<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolliT - Preview</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- App Configuration -->
    <script src="config.js"></script>
    <!-- Coinbase Wallet SDK (optional - only needed for browser extension) -->
    <script src="https://cdn.jsdelivr.net/npm/@coinbase/wallet-sdk@3.0.0/dist/index.js" 
            onload="console.log('Coinbase Wallet SDK loaded'); window.coinbaseSDKLoaded = true;"
            onerror="console.warn('Coinbase Wallet SDK failed to load (optional - only needed for browser extension)'); window.coinbaseSDKLoaded = false; window.coinbaseSDKLoadError = true;"></script>
    <!-- Polyfill for Node.js globals (needed by WalletConnect SDK) -->
    <script>
        // Polyfill process for WalletConnect SDK
        if (typeof process === 'undefined') {
            window.process = { 
                env: { NODE_ENV: 'development' }, 
                version: 'v16.0.0', 
                versions: { node: '16.0.0' },
                browser: true
            };
        }
        // Polyfill Buffer if needed
        if (typeof Buffer === 'undefined') {
            window.Buffer = window.Buffer || {};
        }
    </script>
    <!-- QRCode Library (must load before WalletConnect) -->
    <!-- Using davidshimjs/qrcodejs from GitHub CDN for reliability -->
    <script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/04f46c6a/qrcode.min.js"></script>
    <script>
        // Fallback if GitHub CDN fails
        if (typeof QRCode === 'undefined') {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = 'https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js';
            fallbackScript.onload = function() {
                console.log('QRCode loaded from fallback CDN');
            };
            document.head.appendChild(fallbackScript);
        }
    </script>
    <script>
        // qrcodejs uses a different API - create a wrapper to match our expected API
        (function() {
            function setupQRCode() {
                // Check if QRCode library loaded
                console.log('Checking for QRCode library...');
                console.log('typeof QRCode:', typeof QRCode);
                console.log('window.QRCode:', typeof window.QRCode);
                
                // qrcodejs exposes QRCode as a constructor function
                // Check if it's available and is a function
                const QRCodeConstructor = typeof QRCode !== 'undefined' ? QRCode : (typeof window.QRCode !== 'undefined' ? window.QRCode : null);
                
                if (QRCodeConstructor && typeof QRCodeConstructor === 'function') {
                    console.log('‚úÖ QRCode constructor found');
                    
                    // qrcodejs API: new QRCode(element, options)
                    // We need: QRCode.toCanvas(canvas, text, options, callback)
                    window.QRCode = {
                        toCanvas: function(canvas, text, options, callback) {
                            // Handle different call signatures
                            if (typeof options === 'function') {
                                callback = options;
                                options = {};
                            }
                            
                            const opts = options || {};
                            const width = opts.width || 256;
                            
                            try {
                                // Create a temporary div to render QR code
                                const tempDiv = document.createElement('div');
                                tempDiv.style.position = 'absolute';
                                tempDiv.style.left = '-9999px';
                                tempDiv.style.width = width + 'px';
                                tempDiv.style.height = width + 'px';
                                document.body.appendChild(tempDiv);
                                
                                // Build options for qrcodejs
                                const qrOptions = {
                                    text: text,
                                    width: width,
                                    height: width,
                                    colorDark: opts.color?.dark || '#000000',
                                    colorLight: opts.color?.light || '#FFFFFF'
                                };
                                
                                // Add correctLevel only if it exists
                                if (QRCodeConstructor.CorrectLevel) {
                                    if (QRCodeConstructor.CorrectLevel.M !== undefined) {
                                        qrOptions.correctLevel = QRCodeConstructor.CorrectLevel.M;
                                    } else if (QRCodeConstructor.CorrectLevel.L !== undefined) {
                                        qrOptions.correctLevel = QRCodeConstructor.CorrectLevel.L;
                                    }
                                }
                                
                                // Create QR code instance using the constructor we found
                                let qr;
                                try {
                                    qr = new QRCodeConstructor(tempDiv, qrOptions);
                                    console.log('QR code instance created');
                                } catch(constructorError) {
                                    console.error('QRCode constructor error:', constructorError);
                                    console.log('QRCodeConstructor type:', typeof QRCodeConstructor);
                                    if (tempDiv.parentNode) document.body.removeChild(tempDiv);
                                    if (callback) callback(new Error('QRCode constructor failed: ' + constructorError.message));
                                    return;
                                }
                                
                                // Wait for QR code to render, then copy to canvas
                                setTimeout(function() {
                                    try {
                                        const img = tempDiv.querySelector('img');
                                        if (img && img.complete) {
                                            const ctx = canvas.getContext('2d');
                                            canvas.width = width;
                                            canvas.height = width;
                                            ctx.drawImage(img, 0, 0, width, width);
                                            document.body.removeChild(tempDiv);
                                            if (callback) callback(null);
                                        } else {
                                            // If no img, try to get the canvas from qrcodejs
                                            const qrCanvas = tempDiv.querySelector('canvas');
                                            if (qrCanvas) {
                                                const ctx = canvas.getContext('2d');
                                                canvas.width = width;
                                                canvas.height = width;
                                                ctx.drawImage(qrCanvas, 0, 0, width, width);
                                                document.body.removeChild(tempDiv);
                                                if (callback) callback(null);
                                            } else {
                                                document.body.removeChild(tempDiv);
                                                if (callback) callback(new Error('Failed to render QR code'));
                                            }
                                        }
                                    } catch(e) {
                                        if (tempDiv.parentNode) {
                                            document.body.removeChild(tempDiv);
                                        }
                                        if (callback) callback(e);
                                    }
                                }, 100);
                            } catch(e) {
                                console.error('QRCode generation error:', e);
                                if (callback) callback(e);
                            }
                        }
                    };
                    window.qrcodeLoaded = true;
                    console.log('‚úÖ QRCode (qrcodejs) wrapper created');
                } else {
                    // Wait and try again
                    setTimeout(setupQRCode, 500);
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupQRCode);
            } else {
                setupQRCode();
            }
        })();
    </script>
    <!-- WalletConnect SDK v2 - Using ES module approach with dynamic import fallback -->
    <script type="module">
        // Try to use ES modules if available
        try {
            // This will only work if the browser supports ES modules and the CDN provides them
            // For now, we'll use a different approach
            console.log('ES modules available');
        } catch(e) {
            console.warn('ES modules not available, using UMD fallback');
        }
    </script>
    <!-- WalletConnect Core SDK (required dependency) -->
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/core@2.15.0/dist/index.umd.js" 
            onload="console.log('WalletConnect Core SDK script loaded'); window.walletConnectCoreLoaded = true;"
            onerror="console.error('Failed to load WalletConnect Core SDK'); window.walletConnectCoreLoadError = true;"></script>
    <!-- WalletConnect Ethereum Provider SDK v2 -->
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.15.0/dist/index.umd.js" 
            onload="console.log('WalletConnect Ethereum Provider SDK script loaded'); 
                    // Wait a moment for the SDK to initialize
                    setTimeout(function() {
                        // The UMD build should expose EthereumProvider
                        // Check all possible locations
                        let found = false;
                        
                        // Check global scope
                        if (typeof EthereumProvider !== 'undefined') {
                            window.EthereumProvider = EthereumProvider;
                            window.walletConnectSDKLoaded = true;
                            console.log('‚úÖ Found EthereumProvider (global)');
                            found = true;
                        }
                        
                        // Check window
                        if (!found && typeof window.EthereumProvider !== 'undefined') {
                            window.walletConnectSDKLoaded = true;
                            console.log('‚úÖ Found window.EthereumProvider');
                            found = true;
                        }
                        
                        // Check for UMD exports - the SDK might expose it via a namespace
                        if (!found) {
                            // Check all window properties that might contain it
                            const allKeys = Object.keys(window);
                            for (const key of allKeys) {
                                try {
                                    const val = window[key];
                                    if (val && typeof val === 'object') {
                                        // Check for EthereumProvider
                                        if (val.EthereumProvider && typeof val.EthereumProvider === 'function') {
                                            window.EthereumProvider = val.EthereumProvider;
                                            window.walletConnectSDKLoaded = true;
                                            console.log('‚úÖ Found EthereumProvider via', key);
                                            found = true;
                                            break;
                                        }
                                        // Check for default export
                                        if (val.default) {
                                            if (val.default.EthereumProvider && typeof val.default.EthereumProvider === 'function') {
                                                window.EthereumProvider = val.default.EthereumProvider;
                                                window.walletConnectSDKLoaded = true;
                                                console.log('‚úÖ Found EthereumProvider via', key, '.default');
                                                found = true;
                                                break;
                                            }
                                            // Sometimes the default IS the provider
                                            if (typeof val.default === 'function' && val.default.prototype && val.default.prototype.init) {
                                                window.EthereumProvider = val.default;
                                                window.walletConnectSDKLoaded = true;
                                                console.log('‚úÖ Found EthereumProvider as default of', key);
                                                found = true;
                                                break;
                                            }
                                        }
                                    }
                                } catch(e) {
                                    // Ignore errors when checking properties
                                }
                            }
                        }
                        
                        if (!found) {
                            console.warn('‚ö†Ô∏è WalletConnect SDK loaded but EthereumProvider not found');
                            console.log('Available window properties:', Object.keys(window).filter(k => 
                                k.toLowerCase().includes('wallet') || 
                                k.toLowerCase().includes('connect') ||
                                k.toLowerCase().includes('ethereum')
                            ));
                        }
                    }, 500);"
            onerror="console.error('Failed to load WalletConnect Ethereum Provider SDK'); window.walletConnectSDKLoadError = true;"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        .pollit-brand {
            background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }
        /* Hide native calendar icon from datetime-local input */
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            display: none;
            -webkit-appearance: none;
            appearance: none;
        }
        input[type="datetime-local"]::-webkit-inner-spin-button,
        input[type="datetime-local"]::-webkit-outer-spin-button {
            display: none;
            -webkit-appearance: none;
        }
        input[type="datetime-local"] {
            -webkit-appearance: none;
            appearance: none;
        }
        /* Improve datetime-local input styling */
        input[type="datetime-local"]:focus {
            border-color: #9333ea !important;
            box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.1);
        }
        input[type="datetime-local"]:valid {
            color: #ffffff;
        }
        input[type="datetime-local"]:invalid:not(:focus):not(:placeholder-shown) {
            border-color: #ef4444;
        }
        /* Ensure date picker modal is dark */
        #dateTimePickerModal {
            background-color: rgba(0, 0, 0, 0.75) !important;
        }
        #dateTimePickerModal > div {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%) !important;
            color: white !important;
        }
        #dateTimePickerModal select {
            background-color: #161b22 !important;
            color: white !important;
            border-color: #30363d !important;
        }
        #dateTimePickerModal select option {
            background-color: #161b22 !important;
            color: white !important;
        }
        #dateTimePickerModal input[type="number"] {
            background-color: #0d1117 !important;
            color: white !important;
            border-color: #30363d !important;
        }
        #dateTimePickerModal input[type="number"]::-webkit-inner-spin-button,
        #dateTimePickerModal input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            appearance: none;
        }
        #dateTimePickerModal * {
            color: inherit;
        }
        #dateTimePickerModal #calendarGrid > div {
            background-color: transparent !important;
        }
        #dateTimePickerModal button {
            color: white !important;
        }
        /* Force dark theme on all modal elements */
        #dateTimePickerModal,
        #dateTimePickerModal div,
        #dateTimePickerModal h3,
        #dateTimePickerModal p,
        #dateTimePickerModal label,
        #dateTimePickerModal span {
            background-color: transparent !important;
            color: white !important;
        }
        #dateTimePickerModal .rounded-2xl {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%) !important;
        }
        /* Ensure calendar days are visible */
        #dateTimePickerModal #calendarGrid > div:not([style*="background"]) {
            background-color: transparent !important;
        }
        [id^="cat-"].category-selected {
            border-bottom: 2px solid #a855f7 !important;
            border-bottom-left-radius: 0 !important;
            border-bottom-right-radius: 0 !important;
            box-shadow: 0 2px 0 0 #a855f7 !important;
        }
        .how-it-works-link {
            position: relative;
            padding-bottom: 4px;
            transition: all 0.2s ease;
        }
        .how-it-works-link:hover {
            border-bottom: 2px solid #a855f7;
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.05);
            }
        }
        @keyframes numberChange {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        .countdown-number {
            transition: all 0.3s ease;
        }
        .countdown-number.changing {
            animation: numberChange 0.3s ease;
        }
    </style>
</head>
<body class="min-h-screen" style="background-color: #0d1117; color: white;">
    <!-- Header -->
    <header style="background-color: #161b22; border-bottom: 1px solid #30363d; position: sticky; top: 0; z-index: 50;">
        <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8" style="max-width: 1920px;">
            <div class="flex items-center justify-between min-h-16 py-2 gap-6">
                <!-- Logo -->
                <div class="flex flex-col gap-0.5 justify-center">
                    <a href="#" id="logoLink" onclick="window.setActiveTab('Trending'); return false;" class="flex items-center gap-2 hover:opacity-80 transition-opacity cursor-pointer group">
                        <h1 class="text-2xl sm:text-3xl font-bold pollit-brand">
                            P<span class="font-semibold">oll</span><span class="font-bold">i</span>T
                        </h1>
                    </a>
                    <p class="text-[10px] sm:text-xs font-medium opacity-80 group-hover:opacity-100 transition-opacity" style="color: #8b949e; letter-spacing: 0.3px; margin-left: 2px; line-height: 1.2;">Turn your everyday life into a casino!</p>
                </div>

                <!-- Search Bar -->
                <div class="flex-1 max-w-md relative">
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none z-10">
                            <svg class="h-5 w-5" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                            </svg>
                        </div>
                        <input
                            type="text"
                            id="searchInput"
                            placeholder="search polls"
                            autocomplete="off"
                            class="block w-full pl-10 pr-10 py-2 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all"
                            style="background-color: #0d1117; border: 1px solid #30363d; color: white;"
                        />
                        <button
                            id="clearSearchBtn"
                            class="absolute inset-y-0 right-0 pr-3 flex items-center hidden"
                            onclick="clearSearch()"
                        >
                            <svg class="h-5 w-5" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                    <!-- Autocomplete Dropdown -->
                    <div id="autocompleteDropdown" class="absolute top-full left-0 right-0 mt-1 rounded-lg hidden z-50 max-h-80 overflow-y-auto" style="background-color: #161b22; border: 1px solid #30363d; box-shadow: 0 10px 25px rgba(0,0,0,0.5);">
                        <div id="autocompleteList" class="py-2">
                            <!-- Suggestions will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Right Actions -->
                <div class="flex items-center gap-4">
                    <div class="h-6 w-px" style="background-color: #30363d;"></div>
                    <a href="javascript:void(0)" id="howItWorksLink" class="text-sm how-it-works-link" style="color: white; cursor: pointer; border-bottom: 2px solid transparent; transition: border-color 0.2s;" onclick="if(typeof openHowItWorks === 'function') { openHowItWorks(); } else { console.error('openHowItWorks not available'); } return false;">How it works</a>
                    <button id="createMarketBtn" type="button" onclick="if(typeof window.openCreateMarketModal === 'function') { window.openCreateMarketModal(); } else { console.error('openCreateMarketModal not found'); }" class="px-4 py-2 text-white rounded-lg font-medium hover:opacity-90 cursor-pointer transition-opacity" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);">
                        Create Market
                    </button>
                    <button id="menuBtn" class="p-2 hover:opacity-70 rounded-lg transition-opacity" style="background-color: transparent;">
                        <svg class="h-6 w-6" fill="none" stroke="#a855f7" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Menu Sidebar -->
    <div id="menuSidebar" class="fixed top-0 right-0 h-full w-80 z-50 transform translate-x-full transition-transform duration-300" style="background-color: #161b22; border-left: 1px solid #30363d; box-shadow: -2px 0 8px rgba(0,0,0,0.3);">
        <div class="flex flex-col h-full">
            <!-- Close Button -->
            <div class="flex justify-end p-3">
                <button id="closeMenuBtn" onclick="closeMenu()" class="p-1.5 hover:opacity-70 rounded-lg transition-opacity" style="color: white;">
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <!-- Menu Content -->
            <div class="flex-1 overflow-y-auto px-5 pb-5 flex flex-col">
                <!-- User Info (shown when logged in) -->
                <div id="sidebarUserInfo" class="hidden mb-5">
                    <div class="flex items-center gap-4 p-4 rounded-xl transition-all duration-200 hover:scale-[1.02]" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.15) 0%, rgba(124, 58, 237, 0.15) 100%); border: 1px solid rgba(147, 51, 234, 0.3);">
                        <div class="w-14 h-14 rounded-full flex items-center justify-center text-xl font-bold flex-shrink-0 shadow-lg" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);">
                            <span id="sidebarUserInitial" class="text-white"></span>
                        </div>
                        <div class="flex-1 min-w-0">
                            <p class="text-base font-semibold text-white truncate mb-1" id="sidebarUserName">User</p>
                            <p class="text-xs text-gray-400 truncate" id="sidebarUserAddress"></p>
                        </div>
                    </div>
                </div>
                
                <!-- Menu Items -->
                <div class="flex-1 space-y-2">
                    <a href="#" onclick="navigateToHome(); return false;" class="block px-4 py-3 rounded-lg text-white hover:bg-gray-800 transition-colors cursor-pointer font-medium">Home</a>
                    <a href="#" id="accountButton" onclick="if(typeof handleAccountClick === 'function') { handleAccountClick(event); } else if(typeof window.handleAccountClick === 'function') { window.handleAccountClick(event); } else if(typeof navigateToDashboard === 'function') { navigateToDashboard(); } else if(typeof window.navigateToDashboard === 'function') { window.navigateToDashboard(); } else { console.error('Account functions not found'); } return false;" class="block px-4 py-3 rounded-lg text-white hover:bg-gray-800 transition-colors cursor-pointer font-medium">Account</a>
                    <a href="#" onclick="navigateToSettings(); return false;" class="block px-4 py-3 rounded-lg text-white hover:bg-gray-800 transition-colors cursor-pointer font-medium">Settings</a>
                    <a href="#" onclick="navigateToHelp(); return false;" class="block px-4 py-3 rounded-lg text-white hover:bg-gray-800 transition-colors cursor-pointer font-medium">Help & Support</a>
                </div>
                
                <!-- Log In/Out Button at the end -->
                <div class="mt-auto pt-4">
                    <button id="menuLoginBtn" class="w-full px-4 py-3.5 rounded-xl font-semibold text-white hover:scale-[1.02] transition-all duration-200 shadow-lg hover:shadow-xl" style="background-color: #9333ea;">
                        <span class="flex items-center justify-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"></path>
                            </svg>
                            Log In
                        </span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Menu Overlay -->
    <div id="menuOverlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden transition-opacity duration-300"></div>

    <!-- Main Navigation -->
    <nav style="background-color: #161b22; border-bottom: 1px solid #30363d; position: sticky; top: 64px; z-index: 40;">
        <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8" style="max-width: 1920px;">
            <div class="flex items-center gap-2 h-12 overflow-x-auto" style="-ms-overflow-style: none; scrollbar-width: none;">
                <style>
                    .nav-scroll::-webkit-scrollbar { display: none; }
                </style>
                <!-- Tab Navigation -->
                <div class="flex items-center gap-0.5">
                    <button class="px-4 py-2 text-sm font-medium text-white transition-colors flex items-center gap-1.5" style="border-bottom: 2px solid #a855f7;" id="tabTrending">
                        <span style="display: inline-block; filter: hue-rotate(260deg) saturate(2) brightness(0.9);">üî•</span>
                        <span>Trending</span>
                    </button>
                </div>
                
                <!-- Subtle Divider -->
                <div class="h-6 w-px flex-shrink-0" style="background-color: #21262d;"></div>
                
                <!-- Category Filters -->
                <div class="flex items-center flex-1 relative" style="gap: 0; margin-left: 0;">
                    <!-- Left Gradient Fade -->
                    <div id="categoryFadeLeft" class="absolute left-0 top-0 bottom-0 w-6 pointer-events-none z-10 opacity-0 transition-opacity" style="background: linear-gradient(to right, #0d1117 0%, transparent 100%);"></div>
                    <!-- Left Arrow Button -->
                    <button id="categoryScrollLeft" onclick="scrollCategories('left')" class="flex-shrink-0 transition-all opacity-0 pointer-events-none z-20" style="color: #a855f7; background-color: transparent; width: 16px; height: 16px; padding: 0; margin: 0;" onmouseover="this.style.color='#c084fc';" onmouseout="this.style.color='#a855f7';">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="stroke-width: 2;">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                        </svg>
                    </button>
                    <div id="categoryScrollContainer" class="flex items-center gap-1 flex-1 overflow-x-auto nav-scroll" style="flex-wrap: nowrap; scroll-behavior: smooth; margin: 0; padding: 0;">
                        <button id="cat-other" onclick="if(window.filterByCategory) window.filterByCategory('other', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üëø</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Others</span></button>
                        <button id="cat-gaming" onclick="if(window.filterByCategory) window.filterByCategory('gaming', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üéÆ</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Gaming</span></button>
                        <button id="cat-wellness" onclick="if(window.filterByCategory) window.filterByCategory('fitness', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üí™</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Fitness</span></button>
                        <button id="cat-socials" onclick="if(window.filterByCategory) window.filterByCategory('socials', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üéâ</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Socials</span></button>
                        <button id="cat-foodies" onclick="if(window.filterByCategory) window.filterByCategory('foodies', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üçî</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Foodies</span></button>
                        <button id="cat-office" onclick="if(window.filterByCategory) window.filterByCategory('office', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üíº</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Office</span></button>
                    <button id="cat-entertainment" onclick="if(window.filterByCategory) window.filterByCategory('entertainment', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üé¨</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Entertainment</span></button>
                        <button id="cat-sports" onclick="if(window.filterByCategory) window.filterByCategory('sports', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">‚öΩ</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Sports</span></button>
                        <button id="cat-education" onclick="if(window.filterByCategory) window.filterByCategory('education', event)" class="px-3 py-1.5 text-sm flex items-center gap-1.5 rounded-md transition-all flex-shrink-0" style="color: #8b949e; display: flex; flex-wrap: nowrap; white-space: nowrap; word-break: keep-all; overflow: visible;" onmouseover="this.style.color='white'; this.style.backgroundColor='#21262d';" onmouseout="this.style.color='#8b949e'; this.style.backgroundColor='transparent';"><span style="font-size: 16px; line-height: 1; flex-shrink: 0; display: inline-block;">üìö</span><span style="white-space: nowrap; display: inline-block; word-break: keep-all;">Education</span></button>
                </div>
                    <!-- Right Arrow Button -->
                    <button id="categoryScrollRight" onclick="scrollCategories('right')" class="flex-shrink-0 transition-all z-20" style="color: #a855f7; background-color: transparent; width: 16px; height: 16px; padding: 0; margin: 0;" onmouseover="this.style.color='#c084fc';" onmouseout="this.style.color='#a855f7';">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="stroke-width: 2;">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                        </svg>
                    </button>
                    <!-- Right Gradient Fade -->
                    <div id="categoryFadeRight" class="absolute right-0 top-0 bottom-0 w-6 pointer-events-none z-10 transition-opacity" style="background: linear-gradient(to left, #0d1117 0%, transparent 100%);"></div>
                </div>
            </div>
        </nav>

    <!-- Main Content -->

    <!-- Settings Page -->
    <div id="settingsPage" style="display: none; background-color: #0d1117; min-height: 100vh;">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6" style="max-width: 1920px;">
            <!-- Settings Header -->
            <div class="mb-8">
                <div class="flex items-center justify-between mb-6">
                    <div>
                        <h1 class="text-3xl font-bold text-white mb-2">Settings</h1>
                        <p class="text-[#8b949e]">Manage your account preferences and settings</p>
                    </div>
                    <button onclick="closeSettings()" class="p-2 hover:opacity-70 rounded-lg transition-opacity" style="background-color: transparent; color: #8b949e;">
                        <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Settings Form -->
            <form id="settingsForm" class="space-y-6">
                <!-- Account Settings Section -->
                <div class="p-6 rounded-xl" style="background-color: #161b22; border: 1px solid #30363d;">
                    <h2 class="text-xl font-semibold text-white mb-4">Account Settings</h2>
                    
                    <div class="space-y-4">
                        <!-- Username -->
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Username</label>
                            <input type="text" id="settingsUsername" class="w-full px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;" placeholder="Enter username">
                        </div>
                        
                        <!-- Email -->
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Email</label>
                            <input type="email" id="settingsEmail" class="w-full px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;" placeholder="Enter email">
                        </div>
                        
                        <!-- Bio -->
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Bio</label>
                            <textarea id="settingsBio" rows="3" class="w-full px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;" placeholder="Tell us about yourself"></textarea>
                        </div>
                    </div>
                </div>

                <!-- Currency & Payment Section -->
                <div class="p-6 rounded-xl" style="background-color: #161b22; border: 1px solid #30363d;">
                    <h2 class="text-xl font-semibold text-white mb-4">Currency & Payment</h2>
                    
                    <div class="space-y-4">
                        <!-- Currency -->
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Preferred Currency</label>
                            <select id="settingsCurrency" class="w-full px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <option value="USD">USD ($)</option>
                                <option value="EUR">EUR (‚Ç¨)</option>
                                <option value="GBP">GBP (¬£)</option>
                                <option value="JPY">JPY (¬•)</option>
                                <option value="CAD">CAD (C$)</option>
                                <option value="AUD">AUD (A$)</option>
                            </select>
                        </div>
                        
                        <!-- Payment Method -->
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Payment Method</label>
                            <select id="settingsPaymentMethod" class="w-full px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <option value="wallet">Wallet (Crypto)</option>
                                <option value="credit_card">Credit Card</option>
                                <option value="paypal">PayPal</option>
                                <option value="bank_transfer">Bank Transfer</option>
                            </select>
                        </div>
                        
                        <!-- Wallet Address (if using wallet) -->
                        <div id="settingsWalletAddressContainer" class="hidden">
                            <label class="block text-sm font-medium text-white mb-2">Wallet Address</label>
                            <input type="text" id="settingsWalletAddress" class="w-full px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;" placeholder="0x..." readonly>
                        </div>
                    </div>
                </div>

                <!-- Notification Settings Section -->
                <div class="p-6 rounded-xl" style="background-color: #161b22; border: 1px solid #30363d;">
                    <h2 class="text-xl font-semibold text-white mb-4">Notifications</h2>
                    
                    <div class="space-y-4">
                        <!-- Email Notifications -->
                        <div class="flex items-center justify-between">
                            <div>
                                <label class="block text-sm font-medium text-white">Email Notifications</label>
                                <p class="text-xs text-[#8b949e]">Receive email updates about your markets</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="settingsEmailNotifications" class="sr-only peer">
                                <div class="w-11 h-6 rounded-full peer peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 dark:peer-focus:ring-purple-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600" style="background-color: #30363d;"></div>
                            </label>
                        </div>
                        
                        <!-- Push Notifications -->
                        <div class="flex items-center justify-between">
                            <div>
                                <label class="block text-sm font-medium text-white">Push Notifications</label>
                                <p class="text-xs text-[#8b949e]">Receive browser push notifications</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="settingsPushNotifications" class="sr-only peer">
                                <div class="w-11 h-6 rounded-full peer peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 dark:peer-focus:ring-purple-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600" style="background-color: #30363d;"></div>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Save Button -->
                <div class="flex justify-end gap-4">
                    <button type="button" onclick="closeSettings()" class="px-6 py-3 rounded-lg font-medium text-white hover:opacity-90 transition-opacity" style="background-color: #30363d;">
                        Cancel
                    </button>
                    <button type="submit" class="px-6 py-3 rounded-lg font-medium text-white hover:opacity-90 transition-opacity" style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);">
                        Save Changes
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- User Dashboard -->
    <div id="userDashboard" style="display: none; background-color: #0d1117; min-height: 100vh;">
        <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-6" style="max-width: 1920px;">
            <!-- Dashboard Header -->
            <div class="mb-8">
                <div class="flex items-center justify-between mb-6">
                    <div>
                        <h1 class="text-3xl font-bold text-white mb-2">Dashboard</h1>
                        <p class="text-[#8b949e]">Welcome back! Here's your activity overview.</p>
                    </div>
                    <button onclick="closeDashboard()" class="p-2 hover:opacity-70 rounded-lg transition-opacity" style="background-color: transparent; color: #8b949e;">
                        <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
                </div>
            </div>

            <!-- User Info Card -->
            <div class="mb-6 p-6 rounded-xl" style="background-color: #161b22; border: 1px solid #30363d;">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-4">
                        <div class="w-16 h-16 rounded-full flex items-center justify-center text-2xl font-bold" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);">
                            <span id="dashboardUserInitial" class="text-white"></span>
                        </div>
                        <div>
                            <h2 class="text-xl font-semibold text-white mb-1" id="dashboardUserName">User</h2>
                            <p class="text-sm text-[#8b949e]" id="dashboardUserInfo">Loading...</p>
                        </div>
                    </div>
                    <button id="dashboardLogoutBtn" onclick="handleDashboardAuth();" class="px-4 py-2 rounded-lg text-sm font-medium hover:opacity-90 transition-opacity" style="background-color: #dc2626; color: white;">
                        Log Out
                    </button>
                        </div>
                    </div>

            <!-- Stats Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Markets Created -->
                <div class="p-6 rounded-xl transition-all" style="background-color: #161b22; border: 1px solid #30363d;">
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-sm font-medium text-[#8b949e]">Markets Created</span>
                        <button onclick="showMarketsCreatedDetail()" class="flex items-center gap-2 cursor-pointer hover:opacity-70 transition-opacity">
                        <span class="text-2xl">üíº</span>
                            <svg class="w-4 h-4 text-[#8b949e]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                            </svg>
                        </button>
                </div>
                    <p class="text-3xl font-bold text-white mb-3" id="dashboardMarketsCreated">0</p>
                    <div id="dashboardMarketsCreatedList" class="text-xs text-[#8b949e] space-y-1">
                        <!-- Market details will be populated here -->
                    </div>
            </div>

                <!-- Trading Activity Card (Merged Total Volume + Active Positions) -->
                <div class="p-6 rounded-xl cursor-pointer transition-all hover:opacity-90" style="background-color: #161b22; border: 1px solid #30363d;" onclick="showPositionsDetail()">
                    <!-- Total Volume Section -->
                    <div class="mb-4 pb-4 border-b" style="border-color: #30363d;">
                    <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-[#8b949e]">Total Invested</span>
                        <span class="text-2xl">üí∞</span>
        </div>
                        <p class="text-3xl font-bold text-white mb-1" id="dashboardTotalInvested">$0</p>
                        <div id="dashboardTotalPnL" class="text-sm mb-2">
                            <!-- Total P&L will be populated here -->
                        </div>
                        <div id="dashboardVolumeBreakdown" class="text-xs text-[#8b949e] space-y-1">
                            <!-- Breakdown will be populated here -->
                        </div>
                </div>

                    <!-- Active Positions Section -->
                    <div>
                    <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-[#8b949e]">Active Positions</span>
                            <span class="text-2xl">üìà</span>
                        </div>
                        <p class="text-2xl font-bold text-white mb-2" id="dashboardActivePositions">0</p>
                        <div id="dashboardPositionsInfo" class="text-xs text-[#8b949e] space-y-1.5 mb-3">
                            <!-- Positions info will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- My Markets Section -->
            <div class="mb-6">
                <h3 class="text-xl font-semibold text-white mb-4">My Markets</h3>
                <div id="dashboardMyMarkets" class="space-y-4">
                    <!-- Markets will be populated here -->
                </div>
            </div>

            <!-- Markets Created Detail Section -->
            <div id="dashboardMarketsCreatedDetail" class="mb-6" style="display: none;">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-semibold text-white">Your Created Markets</h3>
                    <button onclick="hideMarketsCreatedDetail()" class="p-2 hover:opacity-70 rounded-lg transition-opacity" style="background-color: transparent; color: #8b949e;">
                        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div id="dashboardMarketsCreatedDetailList" class="space-y-3">
                    <!-- Markets will be populated here -->
                </div>
            </div>

            <!-- Active Positions Detail Section -->
            <div id="dashboardPositionsDetail" class="mb-6" style="display: none; visibility: hidden;">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-semibold text-white">Your Active Positions</h3>
                    <button onclick="hidePositionsDetail()" class="p-2 hover:opacity-70 rounded-lg transition-opacity" style="background-color: transparent; color: #8b949e;">
                        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div id="dashboardPositionsList" class="space-y-3">
                    <!-- Positions will be populated here -->
                </div>
            </div>

            <!-- Portfolio/Recent Activity Section -->
            <div id="dashboardPortfolio">
                <h3 class="text-xl font-semibold text-white mb-4">Recent Activity</h3>
                <div id="dashboardRecentActivity" class="space-y-3">
                    <div class="p-4 rounded-lg" style="background-color: #161b22; border: 1px solid #30363d;">
                        <p class="text-sm text-[#8b949e]">No recent activity</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-6" style="max-width: 1920px;">
        <div id="marketsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <!-- Markets will be dynamically rendered here by JavaScript -->
            <div class="rounded-lg p-4 cursor-pointer" style="background-color: #161b22; border: 1px solid #30363d;">
                <div class="flex items-start justify-between mb-3">
                    <div class="flex items-center gap-2">
                        <div class="w-8 h-8 rounded-full flex items-center justify-center text-lg">
                            ‚è∞
        </div>
                        <h3 class="text-sm font-medium text-white line-clamp-2 leading-snug">
                            Will Sarah be late to the meeting?
                </h3>
                </div>
                    <button class="p-1 hover:opacity-70 rounded-lg">
                        <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                        </svg>
                    </button>
                    </div>
                <div class="space-y-2 mb-3">
                    <div class="flex items-center justify-between">
                        <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">On time or early</span>
                        <span class="text-xs font-medium text-white min-w-[2.5rem] text-right">35%</span>
                        <div class="flex gap-1 ml-2">
                            <button class="px-2 py-0.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded font-medium">Yes</button>
                            <button class="px-2 py-0.5 bg-red-600 hover:bg-red-700 text-white text-xs rounded font-medium">No</button>
                    </div>
                    </div>
                    <div class="flex items-center justify-between">
                        <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">Late (5+ minutes)</span>
                        <span class="text-xs font-medium text-white min-w-[2.5rem] text-right">65%</span>
                        <div class="flex gap-1 ml-2">
                            <button class="px-2 py-0.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded font-medium">Yes</button>
                            <button class="px-2 py-0.5 bg-red-600 hover:bg-red-700 text-white text-xs rounded font-medium">No</button>
                        </div>
                    </div>
                </div>
                <div class="flex items-center justify-between pt-3" style="border-top: 1px solid #30363d;">
                    <span class="text-xs" style="color: #8b949e;">$856 Vol.</span>
                    <button class="p-1 hover:opacity-70 rounded">
                        <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Market Card 3 -->
            <div class="rounded-lg p-4 cursor-pointer" style="background-color: #161b22; border: 1px solid #30363d;">
                <div class="flex items-start justify-between mb-3">
                    <div class="flex items-center gap-2">
                        <div class="w-8 h-8 rounded-full flex items-center justify-center text-lg">
                            ‚òï
                        </div>
                        <h3 class="text-sm font-medium text-white line-clamp-2 leading-snug">
                            Will the coffee shop be busy at 3pm?
                </h3>
                </div>
                    <button class="p-1 hover:opacity-70 rounded-lg">
                        <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                        </svg>
                    </button>
                    </div>
                <div class="space-y-2 mb-3">
                    <div class="flex items-center justify-between">
                        <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">Busy (long line)</span>
                        <span class="text-xs font-medium text-white min-w-[2.5rem] text-right">72%</span>
                        <div class="flex gap-1 ml-2">
                            <button class="px-2 py-0.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded font-medium">Yes</button>
                            <button class="px-2 py-0.5 bg-red-600 hover:bg-red-700 text-white text-xs rounded font-medium">No</button>
                    </div>
                    </div>
                    <div class="flex items-center justify-between">
                        <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">Not busy (quick order)</span>
                        <span class="text-xs font-medium text-white min-w-[2.5rem] text-right">28%</span>
                        <div class="flex gap-1 ml-2">
                            <button class="px-2 py-0.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded font-medium">Yes</button>
                            <button class="px-2 py-0.5 bg-red-600 hover:bg-red-700 text-white text-xs rounded font-medium">No</button>
                        </div>
                    </div>
                </div>
                <div class="flex items-center justify-between pt-3" style="border-top: 1px solid #30363d;">
                    <span class="text-xs" style="color: #8b949e;">$423 Vol.</span>
                    <button class="p-1 hover:opacity-70 rounded">
                        <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Market Card 4 -->
            <div class="rounded-lg p-4 cursor-pointer" style="background-color: #161b22; border: 1px solid #30363d;">
                <div class="flex items-start justify-between mb-3">
                    <div class="flex items-center gap-2">
                        <div class="w-8 h-8 rounded-full flex items-center justify-center text-lg">
                            üçΩÔ∏è
                        </div>
                        <h3 class="text-sm font-medium text-white line-clamp-2 leading-snug">
                            Will Mike do the dishes tonight?
                </h3>
                </div>
                    <button class="p-1 hover:opacity-70 rounded-lg">
                        <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                        </svg>
                    </button>
                    </div>
                <div class="space-y-2 mb-3">
                    <div class="flex items-center justify-between">
                        <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">Yes, he will</span>
                        <span class="text-xs font-medium text-white min-w-[2.5rem] text-right">28%</span>
                        <div class="flex gap-1 ml-2">
                            <button class="px-2 py-0.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded font-medium">Yes</button>
                            <button class="px-2 py-0.5 bg-red-600 hover:bg-red-700 text-white text-xs rounded font-medium">No</button>
                    </div>
                </div>
                    <div class="flex items-center justify-between">
                        <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">No, he won't</span>
                        <span class="text-xs font-medium text-white min-w-[2.5rem] text-right">72%</span>
                        <div class="flex gap-1 ml-2">
                            <button class="px-2 py-0.5 bg-green-600 hover:bg-green-700 text-white text-xs rounded font-medium">Yes</button>
                            <button class="px-2 py-0.5 bg-red-600 hover:bg-red-700 text-white text-xs rounded font-medium">No</button>
                        </div>
                    </div>
                </div>
                <div class="flex items-center justify-between pt-3" style="border-top: 1px solid #30363d;">
                    <span class="text-xs" style="color: #8b949e;">$234 Vol.</span>
                    <button class="p-1 hover:opacity-70 rounded">
                        <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
            </div>
        </div>
    </main>

    <!-- Create Market Modal -->
    <!-- Login Modal -->
    <div id="loginModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1000;">
        <div class="rounded-lg max-w-md w-full" style="background-color: #161b22; border: 1px solid #30363d;">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white">Log In</h2>
                    <button id="closeLoginModal" class="text-[#8b949e] hover:text-white text-2xl">‚úï</button>
                </div>
                
                <p class="text-[#8b949e] mb-6 text-sm">Choose your preferred login method</p>
                
                <div class="space-y-3">
                    <!-- Google Login -->
                    <button id="googleLoginBtn" class="w-full px-4 py-3 rounded-lg font-medium text-white hover:opacity-90 transition-opacity flex items-center justify-center gap-3" style="background-color: #4285f4; border: 1px solid #4285f4;">
                        <svg class="w-5 h-5" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        <span>Continue with Google</span>
                    </button>
                    
                    <!-- Apple Login -->
                    <button id="appleLoginBtn" class="w-full px-4 py-3 rounded-lg font-medium text-white hover:opacity-90 transition-opacity flex items-center justify-center gap-3" style="background-color: #000000; border: 1px solid #30363d;">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M17.05 20.28c-.98.95-2.05.88-3.08.4-1.09-.5-2.08-.48-3.24 0-1.44.62-2.2.44-3.06-.4C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
                        </svg>
                        <span>Continue with Apple</span>
                    </button>
                    
                    <!-- Wallet Connect -->
                    <button id="walletConnectBtn" class="w-full px-4 py-3 rounded-lg font-medium text-white hover:opacity-90 transition-opacity flex items-center justify-center gap-3" style="background-color: #3b99fc; border: 1px solid #3b99fc;">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                        </svg>
                        <span>Connect Wallet</span>
                    </button>
                </div>
                
                <div id="loginStatus" class="mt-4 text-sm text-center hidden"></div>
            </div>
        </div>
    </div>

    <!-- Wallet Connect Modal with QR Code -->
    <div id="walletConnectModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1001;">
        <div class="rounded-lg max-w-md w-full" style="background-color: #161b22; border: 1px solid #30363d;">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white">Connect Wallet</h2>
                    <button id="closeWalletModal" class="text-[#8b949e] hover:text-white text-2xl transition-colors">‚úï</button>
                </div>
                
                <div class="space-y-4">
                    <!-- Coinbase Wallet Connection -->
                    <div>
                        <p class="text-sm font-medium text-[#8b949e] mb-3 uppercase tracking-wide">Connect to Base</p>
                        <div class="space-y-2">
                            <button id="coinbaseExtensionBtn" class="w-full px-4 py-3.5 rounded-xl font-medium text-white hover:opacity-90 transition-all flex items-center justify-center gap-3 shadow-lg hover:shadow-xl" style="background-color: #0052ff; border: 1px solid #0052ff;">
                                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.568 8.16c-.169 0-.315.06-.449.165l-2.794 1.95-1.843-1.844a.526.526 0 0 0-.449-.165c-.169 0-.315.06-.449.165L8.16 10.08c-.315.225-.449.6-.315.975l1.05 3.15c.06.165.225.315.449.315.169 0 .315-.06.449-.165l2.794-1.95 1.843 1.844c.135.105.315.165.449.165.169 0 .315-.06.449-.165l2.794-1.95c.315-.225.449-.6.315-.975l-1.05-3.15a.526.526 0 0 0-.449-.315z"/>
                                </svg>
                                <span class="font-semibold">Coinbase Wallet</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Divider -->
                    <div class="flex items-center my-6">
                        <div class="flex-1 border-t" style="border-color: #30363d;"></div>
                        <span class="px-4 text-xs font-medium text-[#8b949e] uppercase tracking-wide">OR</span>
                        <div class="flex-1 border-t" style="border-color: #30363d;"></div>
                    </div>
                    
                    <!-- WalletConnect QR Code -->
                    <div>
                        <p class="text-sm font-medium text-[#8b949e] mb-3 uppercase tracking-wide">Wallet Connect</p>
                        <div id="walletConnectQR" class="w-full p-6 rounded-xl" style="background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); border: 1px solid #30363d;">
                            <div id="qrCodeContainer" class="flex flex-col items-center justify-center">
                                <!-- Loading State -->
                                <div id="qrCodeLoading" class="flex flex-col items-center justify-center py-8">
                                    <div class="animate-spin rounded-full h-12 w-12 border-4 border-[#3b99fc] border-t-transparent mb-4"></div>
                                    <p class="text-white text-sm font-medium">Generating QR code...</p>
                                </div>
                                
                                <!-- QR Code Display -->
                                <div id="qrCodeDisplay" class="hidden flex-col items-center justify-center text-center">
                                    <div class="inline-block p-5 rounded-2xl mb-5 shadow-2xl" style="background-color: white;">
                                        <canvas id="qrCodeCanvas" width="256" height="256" class="block"></canvas>
                                    </div>
                                    <h3 class="text-white text-base font-semibold mb-1">Scan with WalletConnect</h3>
                                    <p class="text-[#8b949e] text-xs mb-4">Scan to connect to Base network</p>
                                    <div class="flex items-center gap-2 text-[#8b949e] text-xs">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        <span>Open your wallet app and scan</span>
                                    </div>
                                </div>
                                
                                <!-- Error/Retry State -->
                                <div id="qrCodeError" class="hidden flex-col items-center justify-center text-center py-8">
                                    <svg class="w-16 h-16 text-red-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <p class="text-white text-sm font-medium mb-2">Failed to generate QR code</p>
                                    <p class="text-[#8b949e] text-xs mb-4">Please try again</p>
                                    <button id="generateQRBtn" type="button" class="px-6 py-2.5 rounded-lg text-white text-sm font-medium hover:opacity-90 transition-all cursor-pointer shadow-lg" style="background-color: #3b99fc; border: 1px solid #3b99fc;">
                                        Retry QR Code
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="walletConnectStatus" class="mt-4 text-sm text-center hidden"></div>
            </div>
        </div>
    </div>

    <div id="createMarketModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1000;">
        <div class="rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto" style="background-color: #161b22; border: 1px solid #30363d;">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white">Create Market</h2>
                    <button id="closeCreateModal" type="button" class="text-[#8b949e] hover:text-white text-2xl cursor-pointer transition-colors" style="background: none; border: none; padding: 0.5rem;">‚úï</button>
                </div>

                <form id="createMarketForm">
                    <!-- Step 1: Basic Info -->
                    <div id="step1" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-white mb-1">
                                Category *
                            </label>
                            <select
                                required
                                id="marketCategory"
                                class="w-full px-3 py-2 rounded-lg text-white"
                                style="background-color: #0d1117; border: 1px solid #30363d;"
                            >
                                <option value="">Select a category</option>
                                <option value="other">üëø Others</option>
                                <option value="gaming">üéÆ Gaming</option>
                                <option value="wellness">üí™ Fitness</option>
                                <option value="socials">üéâ Socials</option>
                                <option value="foodies">üçî Foodies</option>
                                <option value="office">üíº Office</option>
                                <option value="entertainment">üé¨ Entertainment</option>
                                <option value="sports">‚öΩ Sports</option>
                                <option value="education">üìö Education</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-white mb-1">
                                Title *
                            </label>
                            <input
                                type="text"
                                required
                                id="marketTitle"
                                class="w-full px-3 py-2 rounded-lg text-white"
                                style="background-color: #0d1117; border: 1px solid #30363d;"
                                placeholder="e.g., Will it rain today?"
                            />
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-white mb-1">
                                Resolution Criteria * (up to 99 options)
                            </label>
                            <div id="resolutionCriteriaList" class="space-y-2">
                                <div class="flex gap-2">
                                    <input
                                        type="text"
                                required
                                        class="flex-1 px-3 py-2 rounded-lg text-white resolution-criteria-input"
                                        style="background-color: #0d1117; border: 1px solid #30363d;"
                                        placeholder="Resolution option 1"
                                        data-index="0"
                                    />
                            </div>
                                <div class="flex gap-2">
                            <input
                                        type="text"
                                required
                                        class="flex-1 px-3 py-2 rounded-lg text-white resolution-criteria-input"
                                        style="background-color: #0d1117; border: 1px solid #30363d;"
                                        placeholder="Resolution option 2"
                                        data-index="1"
                            />
                        </div>
                            </div>
                        <button
                            type="button"
                                onclick="addResolutionCriteria()"
                                class="mt-2 text-sm hover:opacity-80"
                                style="color: #a855f7;"
                                id="addResolutionBtn"
                            >
                                + Add Resolution Option
                        </button>
                            <p class="mt-2 text-sm" style="color: #8b949e;" id="resolutionCount">
                                2 resolution options added
                            </p>
                    </div>

                        <div>
                            <label class="block text-sm font-medium text-white mb-1">
                                Short description
                            </label>
                            <textarea
                                id="marketDescription"
                                class="w-full px-3 py-2 rounded-lg text-white"
                                style="background-color: #0d1117; border: 1px solid #30363d;"
                                rows="2"
                                placeholder="Describe the market..."
                            ></textarea>
                            </div>

                        <div>
                            <label class="block text-sm font-medium text-white mb-2">
                                End Time *
                            </label>
                            <div class="relative group mb-1">
                                <input
                                    type="datetime-local"
                                    required
                                    id="endTime"
                                    class="w-full py-3 rounded-lg text-white transition-all duration-200"
                                    style="background-color: #0d1117; border: 1px solid #30363d; font-size: 14px; outline: none; cursor: pointer; margin-bottom: 0; padding-left: 1rem; padding-right: 3rem;"
                                    min=""
                                    step="60"
                                    onfocus="this.min = new Date().toISOString().slice(0, 16); this.style.borderColor='#9333ea'; this.style.boxShadow='0 0 0 3px rgba(147, 51, 234, 0.1)'; if(this.showPicker) { try { this.showPicker(); } catch(e) {} }"
                                    onblur="if(!this.value) { this.style.borderColor='#30363d'; this.style.boxShadow='none'; } else { this.style.boxShadow='none'; }"
                                    onmouseenter="if(!this.value) { this.style.borderColor='#9333ea'; }"
                                    onmouseleave="if(!this.value && document.activeElement !== this) { this.style.borderColor='#30363d'; }"
                                    oninput="const placeholder = document.getElementById('endTimePlaceholder'); if(placeholder && this.value) { placeholder.style.display='none'; } else if(placeholder) { placeholder.style.display='block'; }"
                                />
                                <div id="calendarIconWrapper" class="absolute right-3 top-1/2 transform -translate-y-1/2 pointer-events-none transition-all duration-200 z-10">
                                    <svg class="w-5 h-5 transition-all duration-200" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                    </svg>
                                </div>
                                <div id="endTimePlaceholder" class="absolute left-4 top-1/2 transform -translate-y-1/2 pointer-events-none transition-all duration-200 z-0" style="color: #6b7280; font-size: 14px; max-width: calc(100% - 4rem); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    Select date and time
                                </div>
                            </div>
                            <div class="mt-8 min-h-[20px] relative z-10">
                                <p class="text-xs flex items-center gap-1.5" style="color: #8b949e; margin-top: 0;">
                                    <svg class="w-3.5 h-3.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                    Click the field to select when this poll will close. Must be a future date and time.
                                </p>
                                </div>
                            <div id="endTimeDisplay" class="mt-3 p-3 rounded-lg hidden transition-all" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%); border: 1px solid rgba(16, 185, 129, 0.3);">
                                <div class="flex items-center gap-2.5">
                                    <div class="flex-shrink-0 w-5 h-5 rounded-full flex items-center justify-center" style="background-color: #10b981;">
                                        <svg class="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7" />
                                        </svg>
                                    </div>
                                    <div class="flex-1">
                                        <span class="text-xs font-medium block mb-0.5" style="color: #10b981;">Date & Time Selected</span>
                                        <span id="endTimeDisplayValue" class="text-sm font-medium text-white"></span>
                                    </div>
                                </div>
                            </div>
                        </div>

                            <button
                                type="button"
                                id="createMarketFinalBtn"
                                onclick="showConfirmationModal()"
                                class="w-full px-4 py-2 text-white rounded-lg font-medium hover:opacity-90 cursor-pointer"
                                style="background-color: #9333ea;"
                            >
                                Review & Confirm
                            </button>
                    </div>

                </form>
            </div>
        </div>
    </div>

    <!-- Invite Link Modal -->
    <div id="inviteLinkModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1001;">
        <div class="rounded-lg max-w-md w-full" style="background-color: #161b22; border: 1px solid #30363d;">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-white">Private Market Created!</h2>
                    <button id="closeInviteModal" class="text-[#8b949e] hover:text-white text-2xl">‚úï</button>
                </div>
                <p class="text-sm text-gray-300 mb-4" id="inviteMarketTitle"></p>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-white mb-2">Invite Link</label>
                    <div class="flex gap-2">
                        <input type="text" id="inviteLinkInput" readonly class="flex-1 px-3 py-2 rounded-lg text-white text-sm" style="background-color: #0d1117; border: 1px solid #30363d;" />
                        <button id="copyInviteLink" class="px-4 py-2 rounded-lg text-white font-medium hover:opacity-90 transition-opacity" style="background-color: #9333ea;">
                            Copy
                        </button>
                    </div>
                </div>
                <p class="text-xs text-gray-400 mb-4">Share this link with people you want to invite to your private market.</p>
                <button id="closeInviteModalBtn" class="w-full px-4 py-2 text-white rounded-lg font-medium hover:opacity-90 transition-opacity" style="background-color: #9333ea;">
                    Done
                </button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1002;">
        <div class="rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto" style="background-color: #161b22; border: 1px solid #30363d;">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white">Review Your Market</h2>
                    <button id="closeConfirmationModal" type="button" class="text-[#8b949e] hover:text-white text-2xl cursor-pointer transition-colors" style="background: none; border: none; padding: 0.5rem;">‚úï</button>
                </div>
                
                <div class="space-y-4">
                    <div class="space-y-3 p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                        <div>
                            <span class="text-sm text-gray-400">Category:</span>
                            <span class="text-white ml-2" id="confirmCategory"></span>
                        </div>
                        <div>
                            <span class="text-sm text-gray-400">Title:</span>
                            <span class="text-white ml-2 font-medium" id="confirmTitle"></span>
                        </div>
                        <div>
                            <span class="text-sm text-gray-400">Description:</span>
                            <span class="text-white ml-2" id="confirmDescription"></span>
                        </div>
                        <div>
                            <span class="text-sm text-gray-400">Resolution Options:</span>
                            <ul class="text-white ml-2 mt-1 list-disc list-inside" id="confirmOutcomes"></ul>
                        </div>
                        <div>
                            <span class="text-sm text-gray-400">End Time:</span>
                            <span class="text-white ml-2" id="confirmEndTime"></span>
                        </div>
                    </div>

                    <div class="p-4 rounded-lg border-2" style="background-color: rgba(147, 51, 234, 0.1); border-color: #9333ea;">
                        <div class="flex items-start gap-3">
                            <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #fbbf24;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                            <div>
                                <p class="text-sm text-white mb-1 font-semibold">
                                    ‚ö†Ô∏è Onchain Transaction Required
                                </p>
                                <p class="text-xs text-gray-300">
                                    Creating this market requires an onchain transaction. You'll need to connect your wallet and approve the transaction. Gas fees will apply.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-4 pt-4">
                        <button
                            type="button"
                            id="cancelConfirmationBtn"
                            onclick="closeConfirmationModal()"
                            class="flex-1 px-4 py-2 border rounded-lg hover:opacity-80 text-white cursor-pointer transition-opacity"
                            style="border-color: #30363d;"
                        >
                            Cancel
                        </button>
                        <button
                            type="button"
                            id="confirmCreateMarketBtn"
                            onclick="executeOnchainMarketCreation()"
                            class="flex-1 px-4 py-2 text-white rounded-lg font-medium hover:opacity-90 cursor-pointer transition-opacity"
                            style="background-color: #9333ea;"
                        >
                            Confirm & Create on Chain
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Poll Detail Page -->
    <div id="pollDetailPage" style="display: none; background-color: #0d1117; min-height: 100vh;">
        <div class="container mx-auto px-4 py-6 max-w-7xl">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Left Column: Market Info -->
                <div class="lg:col-span-2 space-y-6">
                    <!-- Header Section -->
                    <div>
                        <div class="flex items-center gap-3 mb-4">
                            <button onclick="closePollDetail()" class="p-2 hover:opacity-70 rounded-lg transition-opacity" style="background-color: #161b22; border: 1px solid #30363d;">
                                <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                                </svg>
                            </button>
                            <div class="flex items-center gap-3 flex-1">
                                <div id="pollHeaderAvatars" class="flex items-center gap-2">
                                    <!-- Avatars will be populated dynamically -->
                        </div>
                                <h1 id="pollDetailTitle" class="text-2xl font-bold text-white flex-1"></h1>
                            </div>
                        </div>
                        
                        <!-- Market Context (Description) - Below Title -->
                        <div class="mb-4">
                            <p id="marketContextText" class="text-sm text-gray-400">Market context will be generated based on the poll details.</p>
                        </div>
                        
                        <div class="flex flex-col gap-2 text-sm mb-4">
                            <div id="pollEndTime" class="flex items-center gap-2 font-medium">
                                <!-- Countdown will be populated dynamically -->
                            </div>
                            <div id="pollCreator" class="flex items-center gap-2" style="color: #8b949e;">
                                <!-- Created by will be populated dynamically -->
                            </div>
                        </div>
                        </div>
                        
                        <!-- Outcomes List Section - Above Chart -->
                        <div class="mb-6">
                            <div id="pollOutcomesList" class="grid grid-cols-2 gap-4"></div>
                        </div>
                        
                        <!-- Chart Section -->
                        <div class="rounded-lg p-4 mb-6" style="background-color: #161b22; border: 1px solid #30363d;">
                            <div class="mb-4">
                                <div class="flex items-center justify-between mb-2">
                                    <span id="pollVolume" class="font-medium text-white"></span>
                                    <div class="flex gap-2">
                                    <button id="timeRange1H" class="px-3 py-1 text-xs rounded text-gray-400 hover:text-white hover:bg-gray-800" onclick="changeChartTimeRange('1H')">1H</button>
                                    <button id="timeRange6H" class="px-3 py-1 text-xs rounded text-gray-400 hover:text-white hover:bg-gray-800" onclick="changeChartTimeRange('6H')">6H</button>
                                    <button id="timeRange1D" class="px-3 py-1 text-xs rounded text-gray-400 hover:text-white hover:bg-gray-800" onclick="changeChartTimeRange('1D')">1D</button>
                                    <button id="timeRange1W" class="px-3 py-1 text-xs rounded text-gray-400 hover:text-white hover:bg-gray-800" onclick="changeChartTimeRange('1W')">1W</button>
                                    <button id="timeRange1M" class="px-3 py-1 text-xs rounded text-gray-400 hover:text-white hover:bg-gray-800" onclick="changeChartTimeRange('1M')">1M</button>
                                    <button id="timeRangeALL" class="px-3 py-1 text-xs rounded text-white bg-gray-800" onclick="changeChartTimeRange('ALL')">ALL</button>
                                    </div>
                                </div>
                                <div id="pollLegend" class="flex flex-wrap items-center gap-4 text-sm">
                                    <!-- Will be populated dynamically -->
                                </div>
                            </div>
                        <div id="probabilityChart" style="height: 250px; position: relative;">
                            <canvas id="chartCanvas" width="800" height="250"></canvas>
                        </div>
                    </div>

                    <!-- Comments Section -->
                    <div class="rounded-lg" style="background-color: #161b22; border: 1px solid #30363d;">
                        <div class="p-4 border-b" style="border-color: #30363d;">
                            <div class="flex items-center gap-4">
                                <button id="topHoldersTab" class="text-white font-medium border-b-2 border-white pb-2">Top Holders</button>
                                <button id="commentsTab" class="text-gray-400 hover:text-white pb-2">Comments (<span id="commentsCount">0</span>)</button>
                            </div>
                            </div>
                        <div class="p-4">
                            <!-- Top Holders Content -->
                            <div id="topHoldersContent" class="space-y-0" style="max-height: 400px; overflow-y: auto;">
                                <!-- Top holders will be populated here -->
                            </div>
                            
                            <!-- Comments Content (hidden by default) -->
                            <div id="commentsContent" style="display: none;">
                            <!-- Comment Input -->
                            <div class="mb-4">
                                <textarea id="commentInput" placeholder="Add a comment" class="w-full px-4 py-3 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d; min-height: 80px;"></textarea>
                                <div class="flex justify-between items-center mt-2">
                                    <p class="text-xs text-gray-400">Beware of external links.</p>
                                        <button id="postCommentBtn" type="button" class="px-4 py-2 rounded-lg font-medium text-white" style="background-color: #9333ea; cursor: pointer;">Post</button>
                        </div>
                            </div>
                            <!-- Comments List -->
                            <div id="commentsList" class="space-y-4"></div>
                            </div>
                        </div>
                    </div>

                <!-- Right Column: Related Markets Only -->
                <div class="lg:col-span-1">
                    <!-- Related Markets -->
                    <div class="rounded-lg p-5" style="background-color: #161b22; border: 1px solid #30363d;">
                        <div class="flex items-center gap-2 mb-5">
                            <button id="relatedTabTrending" class="px-4 py-2 text-sm font-medium rounded-lg text-white transition-all duration-200 ease-in-out" style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%); box-shadow: 0 2px 8px rgba(147, 51, 234, 0.3);" onclick="setRelatedTab('Trending')">Trending</button>
                            <button id="relatedTabRelated" class="px-4 py-2 text-sm font-medium rounded-lg text-gray-400 hover:text-white transition-all duration-200 ease-in-out hover:bg-gray-800" style="background: transparent;" onclick="setRelatedTab('Related')">Related</button>
                        </div>
                        <div id="relatedMarkets" class="space-y-2.5">
                            <!-- Related markets will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Trading Modal -->
    <div id="tradingModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1000;">
        <div class="bg-[#161b22] rounded-lg border-2 border-[#30363d] w-full max-w-md p-6 relative">
            <!-- Close Button -->
            <button id="closeTradingModalBtn" type="button" class="absolute top-4 right-4 p-2 hover:opacity-70 rounded-lg transition-opacity" style="color: #8b949e; cursor: pointer; z-index: 10;">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            
            <!-- Trading Panel Content -->
                        <div class="text-center mb-6">
                <div id="tradingModalEmoji" class="w-16 h-16 rounded-full flex items-center justify-center text-3xl mx-auto mb-2"></div>
                <p class="text-sm font-medium text-white" id="tradingModalTitle"></p>
                        </div>
                        
                        <div class="flex gap-2 mb-4">
                <button id="modalBuyBtn" type="button" class="flex-1 px-4 py-2 rounded-lg font-medium text-white transition-all" style="background-color: #9333ea; border: 2px solid #3b82f6; cursor: pointer;">Buy</button>
                <button id="modalSellBtn" type="button" class="flex-1 px-4 py-2 rounded-lg font-medium text-gray-400 hover:text-white transition-all" style="background-color: #0d1117; border: 1px solid #30363d; cursor: pointer;">Sell</button>
                        </div>

            <div id="tradingModalOutcomes" class="space-y-2 mb-4"></div>

                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <label class="block text-sm text-gray-400">Amount</label>
                                <span id="ownedSharesDisplay" class="text-xs text-gray-500" style="display: none;">Owned: $0</span>
                            </div>
                            <div class="flex items-center gap-2 mb-2">
                    <input type="text" id="modalTradeAmount" value="$0" class="flex-1 px-4 py-2 rounded-lg text-white" style="background-color: #0d1117; border: 1px solid #30363d;">
                            </div>
                            <div class="flex gap-2">
                    <button id="addAmount1" type="button" class="flex-1 px-3 py-1.5 text-xs rounded text-gray-400 hover:text-white" style="background-color: #0d1117; border: 1px solid #30363d; cursor: pointer;">+$1</button>
                    <button id="addAmount20" type="button" class="flex-1 px-3 py-1.5 text-xs rounded text-gray-400 hover:text-white" style="background-color: #0d1117; border: 1px solid #30363d; cursor: pointer;">+$20</button>
                    <button id="addAmount100" type="button" class="flex-1 px-3 py-1.5 text-xs rounded text-gray-400 hover:text-white" style="background-color: #0d1117; border: 1px solid #30363d; cursor: pointer;">+$100</button>
                    <button id="setMaxAmountBtn" type="button" class="flex-1 px-3 py-1.5 text-xs rounded text-gray-400 hover:text-white" style="background-color: #0d1117; border: 1px solid #30363d; cursor: pointer;">Max</button>
                            </div>
                        </div>

            <button id="confirmTradeBtn" onclick="if(window.executeTrade) { window.executeTrade().then(() => { if(window.closeTradingModal) window.closeTradingModal(); }).catch(err => console.error('Trade error:', err)); }" class="w-full px-4 py-3 rounded-lg font-semibold text-white mb-3 transition-opacity hover:opacity-90" style="background-color: #2563eb;">Trade</button>
            <p class="text-xs text-gray-400 text-center">By trading, you agree to the <a href="terms-of-use.html" target="_blank" class="text-blue-400 hover:text-blue-300 underline" style="color: #60a5fa;">Terms of Use</a>.</p>
        </div>
    </div>

    <!-- How It Works Section -->
    <div id="howItWorksPage" style="display: none; background-color: #0d1117; min-height: 100vh; width: 100%;">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
            <!-- Header -->
            <div class="mb-8">
                <h1 class="text-4xl font-bold mb-4 pollit-brand">How It Works</h1>
                <p class="text-xl text-gray-400">Learn how PolliT turns your everyday life into a casino</p>
            </div>

            <!-- Main Content -->
            <div class="space-y-12">
                <!-- Section 1: What is PolliT -->
                <section class="rounded-lg p-8" style="background-color: #161b22; border: 1px solid #30363d;">
                    <div class="flex items-start gap-4 mb-6">
                        <div class="flex-shrink-0 w-12 h-12 rounded-lg flex items-center justify-center text-2xl" style="background-color: #9333ea; color: white;">
                            1
                        </div>
                        <div>
                            <h2 class="text-2xl font-bold text-white mb-3">What is PolliT?</h2>
                            <p class="text-gray-300 leading-relaxed">
                                PolliT is a prediction market platform where you can create and trade on polls about everyday life. 
                                Whether it's predicting the weather, guessing if your friend will be late, or betting on daily outcomes, 
                                PolliT makes it fun and engaging to predict the future.
                            </p>
                        </div>
                    </div>
                </section>

                <!-- Section 2: Creating a Poll -->
                <section class="rounded-lg p-8" style="background-color: #161b22; border: 1px solid #30363d;">
                    <div class="flex items-start gap-4 mb-6">
                        <div class="flex-shrink-0 w-12 h-12 rounded-lg flex items-center justify-center text-2xl" style="background-color: #9333ea; color: white;">
                            2
                        </div>
                        <div>
                            <h2 class="text-2xl font-bold text-white mb-3">Creating a Poll</h2>
                            <p class="text-gray-300 leading-relaxed mb-4">
                                Creating a poll is simple and straightforward:
                            </p>
                            <ul class="space-y-3 text-gray-300">
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span><strong class="text-white">Title:</strong> Give your poll a clear, descriptive title</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span><strong class="text-white">Resolution Criteria:</strong> Define up to 99 possible outcomes for your poll</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span><strong class="text-white">Description:</strong> Add context about what the poll is about</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span><strong class="text-white">End Time:</strong> Set when the poll will close and resolve</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span><strong class="text-white">Visibility:</strong> Choose if your poll is public or private</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Section 3: Trading on Polls -->
                <section class="rounded-lg p-8" style="background-color: #161b22; border: 1px solid #30363d;">
                    <div class="flex items-start gap-4 mb-6">
                        <div class="flex-shrink-0 w-12 h-12 rounded-lg flex items-center justify-center text-2xl" style="background-color: #9333ea; color: white;">
                            3
                        </div>
                        <div>
                            <h2 class="text-2xl font-bold text-white mb-3">Trading on Polls</h2>
                            <p class="text-gray-300 leading-relaxed mb-4">
                                Once a poll is created, you can trade on different outcomes:
                            </p>
                            <div class="space-y-4">
                                <div class="p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                    <h3 class="text-lg font-semibold text-white mb-2">Buying Shares</h3>
                                    <p class="text-gray-300 text-sm">
                                        When you buy shares of an outcome, you're betting that it will happen. If you're right, 
                                        you'll receive a payout based on the final probability when the poll resolves.
                                    </p>
                                </div>
                                <div class="p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                    <h3 class="text-lg font-semibold text-white mb-2">Selling Shares</h3>
                                    <p class="text-gray-300 text-sm">
                                        You can also sell shares you own if you change your mind or want to lock in profits. 
                                        The price you get depends on the current market probability.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Section 4: Resolution -->
                <section class="rounded-lg p-8" style="background-color: #161b22; border: 1px solid #30363d;">
                    <div class="flex items-start gap-4 mb-6">
                        <div class="flex-shrink-0 w-12 h-12 rounded-lg flex items-center justify-center text-2xl" style="background-color: #9333ea; color: white;">
                            4
                        </div>
                        <div>
                            <h2 class="text-2xl font-bold text-white mb-3">Poll Resolution</h2>
                            <p class="text-gray-300 leading-relaxed mb-4">
                                When the poll's end time arrives, it needs to be resolved:
                            </p>
                            <ul class="space-y-3 text-gray-300">
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span>The poll creator or designated resolver determines which outcome occurred</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span>Shares of the winning outcome are worth $1.00 each</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span>Shares of losing outcomes become worthless</span>
                                </li>
                                <li class="flex items-start gap-3">
                                    <svg class="w-5 h-5 flex-shrink-0 mt-0.5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                                    </svg>
                                    <span>Traders can redeem their winning shares for the payout</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Section 5: Getting Started -->
                <section class="rounded-lg p-8" style="background-color: #161b22; border: 1px solid #30363d;">
                    <div class="flex items-start gap-4 mb-6">
                        <div class="flex-shrink-0 w-12 h-12 rounded-lg flex items-center justify-center text-2xl" style="background-color: #9333ea; color: white;">
                            5
                        </div>
                        <div>
                            <h2 class="text-2xl font-bold text-white mb-3">Getting Started</h2>
                            <p class="text-gray-300 leading-relaxed mb-6">
                                Ready to start predicting? Here's how to get started:
                            </p>
                            <div class="grid md:grid-cols-2 gap-4">
                                <div class="p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                    <h3 class="text-lg font-semibold text-white mb-2 flex items-center gap-2">
                                        <svg class="w-5 h-5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                                        </svg>
                                        Create Your First Poll
                                    </h3>
                                    <p class="text-gray-300 text-sm">
                                        Click "Create Market" to start a new poll about anything in your daily life. 
                                        Be creative and make it fun!
                                    </p>
                                </div>
                                <div class="p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                    <h3 class="text-lg font-semibold text-white mb-2 flex items-center gap-2">
                                        <svg class="w-5 h-5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                        </svg>
                                        Explore Existing Polls
                                    </h3>
                                    <p class="text-gray-300 text-sm">
                                        Browse through public polls and see what others are predicting. 
                                        Join the conversation and place your bets!
                                    </p>
                                </div>
                                <div class="p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                    <h3 class="text-lg font-semibold text-white mb-2 flex items-center gap-2">
                                        <svg class="w-5 h-5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                                        </svg>
                                        Track Your Portfolio
                                    </h3>
                                    <p class="text-gray-300 text-sm">
                                        Monitor your active positions and see how your predictions are performing. 
                                        Build your reputation as a great predictor!
                                    </p>
                                </div>
                                <div class="p-4 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                    <h3 class="text-lg font-semibold text-white mb-2 flex items-center gap-2">
                                        <svg class="w-5 h-5" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                        </svg>
                                        Engage with Community
                                    </h3>
                                    <p class="text-gray-300 text-sm">
                                        Comment on polls, share your reasoning, and discuss outcomes with other traders. 
                                        The community makes it more fun!
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Call to Action -->
                <div class="rounded-lg p-8 text-center" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);">
                    <h2 class="text-3xl font-bold text-white mb-4">Ready to Start Predicting?</h2>
                    <p class="text-white/90 mb-6 text-lg">Join PolliT and turn your everyday predictions into opportunities</p>
                    <button onclick="closeHowItWorks(); document.getElementById('createMarketBtn').click();" class="px-8 py-3 rounded-lg font-semibold text-white transition-opacity hover:opacity-90" style="background-color: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px);">
                        Create Your First Poll
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Help & Support Page with Chatbot -->
    <div id="helpSupportPage" class="hidden" style="background-color: #0d1117 !important; min-height: 100vh; width: 100%; position: fixed; top: 64px; left: 0; right: 0; bottom: 0; z-index: 10001; overflow-y: auto;">
        <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-8" style="position: relative; z-index: 10002;">
            <!-- Header -->
            <div class="mb-6">
                <button onclick="closeHelpSupport()" class="flex items-center gap-2 text-gray-400 hover:text-white mb-4 transition-colors cursor-pointer">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                    <span>Back</span>
                </button>
                <h1 class="text-4xl font-bold mb-2 pollit-brand">Help & Support</h1>
                <p class="text-xl text-gray-400">Get help with PolliT - Ask our chatbot anything!</p>
            </div>

            <!-- Main Content Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Left Column - FAQ/Resources -->
                <div class="lg:col-span-1 space-y-4">
                    <div class="rounded-lg p-6" style="background-color: #161b22; border: 1px solid #30363d;">
                        <h2 class="text-xl font-semibold text-white mb-4">Quick Links</h2>
                        <div class="space-y-3">
                            <a href="#" onclick="closeHelpSupport(); openHowItWorks(); return false;" class="block p-3 rounded-lg hover:bg-gray-800 transition-colors cursor-pointer" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <div class="flex items-center gap-3">
                                    <span class="text-2xl">üìö</span>
                                    <div>
                                        <h3 class="text-white font-medium">How It Works</h3>
                                        <p class="text-sm text-gray-400">Learn about PolliT</p>
                                    </div>
                                </div>
                            </a>
                            <a href="#" onclick="closeHelpSupport(); document.getElementById('createMarketBtn')?.click(); return false;" class="block p-3 rounded-lg hover:bg-gray-800 transition-colors cursor-pointer" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <div class="flex items-center gap-3">
                                    <span class="text-2xl">‚ûï</span>
                                    <div>
                                        <h3 class="text-white font-medium">Create Market</h3>
                                        <p class="text-sm text-gray-400">Start your first poll</p>
                                    </div>
                                </div>
                            </a>
                            <a href="#" onclick="closeHelpSupport(); openDashboard(); return false;" class="block p-3 rounded-lg hover:bg-gray-800 transition-colors cursor-pointer" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <div class="flex items-center gap-3">
                                    <span class="text-2xl">üìä</span>
                                    <div>
                                        <h3 class="text-white font-medium">Dashboard</h3>
                                        <p class="text-sm text-gray-400">View your portfolio</p>
                                    </div>
                                </div>
                            </a>
                        </div>
                    </div>

                    <div class="rounded-lg p-6" style="background-color: #161b22; border: 1px solid #30363d;">
                        <h2 class="text-xl font-semibold text-white mb-4">Common Questions</h2>
                        <div class="space-y-3">
                            <div class="p-3 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <h3 class="text-white font-medium mb-1">How do I create a poll?</h3>
                                <p class="text-sm text-gray-400">Click "Create Market" and fill in the details. You can set outcomes, end time, and visibility.</p>
                            </div>
                            <div class="p-3 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <h3 class="text-white font-medium mb-1">How do I trade?</h3>
                                <p class="text-sm text-gray-400">Click on any poll, select an outcome, and choose to buy or sell shares.</p>
                            </div>
                            <div class="p-3 rounded-lg" style="background-color: #0d1117; border: 1px solid #30363d;">
                                <h3 class="text-white font-medium mb-1">What happens when a poll ends?</h3>
                                <p class="text-sm text-gray-400">The creator proposes a winner. Participants can challenge if they disagree. After resolution, winning shares can be redeemed.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column - Chatbot -->
                <div class="lg:col-span-2">
                    <div class="rounded-lg" style="background-color: #161b22; border: 1px solid #30363d; height: calc(100vh - 200px); display: flex; flex-direction: column;">
                        <!-- Chatbot Header -->
                        <div class="p-4 border-b" style="border-color: #30363d;">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 rounded-full flex items-center justify-center text-xl" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);">
                                    ü§ñ
                                </div>
                                <div>
                                    <h2 class="text-lg font-semibold text-white">PolliT Assistant</h2>
                                    <p class="text-xs text-gray-400">Ask me anything about PolliT</p>
                                </div>
                                <div class="ml-auto">
                                    <span class="inline-flex items-center gap-1.5 px-2 py-1 rounded-full text-xs font-medium" style="background-color: #10b981; color: white;">
                                        <span class="w-2 h-2 rounded-full bg-white animate-pulse"></span>
                                        Online
                                    </span>
                                </div>
                            </div>
                        </div>

                        <!-- Chat Messages -->
                        <div id="chatbotMessages" class="flex-1 overflow-y-auto p-4 space-y-4" style="max-height: calc(100vh - 300px);">
                            <!-- Welcome Message -->
                            <div class="flex items-start gap-3">
                                <div class="w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);">
                                    ü§ñ
                                </div>
                                <div class="flex-1">
                                    <div class="rounded-lg p-4" style="background-color: #0d1117; border: 1px solid #30363d;">
                                        <p class="text-white text-sm">
                                            üëã Hi! I'm the PolliT Assistant. I can help you with:
                                        </p>
                                        <ul class="mt-2 space-y-1 text-sm text-gray-300 list-disc list-inside">
                                            <li>Creating and managing polls</li>
                                            <li>Trading and buying shares</li>
                                            <li>Understanding how prediction markets work</li>
                                            <li>Account and dashboard questions</li>
                                            <li>Technical support</li>
                                        </ul>
                                        <p class="mt-2 text-sm text-gray-300">What would you like to know?</p>
                                    </div>
                                    <p class="text-xs text-gray-500 mt-1">Just now</p>
                                </div>
                            </div>
                        </div>

                        <!-- Chat Input -->
                        <div class="p-4 border-t" style="border-color: #30363d;">
                            <div class="flex gap-2">
                                <input
                                    type="text"
                                    id="chatbotInput"
                                    placeholder="Type your message..."
                                    class="flex-1 px-4 py-2 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all"
                                    style="background-color: #0d1117; border: 1px solid #30363d;"
                                    onkeypress="if(event.key === 'Enter') { sendChatbotMessage(); }"
                                />
                                <button
                                    onclick="sendChatbotMessage()"
                                    class="px-6 py-2 rounded-lg font-medium text-white hover:opacity-90 transition-opacity flex items-center gap-2"
                                    style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);"
                                >
                                    <span>Send</span>
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                    </svg>
                                </button>
                            </div>
                            <p class="text-xs text-gray-500 mt-2 text-center">Press Enter to send ‚Ä¢ AI-powered responses</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Invite Link Modal -->
    <div id="inviteLinkModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" style="z-index: 1001;">
        <div class="rounded-lg max-w-md w-full" style="background-color: #161b22; border: 1px solid #30363d;">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-white">Private Market Created!</h2>
                    <button id="closeInviteModal" class="text-[#8b949e] hover:text-white text-2xl">‚úï</button>
                </div>
                <p class="text-sm text-gray-300 mb-4" id="inviteMarketTitle"></p>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-white mb-2">Invite Link</label>
                    <div class="flex gap-2">
                        <input type="text" id="inviteLinkInput" readonly class="flex-1 px-3 py-2 rounded-lg text-white text-sm" style="background-color: #0d1117; border: 1px solid #30363d;" />
                        <button id="copyInviteLink" class="px-4 py-2 rounded-lg text-white font-medium hover:opacity-90 transition-opacity" style="background-color: #9333ea;">
                            Copy
                        </button>
                    </div>
                </div>
                <p class="text-xs text-gray-400 mb-4">Share this link with people you want to invite to your private market.</p>
                <button id="closeInviteModalBtn" class="w-full px-4 py-2 text-white rounded-lg font-medium hover:opacity-90 transition-opacity" style="background-color: #9333ea;">
                    Done
                </button>
            </div>
        </div>
    </div>

    <!-- Custom Date/Time Picker Modal - DARK THEME VERSION -->
    <div id="dateTimePickerModal" class="fixed inset-0 items-center justify-center p-4" style="z-index: 10000; display: none !important; background-color: rgba(0, 0, 0, 0.85) !important; backdrop-filter: blur(8px) !important;">
        <div class="rounded-2xl max-w-2xl w-full relative overflow-hidden" style="background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #0d1117 100%) !important; border: 2px solid #9333ea !important; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.9), 0 0 0 2px rgba(147, 51, 234, 0.2), inset 0 0 50px rgba(147, 51, 234, 0.05) !important; max-height: 90vh; overflow-y: auto; animation: modalSlideIn 0.3s ease-out;">
            <div class="p-6" style="background: transparent !important;">
                <!-- Header -->
                <div class="flex items-center justify-between mb-6 pb-4 border-b" style="border-color: #30363d;">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 rounded-lg flex items-center justify-center" style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);">
                            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-white">üìÖ Select Date & Time (Dark Theme)</h3>
                            <p class="text-xs mt-0.5" style="color: #8b949e;">Choose when your poll will close</p>
                        </div>
                    </div>
                    <button onclick="if(typeof window.closeDateTimePicker === 'function') { window.closeDateTimePicker(); }" class="p-2 hover:bg-gray-800 rounded-lg transition-all duration-200" style="color: #8b949e;">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                <!-- Date Picker Section -->
                <div class="mb-6">
                    <!-- Month/Year Navigation -->
                    <div class="flex items-center justify-between mb-5 p-3 rounded-xl" style="background-color: #0d1117; border: 1px solid #30363d;">
                        <button onclick="if(typeof window.changeMonth === 'function') { window.changeMonth(-1); } else { console.error('changeMonth not available'); }" class="p-2 hover:bg-gray-800 rounded-lg transition-all duration-200 group" style="color: #8b949e;">
                            <svg class="w-5 h-5 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                            </svg>
                        </button>
                        <div class="flex items-center gap-3">
                            <select id="monthSelect" onchange="if(typeof window.updateCalendar === 'function') { window.updateCalendar(); }" class="px-4 py-2 rounded-lg text-white font-semibold transition-all hover:border-purple-500 cursor-pointer" style="background-color: #161b22; border: 1px solid #30363d; outline: none;">
                                <!-- Months will be populated -->
                            </select>
                            <select id="yearSelect" onchange="if(typeof window.updateCalendar === 'function') { window.updateCalendar(); }" class="px-4 py-2 rounded-lg text-white font-semibold transition-all hover:border-purple-500 cursor-pointer" style="background-color: #161b22; border: 1px solid #30363d; outline: none;">
                                <!-- Years will be populated -->
                            </select>
                        </div>
                        <button onclick="if(typeof window.changeMonth === 'function') { window.changeMonth(1); } else { console.error('changeMonth not available'); }" class="p-2 hover:bg-gray-800 rounded-lg transition-all duration-200 group" style="color: #8b949e;">
                            <svg class="w-5 h-5 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                            </svg>
                        </button>
                    </div>

                    <!-- Calendar Grid -->
                    <div class="mb-4">
                        <div class="grid grid-cols-7 gap-2 mb-3 px-1">
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">S</div>
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">M</div>
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">T</div>
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">W</div>
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">T</div>
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">F</div>
                            <div class="text-center text-xs font-semibold py-2" style="color: #6b7280;">S</div>
                        </div>
                        <div id="calendarGrid" class="grid grid-cols-7 gap-2 px-1">
                            <!-- Calendar days will be populated here -->
                        </div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="flex items-center justify-between pt-4 border-t" style="border-color: #30363d;">
                        <button onclick="if(typeof window.clearDateTime === 'function') { window.clearDateTime(); }" class="px-4 py-2 text-sm rounded-lg text-gray-400 hover:text-white hover:bg-gray-800 transition-all duration-200 font-medium">
                            Clear
                        </button>
                        <button onclick="if(typeof window.setToday === 'function') { window.setToday(); }" class="px-4 py-2 text-sm rounded-lg transition-all duration-200 font-medium" style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%); color: white; box-shadow: 0 4px 6px -1px rgba(147, 51, 234, 0.3);">
                            Today
                        </button>
                    </div>
                </div>

                <!-- Time Picker Section -->
                <div class="pt-6 border-t" style="border-color: #30363d;">
                    <label class="block text-sm font-semibold text-white mb-4 flex items-center gap-2">
                        <svg class="w-4 h-4" style="color: #9333ea;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        Time
                    </label>
                    <div class="flex items-center gap-6 justify-center">
                        <!-- Hours -->
                        <div class="flex flex-col items-center">
                            <label class="text-xs mb-3 font-medium" style="color: #8b949e;">Hour</label>
                            <div class="relative">
                                <input 
                                    type="number" 
                                    id="timeHour" 
                                    min="1" 
                                    max="12" 
                                    value="12"
                                    class="w-20 px-4 py-3 text-center rounded-xl text-white text-xl font-bold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                                    style="background-color: #0d1117; border: 2px solid #30363d;"
                                    onchange="if(typeof window.updateTimeDisplay === 'function') { window.updateTimeDisplay(); }"
                                    onfocus="this.style.borderColor='#9333ea';"
                                    onblur="this.style.borderColor='#30363d';"
                                />
                            </div>
                        </div>
                        <span class="text-3xl font-bold mt-8" style="color: #9333ea;">:</span>
                        <!-- Minutes -->
                        <div class="flex flex-col items-center">
                            <label class="text-xs mb-3 font-medium" style="color: #8b949e;">Minute</label>
                            <div class="relative">
                                <input 
                                    type="number" 
                                    id="timeMinute" 
                                    min="0" 
                                    max="59" 
                                    value="0"
                                    step="1"
                                    class="w-20 px-4 py-3 text-center rounded-xl text-white text-xl font-bold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                                    style="background-color: #0d1117; border: 2px solid #30363d;"
                                    onchange="if(typeof window.updateTimeDisplay === 'function') { window.updateTimeDisplay(); }"
                                    onfocus="this.style.borderColor='#9333ea';"
                                    onblur="this.style.borderColor='#30363d';"
                                />
                            </div>
                        </div>
                        <!-- AM/PM -->
                        <div class="flex flex-col gap-2 mt-8">
                            <button 
                                id="timeAM" 
                                onclick="if(typeof window.setAMPM === 'function') { window.setAMPM('AM'); }"
                                class="px-5 py-2.5 text-sm rounded-xl font-semibold transition-all duration-200 shadow-lg"
                                style="background-color: #9333ea; color: white; box-shadow: 0 4px 6px -1px rgba(147, 51, 234, 0.3);"
                            >
                                AM
                            </button>
                            <button 
                                id="timePM" 
                                onclick="if(typeof window.setAMPM === 'function') { window.setAMPM('PM'); }"
                                class="px-5 py-2.5 text-sm rounded-xl font-semibold transition-all duration-200"
                                style="background-color: #0d1117; border: 2px solid #30363d; color: #8b949e;"
                            >
                                PM
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex gap-3 mt-6 pt-6 border-t" style="border-color: #30363d;">
                    <button 
                        onclick="if(typeof window.closeDateTimePicker === 'function') { window.closeDateTimePicker(); }" 
                        class="flex-1 px-4 py-3.5 rounded-xl font-semibold transition-all duration-200 hover:bg-gray-800"
                        style="background-color: #0d1117; border: 2px solid #30363d; color: white;"
                    >
                        Cancel
                    </button>
                    <button 
                        onclick="if(typeof window.confirmDateTime === 'function') { window.confirmDateTime(); }" 
                        class="flex-1 px-4 py-3.5 rounded-xl font-semibold text-white transition-all duration-200 hover:scale-105 shadow-lg"
                        style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%); box-shadow: 0 10px 15px -3px rgba(147, 51, 234, 0.4);"
                    >
                        Confirm Selection
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Menu Sidebar functionality
        const menuBtn = document.getElementById('menuBtn');
        const menuSidebar = document.getElementById('menuSidebar');
        const closeMenuBtn = document.getElementById('closeMenuBtn');
        const menuOverlay = document.getElementById('menuOverlay');
        
        function openMenu() {
            // Ensure menu appears above "How It Works" page
            const howItWorksPage = document.getElementById('howItWorksPage');
            if (howItWorksPage && howItWorksPage.style.display !== 'none') {
                // Temporarily lower the z-index of "How It Works" page
                howItWorksPage.style.zIndex = '40';
            }
            
            // Set high z-index for menu to appear above everything
            if (menuSidebar) {
                menuSidebar.style.zIndex = '10000';
            }
            if (menuOverlay) {
                menuOverlay.style.zIndex = '9999';
            }
            
            menuSidebar.classList.remove('translate-x-full');
            menuOverlay.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }
        
        function closeMenu() {
            menuSidebar.classList.add('translate-x-full');
            menuOverlay.classList.add('hidden');
            document.body.style.overflow = 'auto';
            
            // Restore "How It Works" page z-index if it was visible
            const howItWorksPage = document.getElementById('howItWorksPage');
            if (howItWorksPage && howItWorksPage.style.display !== 'none') {
                howItWorksPage.style.zIndex = '150';
            }
        }
        
        menuBtn.addEventListener('click', openMenu);
        if (closeMenuBtn) {
            closeMenuBtn.addEventListener('click', closeMenu);
        }
        menuOverlay.addEventListener('click', closeMenu);
        
        // Make closeMenu globally accessible
        window.closeMenu = closeMenu;
        
        // Navigation functions for sidebar menu
        function navigateToHome() {
            closeMenu();
            goToHomepage();
        }
        
        function navigateToMyMarkets() {
            closeMenu();
            openDashboard();
            // Scroll to My Markets section after a short delay
            setTimeout(() => {
                const myMarketsSection = document.getElementById('dashboardMyMarkets');
                if (myMarketsSection) {
                    myMarketsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 300);
        }
        
        function navigateToPortfolio() {
            closeMenu();
            openDashboard();
            // Scroll to Portfolio section after a short delay
            setTimeout(() => {
                const portfolioSection = document.getElementById('dashboardPortfolio');
                if (portfolioSection) {
                    portfolioSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } else {
                    // If portfolio section doesn't exist, scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }, 300);
        }
        
        function navigateToProfile() {
            closeMenu();
            openDashboard();
            // For now, just show dashboard. Profile section can be added later
            setTimeout(() => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, 300);
        }
        
        function navigateToSettings() {
            closeMenu();
            openSettings();
        }
        
        function navigateToHelp() {
            console.log('navigateToHelp called');
            closeMenu();
            // Small delay to ensure menu closes first
            setTimeout(() => {
                openHelpSupport();
            }, 100);
        }
        
        function openHelpSupport() {
            console.log('openHelpSupport called');
            const helpSupportPage = document.getElementById('helpSupportPage');
            const main = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const nav = document.querySelector('nav');
            
            // Hide other pages
            const howItWorksPage = document.getElementById('howItWorksPage');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const userDashboard = document.getElementById('userDashboard');
            const settingsPage = document.getElementById('settingsPage');
            
            if (howItWorksPage) {
                howItWorksPage.style.display = 'none';
                howItWorksPage.style.visibility = 'hidden';
                howItWorksPage.style.opacity = '0';
                howItWorksPage.style.zIndex = '-1';
            }
            if (pollDetailPage) {
                pollDetailPage.style.display = 'none';
                pollDetailPage.style.visibility = 'hidden';
            }
            if (userDashboard) {
                userDashboard.style.display = 'none';
                userDashboard.style.visibility = 'hidden';
            }
            if (settingsPage) {
                settingsPage.style.display = 'none';
                settingsPage.style.visibility = 'hidden';
            }
            
            // Hide main content with !important
            if (main) {
                main.style.setProperty('display', 'none', 'important');
                main.style.setProperty('visibility', 'hidden', 'important');
                main.style.setProperty('opacity', '0', 'important');
                main.style.setProperty('z-index', '-1', 'important');
            }
            if (marketsContainer) {
                marketsContainer.style.setProperty('display', 'none', 'important');
                marketsContainer.style.setProperty('visibility', 'hidden', 'important');
                marketsContainer.style.setProperty('opacity', '0', 'important');
                marketsContainer.style.setProperty('z-index', '-1', 'important');
            }
            // Keep nav visible (don't hide it)
            // if (nav) {
            //     nav.style.display = 'none';
            //     nav.style.visibility = 'hidden';
            // }
            
            // Ensure menu is fully closed
            const menuSidebar = document.getElementById('menuSidebar');
            const menuOverlay = document.getElementById('menuOverlay');
            if (menuSidebar) {
                menuSidebar.classList.add('translate-x-full');
                menuSidebar.style.zIndex = '50';
            }
            if (menuOverlay) {
                menuOverlay.classList.add('hidden');
                menuOverlay.style.display = 'none';
                menuOverlay.style.zIndex = '40';
            }
            document.body.style.overflow = 'auto';
            
            // Show Help & Support page with explicit styling
            if (helpSupportPage) {
                // Remove hidden class first
                helpSupportPage.classList.remove('hidden');
                
                // Force remove any display:none from inline style
                const currentStyle = helpSupportPage.getAttribute('style') || '';
                const newStyle = currentStyle.replace(/display\s*:\s*none[^;]*;?/gi, '');
                helpSupportPage.setAttribute('style', newStyle);
                
                // Apply all styles using setProperty with !important - this will override everything
                helpSupportPage.style.setProperty('display', 'block', 'important');
                helpSupportPage.style.setProperty('visibility', 'visible', 'important');
                helpSupportPage.style.setProperty('opacity', '1', 'important');
                helpSupportPage.style.setProperty('position', 'fixed', 'important');
                helpSupportPage.style.setProperty('top', '64px', 'important');
                helpSupportPage.style.setProperty('left', '0', 'important');
                helpSupportPage.style.setProperty('right', '0', 'important');
                helpSupportPage.style.setProperty('bottom', '0', 'important');
                helpSupportPage.style.setProperty('z-index', '10001', 'important');
                helpSupportPage.style.setProperty('background-color', '#0d1117', 'important');
                helpSupportPage.style.setProperty('overflow-y', 'auto', 'important');
                helpSupportPage.style.setProperty('width', '100%', 'important');
                helpSupportPage.style.setProperty('min-height', 'calc(100vh - 64px)', 'important');
                helpSupportPage.style.setProperty('height', 'calc(100vh - 64px)', 'important');
                
                // Also ensure all child elements are visible
                const children = helpSupportPage.querySelectorAll('*');
                children.forEach(child => {
                    const childDisplay = window.getComputedStyle(child).display;
                    if (childDisplay === 'none') {
                        child.style.setProperty('display', '', 'important');
                    }
                });
                
                console.log('Help & Support page should be visible now');
                console.log('Page element:', helpSupportPage);
                console.log('Page innerHTML length:', helpSupportPage.innerHTML ? helpSupportPage.innerHTML.length : 0);
                console.log('Page display:', window.getComputedStyle(helpSupportPage).display);
                console.log('Page z-index:', window.getComputedStyle(helpSupportPage).zIndex);
                console.log('Page visibility:', window.getComputedStyle(helpSupportPage).visibility);
                
                // Set history state
                history.pushState({ page: 'help-support' }, '', window.location.href);
                
                // Force a reflow to ensure rendering
                helpSupportPage.offsetHeight;
                
                // Double-check display is set and verify content is visible
                setTimeout(() => {
                    const computedDisplay = window.getComputedStyle(helpSupportPage).display;
                    const computedVisibility = window.getComputedStyle(helpSupportPage).visibility;
                    const computedOpacity = window.getComputedStyle(helpSupportPage).opacity;
                    const computedZIndex = window.getComputedStyle(helpSupportPage).zIndex;
                    
                    console.log('Verification after 100ms:');
                    console.log('- Display:', computedDisplay);
                    console.log('- Visibility:', computedVisibility);
                    console.log('- Opacity:', computedOpacity);
                    console.log('- Z-index:', computedZIndex);
                    
                    const rect = helpSupportPage.getBoundingClientRect();
                    console.log('- Element rect:', rect);
                    console.log('- Element dimensions:', rect.width, 'x', rect.height);
                    
                    if (computedDisplay === 'none') {
                        console.error('Display is still none! Forcing display block again...');
                        helpSupportPage.style.setProperty('display', 'block', 'important');
                    }
                    
                    if (rect.width === 0 || rect.height === 0) {
                        console.error('Element has zero dimensions!', rect);
                        // Try setting explicit dimensions
                        helpSupportPage.style.setProperty('width', '100vw', 'important');
                        helpSupportPage.style.setProperty('height', 'calc(100vh - 64px)', 'important');
                    }
                    
                    // Check for any elements that might be covering it
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    const elementsAtPoint = document.elementsFromPoint(centerX, centerY);
                    console.log('Elements at center point:', elementsAtPoint.slice(0, 10).map(el => ({
                        tag: el.tagName,
                        id: el.id,
                        class: el.className,
                        zIndex: window.getComputedStyle(el).zIndex,
                        display: window.getComputedStyle(el).display,
                        position: window.getComputedStyle(el).position
                    })));
                    
                    // Check if helpSupportPage is in the list
                    const isVisible = elementsAtPoint.includes(helpSupportPage) || elementsAtPoint.some(el => helpSupportPage.contains(el));
                    console.log('Help & Support page is visible at center:', isVisible);
                    
                    if (!isVisible) {
                        console.warn('Help & Support page is NOT visible at center point!');
                        // Try to bring it to front
                        helpSupportPage.style.setProperty('z-index', '99999', 'important');
                    }
                }, 100);
            } else {
                console.error('helpSupportPage element not found!');
                alert('Help & Support page element not found. Please refresh the page.');
            }
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function closeHelpSupport() {
            console.log('closeHelpSupport called');
            const helpSupportPage = document.getElementById('helpSupportPage');
            const main = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const nav = document.querySelector('nav');
            
            // Hide Help & Support page
            if (helpSupportPage) {
                helpSupportPage.style.display = 'none';
                helpSupportPage.style.visibility = 'hidden';
            }
            
            // Show main content
            if (main) {
                main.style.display = 'block';
                main.style.visibility = 'visible';
            }
            if (marketsContainer) {
                marketsContainer.style.display = 'grid';
                marketsContainer.style.visibility = 'visible';
            }
            if (nav) {
                nav.style.display = 'block';
                nav.style.visibility = 'visible';
            }
        }
        
        // Chatbot functionality
        function sendChatbotMessage() {
            const input = document.getElementById('chatbotInput');
            const messagesContainer = document.getElementById('chatbotMessages');
            
            if (!input || !input.value.trim() || !messagesContainer) return;
            
            const userMessage = input.value.trim();
            input.value = '';
            
            // Add user message
            const userMsgDiv = document.createElement('div');
            userMsgDiv.className = 'flex items-start gap-3 justify-end';
            userMsgDiv.innerHTML = `
                <div class="flex-1 flex justify-end">
                    <div class="rounded-lg p-4 max-w-[80%]" style="background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);">
                        <p class="text-white text-sm">${escapeHtml(userMessage)}</p>
                    </div>
                </div>
                <div class="w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0" style="background-color: #30363d;">
                    <span class="text-white text-xs">You</span>
                </div>
            `;
            messagesContainer.appendChild(userMsgDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Show typing indicator
            const typingDiv = document.createElement('div');
            typingDiv.id = 'typingIndicator';
            typingDiv.className = 'flex items-start gap-3';
            typingDiv.innerHTML = `
                <div class="w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);">
                    ü§ñ
                </div>
                <div class="flex-1">
                    <div class="rounded-lg p-4" style="background-color: #0d1117; border: 1px solid #30363d;">
                        <div class="flex gap-1">
                            <span class="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style="animation-delay: 0s;"></span>
                            <span class="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style="animation-delay: 0.2s;"></span>
                            <span class="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style="animation-delay: 0.4s;"></span>
                        </div>
                    </div>
                </div>
            `;
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Generate bot response (simulated AI)
            setTimeout(() => {
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator) typingIndicator.remove();
                
                const botResponse = generateChatbotResponse(userMessage);
                const botMsgDiv = document.createElement('div');
                botMsgDiv.className = 'flex items-start gap-3';
                botMsgDiv.innerHTML = `
                    <div class="w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);">
                        ü§ñ
                    </div>
                    <div class="flex-1">
                        <div class="rounded-lg p-4" style="background-color: #0d1117; border: 1px solid #30363d;">
                            <p class="text-white text-sm">${botResponse}</p>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Just now</p>
                    </div>
                `;
                messagesContainer.appendChild(botMsgDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 1000 + Math.random() * 1000); // Simulate thinking time
        }
        
        function generateChatbotResponse(userMessage) {
            const message = userMessage.toLowerCase();
            
            // Keyword-based responses
            if (message.includes('create') || message.includes('poll') || message.includes('market')) {
                return `To create a poll, click the "Create Market" button in the header. You'll need to:
1. Enter a title and description
2. Add at least 2 outcomes (e.g., "Yes" and "No")
3. Set an end time for when the poll closes
4. Choose visibility (all polls are public by default)

Once created, others can start trading shares on your poll!`;
            }
            
            if (message.includes('trade') || message.includes('buy') || message.includes('sell') || message.includes('share')) {
                return `Trading is simple! Here's how:
1. Click on any poll to view details
2. Select an outcome you want to bet on
3. Click "Buy" or "Sell" 
4. Enter the amount you want to trade
5. Confirm your trade

You can sell your shares anytime before the poll ends. The price changes based on how many people are betting on each outcome.`;
            }
            
            if (message.includes('dashboard') || message.includes('portfolio') || message.includes('position')) {
                return `Your dashboard shows:
‚Ä¢ Total Invested: All money you've put into polls
‚Ä¢ Active Positions: Current bets you have open
‚Ä¢ Markets Created: Polls you've created
‚Ä¢ Recent Activity: Your trading history

Click "Account" in the sidebar menu to view your dashboard!`;
            }
            
            if (message.includes('end') || message.includes('resolve') || message.includes('winner') || message.includes('close')) {
                return `When a poll ends:
1. The creator proposes which outcome won
2. There's a 7-day challenge period where participants can dispute
3. After the challenge period, the resolution is finalized
4. Winners can redeem their shares 1:1 (get back their investment)
5. Losers get 0 back

This ensures fair and transparent outcomes!`;
            }
            
            if (message.includes('help') || message.includes('support') || message.includes('problem')) {
                return `I'm here to help! You can ask me about:
‚Ä¢ Creating polls
‚Ä¢ Trading shares
‚Ä¢ Understanding your dashboard
‚Ä¢ How polls resolve
‚Ä¢ Account settings
‚Ä¢ Technical issues

Or check out the "How It Works" page for a detailed guide!`;
            }
            
            if (message.includes('hello') || message.includes('hi') || message.includes('hey')) {
                return `Hello! üëã Welcome to PolliT! I'm here to help you understand how prediction markets work and answer any questions you have. What would you like to know?`;
            }
            
            if (message.includes('price') || message.includes('cost') || message.includes('fee')) {
                return `Trading on PolliT:
‚Ä¢ There's a 0.3% trading fee on all transactions
‚Ä¢ 0.1% goes to the poll creator
‚Ä¢ 0.2% goes to the protocol
‚Ä¢ Gas fees apply for onchain transactions (when fully implemented)

Prices change dynamically based on supply and demand - more people betting on an outcome increases its price!`;
            }
            
            // Default response
            return `Thanks for your question! I can help you with:
‚Ä¢ Creating and managing polls
‚Ä¢ Trading shares
‚Ä¢ Understanding your dashboard
‚Ä¢ How polls resolve
‚Ä¢ Account questions

Try asking about something specific, or check out the "How It Works" page for more details!`;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Make functions globally accessible
        window.openHelpSupport = openHelpSupport;
        window.closeHelpSupport = closeHelpSupport;
        window.sendChatbotMessage = sendChatbotMessage;
        
        function navigateToLogout() {
            closeMenu();
            handleLogout();
        }
        
        function navigateToDashboard() {
            console.log('navigateToDashboard called');
            try {
                // Close menu if open
                if (typeof closeMenu === 'function') {
            closeMenu();
                } else if (typeof window.closeMenu === 'function') {
                    window.closeMenu();
                }
                
                // Small delay to ensure menu closes
                setTimeout(() => {
                    // Open dashboard
                    if (typeof openDashboard === 'function') {
            openDashboard();
                    } else if (typeof window.openDashboard === 'function') {
                        window.openDashboard();
                    } else {
                        console.error('openDashboard function not found');
                        alert('Dashboard function not available. Please refresh the page.');
                    }
                }, 150);
            } catch (error) {
                console.error('Error navigating to dashboard:', error);
                alert('Error opening dashboard: ' + error.message);
            }
        }
        
        // Handle Account button click
        function handleAccountClick(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('handleAccountClick called');
            
            // Close menu first
            try {
                if (typeof closeMenu === 'function') {
                    closeMenu();
                } else if (typeof window.closeMenu === 'function') {
                    window.closeMenu();
                }
            } catch (e) {
                console.warn('Error closing menu:', e);
            }
            
            // Open dashboard immediately without delay to prevent homepage redirect
            try {
                // Clear URL params to prevent redirect
                if (window.history && window.history.replaceState) {
                    window.history.replaceState({}, '', window.location.pathname);
                }
                
                if (typeof openDashboard === 'function') {
                    console.log('Calling openDashboard');
                    openDashboard();
                } else if (typeof window.openDashboard === 'function') {
                    console.log('Calling window.openDashboard');
                    window.openDashboard();
                } else {
                    console.error('openDashboard function not found');
                    alert('Dashboard not available. Please refresh the page.');
                }
            } catch (e) {
                console.error('Error opening dashboard:', e);
                alert('Error: ' + e.message);
            }
        }
        
        window.handleAccountClick = handleAccountClick;
        
        function openSettings() {
            const settingsPage = document.getElementById('settingsPage');
            const mainContent = document.querySelector('main');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const userDashboard = document.getElementById('userDashboard');
            
            if (settingsPage) {
                // Hide other pages
                if (mainContent) mainContent.style.display = 'none';
                if (pollDetailPage) pollDetailPage.style.display = 'none';
                if (userDashboard) userDashboard.style.display = 'none';
                
                // Show settings page
                settingsPage.style.display = 'block';
                
                // Load settings data
                loadSettings();
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        function closeSettings() {
            const settingsPage = document.getElementById('settingsPage');
            const mainContent = document.querySelector('main');
            
            if (settingsPage) {
                settingsPage.style.display = 'none';
            }
            if (mainContent) {
                mainContent.style.display = 'block';
            }
        }
        
        // Load settings from backend
        async function loadSettings() {
            const loginData = localStorage.getItem('userLogin');
            if (!loginData) {
                console.warn('No user logged in');
                return;
            }
            
            try {
                const data = JSON.parse(loginData);
                const userAddress = data.userAddress || data.identifier;
                
                const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                const response = await fetch(`${API_URL}/api/users/${encodeURIComponent(userAddress)}/settings`);
                
                if (response.ok) {
                    const settings = await response.json();
                    
                    // Populate form fields
                    if (settings.username) document.getElementById('settingsUsername').value = settings.username;
                    if (settings.email) document.getElementById('settingsEmail').value = settings.email;
                    if (settings.bio) document.getElementById('settingsBio').value = settings.bio;
                    if (settings.currency) document.getElementById('settingsCurrency').value = settings.currency;
                    if (settings.paymentMethod) document.getElementById('settingsPaymentMethod').value = settings.paymentMethod;
                    if (settings.walletAddress) {
                        document.getElementById('settingsWalletAddress').value = settings.walletAddress;
                        if (settings.paymentMethod === 'wallet') {
                            document.getElementById('settingsWalletAddressContainer').classList.remove('hidden');
                        }
                    }
                    if (settings.emailNotifications !== undefined) {
                        document.getElementById('settingsEmailNotifications').checked = settings.emailNotifications;
                    }
                    if (settings.pushNotifications !== undefined) {
                        document.getElementById('settingsPushNotifications').checked = settings.pushNotifications;
                    }
                } else {
                    // If no settings found, load defaults from localStorage
                    loadDefaultSettings(data);
                }
            } catch (error) {
                console.error('Error loading settings:', error);
                // Load defaults from localStorage
                const data = JSON.parse(loginData);
                loadDefaultSettings(data);
            }
        }
        
        // Load default settings from localStorage
        function loadDefaultSettings(loginData) {
            if (loginData.email) document.getElementById('settingsEmail').value = loginData.email;
            if (loginData.username) document.getElementById('settingsUsername').value = loginData.username;
            if (loginData.userAddress) {
                document.getElementById('settingsWalletAddress').value = loginData.userAddress;
                if (loginData.provider === 'wallet') {
                    document.getElementById('settingsWalletAddressContainer').classList.remove('hidden');
                    document.getElementById('settingsPaymentMethod').value = 'wallet';
                }
            }
        }
        
        // Save settings
        async function saveSettings(settingsData) {
            const loginData = localStorage.getItem('userLogin');
            if (!loginData) {
                alert('Please log in to save settings');
                return false;
            }
            
            try {
                const data = JSON.parse(loginData);
                const userAddress = data.userAddress || data.identifier;
                
                if (!userAddress) {
                    alert('User address not found');
                    return false;
                }
                
                const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                let useBackend = false;
                
                // Check if backend is available
                try {
                    const pingResponse = await fetch(`${API_URL}/api/health`, { 
                        method: 'GET',
                        signal: AbortSignal.timeout(2000) // 2 second timeout
                    });
                    useBackend = pingResponse.ok;
                } catch (e) {
                    console.log('Backend not available, saving to localStorage');
                    useBackend = false;
                }
                
                if (useBackend) {
                    // Try to save to backend
                    try {
                        const response = await fetch(`${API_URL}/api/users/${encodeURIComponent(userAddress)}/settings`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(settingsData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                            console.log('Settings saved to backend:', result);
                            // Also save to localStorage as backup
                            saveSettingsToLocalStorage(settingsData, data);
                    alert('Settings saved successfully!');
                    return true;
                } else {
                    const error = await response.json();
                            throw new Error(error.message || `HTTP ${response.status}`);
                        }
                    } catch (error) {
                        console.warn('Backend save failed, falling back to localStorage:', error);
                        // Fall through to localStorage save
                    }
                }
                
                // Save to localStorage (fallback or primary if backend unavailable)
                saveSettingsToLocalStorage(settingsData, data);
                alert('Settings saved successfully! (Saved locally)');
                return true;
                
            } catch (error) {
                console.error('Error saving settings:', error);
                // Try localStorage as last resort
                try {
                    const data = JSON.parse(localStorage.getItem('userLogin'));
                    saveSettingsToLocalStorage(settingsData, data);
                    alert('Settings saved successfully! (Saved locally)');
                    return true;
                } catch (e) {
                alert('Error saving settings. Please check if the backend server is running.');
                return false;
                }
            }
        }
        
        // Helper function to save settings to localStorage
        function saveSettingsToLocalStorage(settingsData, loginData) {
            // Update login data with new username if provided
            if (settingsData.username) {
                loginData.username = settingsData.username;
                localStorage.setItem('userName', settingsData.username);
                localStorage.setItem('userLogin', JSON.stringify(loginData));
                console.log('Username saved to localStorage:', settingsData.username);
                
                // Update dashboard username if dashboard is open
                const dashboardUserName = document.getElementById('dashboardUserName');
                if (dashboardUserName) {
                    dashboardUserName.textContent = settingsData.username;
                }
                
                // Update sidebar username if visible
                const sidebarUserName = document.getElementById('sidebarUserName');
                if (sidebarUserName) {
                    sidebarUserName.textContent = settingsData.username;
                }
            }
            
            // Save other settings to localStorage
            const userSettings = JSON.parse(localStorage.getItem('userSettings') || '{}');
            const userAddress = loginData.userAddress || loginData.identifier || loginData.address;
            
            if (userAddress) {
                userSettings[userAddress.toLowerCase()] = {
                    ...userSettings[userAddress.toLowerCase()],
                    ...settingsData,
                    updatedAt: new Date().toISOString()
                };
                localStorage.setItem('userSettings', JSON.stringify(userSettings));
                console.log('Settings saved to localStorage:', userSettings[userAddress.toLowerCase()]);
            }
        }
        
        // Make navigation functions globally accessible
        window.navigateToHome = navigateToHome;
        window.navigateToMyMarkets = navigateToMyMarkets;
        window.navigateToPortfolio = navigateToPortfolio;
        window.navigateToProfile = navigateToProfile;
        window.navigateToSettings = navigateToSettings;
        window.openSettings = openSettings;
        window.closeSettings = closeSettings;
        window.navigateToHelp = navigateToHelp;
        window.navigateToLogout = navigateToLogout;
        window.navigateToDashboard = navigateToDashboard;
        
        // Login Modal functionality
        const loginModal = document.getElementById('loginModal');
        const menuLoginBtn = document.getElementById('menuLoginBtn');
        const closeLoginModal = document.getElementById('closeLoginModal');
        const googleLoginBtn = document.getElementById('googleLoginBtn');
        const appleLoginBtn = document.getElementById('appleLoginBtn');
        const walletConnectBtn = document.getElementById('walletConnectBtn');
        const loginStatus = document.getElementById('loginStatus');
        
        // Open login modal or handle logout
        if (menuLoginBtn) {
            menuLoginBtn.addEventListener('click', () => {
                const isLoggedIn = menuLoginBtn.getAttribute('data-logged-in') === 'true';
                if (isLoggedIn) {
                    // If logged in, log out
                    closeMenu();
                    handleLogout();
                } else {
                    // Login - open modal
                    if (loginModal) {
                        loginModal.classList.remove('hidden');
                        loginModal.classList.add('flex');
                    }
                    closeMenu();
                }
            });
        }
        
        // Close login modal
        if (closeLoginModal) {
            closeLoginModal.addEventListener('click', () => {
                if (loginModal) {
                    loginModal.classList.add('hidden');
                    loginModal.classList.remove('flex');
                }
            });
        }
        
        // Close modal when clicking outside
        if (loginModal) {
            loginModal.addEventListener('click', (e) => {
                if (e.target === loginModal) {
                    loginModal.classList.add('hidden');
                    loginModal.classList.remove('flex');
                }
            });
        }
        
        // Google Login
        if (googleLoginBtn) {
            googleLoginBtn.addEventListener('click', async () => {
                try {
                    showLoginStatus('Connecting to Google...', 'text-blue-400');
                    
                    // In a real implementation, this would redirect to Google OAuth
                    // For demo purposes, we'll simulate the login
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Simulate successful login
                    const userEmail = 'user@gmail.com'; // In real app, get from OAuth response
                    handleLoginSuccess('google', userEmail);
                } catch (error) {
                    showLoginStatus('Google login failed. Please try again.', 'text-red-400');
                    console.error('Google login error:', error);
                }
            });
        }
        
        // Apple Login
        if (appleLoginBtn) {
            appleLoginBtn.addEventListener('click', async () => {
                try {
                    showLoginStatus('Connecting to Apple...', 'text-blue-400');
                    
                    // In a real implementation, this would use Apple Sign In
                    // For demo purposes, we'll simulate the login
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Simulate successful login
                    const userEmail = 'user@icloud.com'; // In real app, get from Apple Sign In
                    handleLoginSuccess('apple', userEmail);
                } catch (error) {
                    showLoginStatus('Apple login failed. Please try again.', 'text-red-400');
                    console.error('Apple login error:', error);
                }
            });
        }
        
        // Base chain configuration
        const BASE_MAINNET = {
            chainId: '0x2105', // 8453 in hex
            chainName: 'Base',
            nativeCurrency: {
                name: 'Ether',
                symbol: 'ETH',
                decimals: 18
            },
            rpcUrls: ['https://mainnet.base.org'],
            blockExplorerUrls: ['https://basescan.org']
        };
        
        const BASE_SEPOLIA = {
            chainId: '0x14a34', // 84532 in hex
            chainName: 'Base Sepolia',
            nativeCurrency: {
                name: 'Ether',
                symbol: 'ETH',
                decimals: 18
            },
            rpcUrls: ['https://sepolia.base.org'],
            blockExplorerUrls: ['https://sepolia.basescan.org']
        };
        
        // Base Sepolia chain ID as number for comparisons
        const BASE_SEPOLIA_CHAIN_ID = 84532;
        const BASE_MAINNET_CHAIN_ID = 8453;
        
        // Switch to Base network
        async function switchToBaseNetwork(useMainnet = false) {
            const baseConfig = useMainnet ? BASE_MAINNET : BASE_SEPOLIA;
            
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: baseConfig.chainId }]
                });
            } catch (switchError) {
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [baseConfig]
                        });
                    } catch (addError) {
                        throw new Error('Failed to add Base network to wallet');
                    }
                } else {
                    throw switchError;
                }
            }
        }
        
        // Wallet Connect Modal functionality
        const walletConnectModal = document.getElementById('walletConnectModal');
        const closeWalletModalBtn = document.getElementById('closeWalletModal');
        const metamaskBtn = document.getElementById('metamaskBtn');
        const coinbaseExtensionBtn = document.getElementById('coinbaseExtensionBtn');
        const generateQRBtn = document.getElementById('generateQRBtn');
        
        // Function to close wallet modal
        function closeWalletModal() {
            if (walletConnectModal) {
                walletConnectModal.classList.add('hidden');
                walletConnectModal.classList.remove('flex');
            }
        }
        
        // Close button event listener
        if (closeWalletModalBtn) {
            closeWalletModalBtn.addEventListener('click', closeWalletModal);
        }
        const qrCodeCanvas = document.getElementById('qrCodeCanvas');
        const walletConnectStatus = document.getElementById('walletConnectStatus');
        const qrCodeContainer = document.getElementById('qrCodeContainer');
        const qrCodeLoading = document.getElementById('qrCodeLoading');
        const qrCodeDisplay = document.getElementById('qrCodeDisplay');
        const qrCodeError = document.getElementById('qrCodeError');
        let coinbaseWalletSDK = null;
        let coinbaseWalletProvider = null;
        let walletConnectProvider = null;
        let walletConnectURI = null;
        
        // Initialize WalletConnect (used by RainbowKit)
        async function initializeWalletConnect() {
            try {
                console.log('=== Initializing WalletConnect ===');
                
                // Wait for WalletConnect SDK to load
                let attempts = 0;
                const maxAttempts = 50;
                
                // Check multiple possible SDK exports
                let WCProvider = null;
                
                // Wait for SDK to be ready - check if it loaded successfully
                if (window.walletConnectSDKLoadError) {
                    throw new Error('WalletConnect SDK failed to load from CDN. Please check your internet connection and try again.');
                }
                
                // Wait a bit for SDK to fully initialize after load
                let waitAttempts = 0;
                while (!window.walletConnectSDKLoaded && waitAttempts < 20) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    waitAttempts++;
                }
                
                // Additional wait for SDK to expose globals
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Try different ways the SDK might be exposed
                console.log('=== Checking for EthereumProvider ===');
                
                // First, check if the setup script already found it
                if (typeof window.EthereumProvider !== 'undefined' && typeof window.EthereumProvider.init === 'function') {
                    WCProvider = window.EthereumProvider;
                    console.log('‚úÖ Found window.EthereumProvider (from setup script)');
                } else {
                    // Wait a bit more for SDK to fully initialize
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Try accessing EthereumProvider in different ways
                    try {
                        if (typeof EthereumProvider !== 'undefined' && typeof EthereumProvider.init === 'function') {
                            WCProvider = EthereumProvider;
                            window.EthereumProvider = EthereumProvider;
                            console.log('‚úÖ Found EthereumProvider (global scope)');
                        }
                    } catch (e) {
                        console.log('EthereumProvider not in global scope:', e.message);
                    }
                    
                    if (!WCProvider && typeof window.EthereumProvider !== 'undefined' && typeof window.EthereumProvider.init === 'function') {
                        WCProvider = window.EthereumProvider;
                        console.log('‚úÖ Found window.EthereumProvider');
                    }
                    
                    // Check all window properties for the provider
                    if (!WCProvider) {
                        console.log('Searching all window properties for EthereumProvider...');
                        const allKeys = Object.keys(window);
                        for (const key of allKeys) {
                            try {
                                const val = window[key];
                                if (val && typeof val === 'function' && val.prototype && typeof val.prototype.init === 'function') {
                                    // Check if it looks like EthereumProvider
                                    if (key.includes('Provider') || key.includes('Ethereum') || key.includes('WalletConnect')) {
                                        WCProvider = val;
                                        window.EthereumProvider = val;
                                        console.log('‚úÖ Found provider class:', key);
                                        break;
                                    }
                                } else if (val && typeof val === 'object') {
                                    if (val.EthereumProvider && typeof val.EthereumProvider === 'function' && typeof val.EthereumProvider.prototype.init === 'function') {
                                        WCProvider = val.EthereumProvider;
                                        window.EthereumProvider = WCProvider;
                                        console.log('‚úÖ Found EthereumProvider in', key);
                                        break;
                                    }
                                    if (val.default && typeof val.default === 'function' && typeof val.default.prototype.init === 'function') {
                                        WCProvider = val.default;
                                        window.EthereumProvider = WCProvider;
                                        console.log('‚úÖ Found provider as default in', key);
                                        break;
                                    }
                                }
                            } catch(e) {
                                // Ignore errors
                            }
                        }
                    }
                }
                
                if (!WCProvider && typeof window.WalletConnectEthereumProvider !== 'undefined') {
                    WCProvider = window.WalletConnectEthereumProvider;
                    console.log('‚úÖ Found window.WalletConnectEthereumProvider');
                }
                
                if (!WCProvider && window.WalletConnect && window.WalletConnect.EthereumProvider) {
                    WCProvider = window.WalletConnect.EthereumProvider;
                    console.log('‚úÖ Found window.WalletConnect.EthereumProvider');
                }
                
                if (!WCProvider && window.WalletConnectEthereumProvider) {
                    WCProvider = window.WalletConnectEthereumProvider;
                    console.log('‚úÖ Found window.WalletConnectEthereumProvider (direct)');
                }
                
                // Check for UMD exports - the SDK might expose itself differently
                if (!WCProvider) {
                    const walletConnectKeys = Object.keys(window).filter(k => 
                        k.toLowerCase().includes('walletconnect') || 
                        (k.toLowerCase().includes('ethereum') && k.toLowerCase().includes('provider'))
                    );
                    console.log('Checking for WalletConnect keys:', walletConnectKeys);
                    
                    for (const key of walletConnectKeys) {
                        try {
                            const obj = window[key];
                            if (obj) {
                                if (obj.EthereumProvider) {
                                    WCProvider = obj.EthereumProvider;
                                    console.log('‚úÖ Found provider via', key, '.EthereumProvider');
                                    break;
                                } else if (typeof obj === 'function' && obj.name && obj.name.includes('Provider')) {
                                    WCProvider = obj;
                                    console.log('‚úÖ Found provider function via', key);
                                    break;
                                } else if (typeof obj === 'object' && obj.default && obj.default.EthereumProvider) {
                                    WCProvider = obj.default.EthereumProvider;
                                    console.log('‚úÖ Found provider via', key, '.default.EthereumProvider');
                                    break;
                                }
                            }
                        } catch (e) {
                            console.warn('Error checking key', key, ':', e);
                        }
                    }
                }
                
                if (!WCProvider) {
                    console.error('WalletConnect SDK not found after checking');
                    const relevantKeys = Object.keys(window).filter(k => 
                        k.toLowerCase().includes('wallet') || 
                        k.toLowerCase().includes('connect') ||
                        k.toLowerCase().includes('ethereum') ||
                        k.toLowerCase().includes('provider')
                    );
                    console.log('Available window properties:', relevantKeys);
                    console.log('window.WalletConnect:', window.WalletConnect);
                    console.log('window.EthereumProvider:', window.EthereumProvider);
                    console.log('typeof EthereumProvider:', typeof EthereumProvider);
                    
                    // The UMD build might expose it as a default export or different name
                    // Try accessing it directly if it exists in global scope
                    try {
                        // Check if it's available but not on window
                        if (typeof EthereumProvider !== 'undefined') {
                            WCProvider = EthereumProvider;
                            console.log('Found EthereumProvider in global scope');
                        }
                    } catch (e) {
                        console.warn('Could not access EthereumProvider:', e);
                    }
                    
                    if (!WCProvider) {
                        throw new Error('WalletConnect SDK not available. The SDK loaded but EthereumProvider was not found. Please check the console output above to see what properties are available.');
                    }
                }
                
                console.log('WalletConnect Provider found:', WCProvider);
                
                console.log('WalletConnect Provider found:', WCProvider);
                
                // Get Project ID from localStorage or use default
                // Default Project ID for PolliT
                const defaultProjectId = '73dcb63aac8a5b37aa1ec6b380c444db';
                const projectId = localStorage.getItem('walletconnect_project_id') || defaultProjectId;
                
                if (!projectId || projectId.length < 20) {
                    const errorMsg = 'WalletConnect Project ID not configured.\n\nPlease:\n1. Go to https://cloud.walletconnect.com\n2. Create a project (free)\n3. Copy your Project ID\n4. Set it: localStorage.setItem("walletconnect_project_id", "YOUR_PROJECT_ID")';
                    console.error(errorMsg);
                    
                    if (qrCodeError) {
                        const errorText = qrCodeError.querySelector('p');
                        if (errorText) {
                            errorText.textContent = 'WalletConnect Project ID required. See console for instructions.';
                        }
                    }
                    
                    showQRCodeError();
                    throw new Error('WalletConnect Project ID not configured');
                }
                
                console.log('Initializing WalletConnect with Project ID:', projectId.substring(0, 8) + '...');
                
                // Reset URI
                walletConnectURI = null;
                
                // Initialize WalletConnect - Connect to Base Mainnet (8453) and Base Sepolia testnet (84532)
                walletConnectProvider = await WCProvider.init({
                    projectId: projectId,
                    chains: [8453], // Base Mainnet (primary)
                    optionalChains: [84532], // Base Sepolia testnet (optional)
                    showQrModal: false, // We'll handle QR display ourselves
                    metadata: {
                        name: 'PolliT',
                        description: 'Prediction Market Platform',
                        url: window.location.origin,
                        icons: [`${window.location.origin}/favicon.svg`]
                    }
                });
                
                console.log('WalletConnect provider initialized:', walletConnectProvider);
                
                // Set up event listeners BEFORE connecting
                walletConnectProvider.on('display_uri', (uri) => {
                    console.log('=== WalletConnect URI received ===');
                    console.log('URI:', uri.substring(0, 100) + '...');
                    walletConnectURI = uri;
                    displayWalletConnectQR(uri);
                });
                
                walletConnectProvider.on('connect', (error, payload) => {
                    if (error) {
                        console.error('WalletConnect connection error:', error);
                        showQRCodeError();
                        return;
                    }
                    
                    console.log('WalletConnect connected:', payload);
                    const session = payload.params[0];
                    const accounts = session?.accounts || [];
                    if (accounts && accounts.length > 0) {
                        // Extract address from account string (format: chainId:address)
                        const address = accounts[0].split(':')[2] || accounts[0];
                        handleWalletConnection(address, 'WalletConnect');
                    }
                });
                
                walletConnectProvider.on('disconnect', () => {
                    console.log('WalletConnect disconnected');
                    walletConnectProvider = null;
                    walletConnectURI = null;
                });
                
                walletConnectProvider.on('session_event', (error, payload) => {
                    if (error) {
                        console.error('WalletConnect session error:', error);
                    } else {
                        console.log('WalletConnect session event:', payload);
                    }
                });
                
                console.log('WalletConnect event listeners attached');
                
                return walletConnectProvider;
            } catch (error) {
                console.error('Failed to initialize WalletConnect:', error);
                console.error('Error stack:', error.stack);
                showQRCodeError();
                return null;
            }
        }
        
        // Initialize Coinbase Wallet SDK
        async function initializeCoinbaseWallet() {
            try {
                // Wait for Coinbase Wallet SDK to load
                let attempts = 0;
                while ((typeof CoinbaseWalletSDK === 'undefined' && 
                       typeof window.CoinbaseWalletSDK === 'undefined') && attempts < 30) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                // Check if Coinbase Wallet SDK is available
                const CoinbaseSDK = window.CoinbaseWalletSDK || CoinbaseWalletSDK;
                
                if (!CoinbaseSDK) {
                    console.warn('Coinbase Wallet SDK not loaded (optional - only needed for browser extension)');
                    // Don't throw error - this is optional since we use WalletConnect for mobile
                    return null;
                }
                
                console.log('Coinbase Wallet SDK found');
                
                // Initialize Coinbase Wallet SDK with Base network
                coinbaseWalletSDK = new CoinbaseSDK({
                    appName: 'PolliT',
                    appLogoUrl: `${window.location.origin}/favicon.svg`,
                    darkMode: true
                });
                
                // Make the provider available - connect directly to Base Mainnet
                coinbaseWalletProvider = coinbaseWalletSDK.makeWeb3Provider(
                    'https://mainnet.base.org', // Base Mainnet RPC URL
                    8453 // Base Mainnet chain ID
                );
                
                console.log('Coinbase Wallet provider initialized for Base network');
                
                return coinbaseWalletProvider;
            } catch (error) {
                console.error('Failed to initialize Coinbase Wallet:', error);
                showQRCodeError();
                return null;
            }
        }
        
        // Connect with Coinbase Wallet and generate QR code
        // Make function globally accessible
        window.connectCoinbaseWallet = async function connectCoinbaseWallet() {
            try {
                console.log('=== Coinbase Wallet button clicked ===');
                showWalletConnectStatus('Connecting to Coinbase Wallet...', 'text-blue-400');
                
                // First, check if any Ethereum provider is available (Coinbase Wallet, MetaMask, etc.)
                if (window.ethereum) {
                    console.log('window.ethereum found:', window.ethereum);
                    console.log('isCoinbaseWallet:', window.ethereum.isCoinbaseWallet);
                    console.log('isMetaMask:', window.ethereum.isMetaMask);
                    console.log('providers:', window.ethereum.providers);
                    
                    // Also check for Coinbase Wallet specific properties
                    console.log('Coinbase Wallet properties:', {
                        isCoinbaseWallet: window.ethereum.isCoinbaseWallet,
                        selectedProvider: window.ethereum.selectedProvider,
                        providerName: window.ethereum.providerName,
                        isCoinbaseBrowser: window.ethereum.isCoinbaseBrowser
                    });
                    
                    // Try to find Coinbase Wallet provider
                    let provider = null;
                    
                    // Method 1: Direct Coinbase Wallet flag
                    if (window.ethereum.isCoinbaseWallet) {
                        provider = window.ethereum;
                        console.log('‚úÖ Coinbase Wallet detected (direct flag)');
                    }
                    // Method 2: Check providers array
                    else if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                        provider = window.ethereum.providers.find(p => p.isCoinbaseWallet);
                        if (provider) {
                            console.log('‚úÖ Coinbase Wallet detected (from providers array)');
                        } else {
                            // Try to find by other Coinbase indicators
                            provider = window.ethereum.providers.find(p => 
                                p.providerName === 'coinbaseWalletExtension' ||
                                (p.toString && p.toString().includes('Coinbase'))
                            );
                            if (provider) {
                                console.log('‚úÖ Coinbase Wallet detected (by provider name)');
                            }
                        }
                    }
                    // Method 3: Check if Coinbase Wallet is the selected provider
                    else if (window.ethereum.selectedProvider && window.ethereum.selectedProvider.isCoinbaseWallet) {
                        provider = window.ethereum.selectedProvider;
                        console.log('‚úÖ Coinbase Wallet detected (selected provider)');
                    }
                    // Method 4: If it's not MetaMask, try using it (might be Coinbase)
                    else if (!window.ethereum.isMetaMask) {
                        // If it's not MetaMask, it might be Coinbase Wallet
                        provider = window.ethereum;
                        console.log('‚úÖ Using ethereum provider (not MetaMask, likely Coinbase Wallet)');
                    }
                    // Method 5: Try using window.ethereum directly if no other wallet detected
                    else {
                        // Last resort: try using window.ethereum directly
                        provider = window.ethereum;
                        console.log('‚úÖ Using window.ethereum directly (fallback)');
                    }
                    
                    // If we found a provider, try to connect
                    if (provider) {
                        try {
                            console.log('Requesting accounts from provider...');
                            const accounts = await provider.request({
                                method: 'eth_requestAccounts'
                            });
                            
                            console.log('Accounts received:', accounts);
                            
                            if (accounts && accounts.length > 0) {
                                // Switch to Base network
                                try {
                                    await provider.request({
                                        method: 'wallet_switchEthereumChain',
                                        params: [{ chainId: '0x2105' }] // Base Mainnet: 8453 = 0x2105
                                    });
                                    console.log('Switched to Base network');
                                } catch (switchError) {
                                    console.log('Switch error:', switchError);
                                    // If chain doesn't exist, add it
                                    if (switchError.code === 4902) {
                                        await provider.request({
                                            method: 'wallet_addEthereumChain',
                                            params: [{
                                                chainId: '0x2105',
                                                chainName: 'Base',
                                                nativeCurrency: {
                                                    name: 'ETH',
                                                    symbol: 'ETH',
                                                    decimals: 18
                                                },
                                                rpcUrls: ['https://mainnet.base.org'],
                                                blockExplorerUrls: ['https://basescan.org']
                                            }]
                                        });
                                        console.log('Added Base network');
                                    }
                                }
                                
                                handleWalletConnection(accounts[0], 'Coinbase Wallet');
                                closeWalletModal();
                                
                                // Also close login modal if open
                                const loginModal = document.getElementById('loginModal');
                                if (loginModal) {
                                    loginModal.classList.add('hidden');
                                    loginModal.classList.remove('flex');
                                }
                                
                                return;
                            }
                        } catch (error) {
                            console.error('Coinbase Wallet connection error:', error);
                            if (error.code === 4001) {
                                showWalletConnectStatus('Connection rejected', 'text-yellow-400');
                                return;
                            }
                            // Show error but don't give up
                            showWalletConnectStatus('Connection error: ' + (error.message || 'Unknown error'), 'text-red-400');
                            return;
                        }
                    }
                }
                
                // If no provider found, inform user
                console.log('No Ethereum provider found');
                showWalletConnectStatus('No wallet extension detected. Please install Coinbase Wallet extension or use WalletConnect for mobile wallets.', 'text-yellow-400');
                
                // Note: Coinbase Wallet SDK doesn't automatically show QR codes for mobile
                // The SDK is primarily for browser extension connections
                // Users should use WalletConnect for mobile wallet connections
                
                // Don't try SDK - it won't work without extension and doesn't show QR codes
                // Instead, direct users to WalletConnect
                console.log('Directing user to use WalletConnect for mobile wallets');
                return;
                
            } catch (error) {
                console.error('=== Coinbase Wallet connection error ===');
                console.error('Error message:', error.message);
                console.error('Error code:', error.code);
                console.error('Error stack:', error.stack);
                
                // Show user-friendly error message
                let errorMessage = 'Coinbase Wallet connection failed. ';
                if (error.message && error.message.includes('not found')) {
                    errorMessage += 'Please install the Coinbase Wallet extension or use WalletConnect for mobile.';
                } else if (error.code === 4001) {
                    errorMessage = 'Connection rejected';
                } else if (error.message && error.message.includes('mobile')) {
                    errorMessage = 'For mobile wallets, please use WalletConnect instead.';
                } else {
                    errorMessage += 'Try WalletConnect for mobile wallets.';
                }
                
                showWalletConnectStatus(errorMessage, 'text-red-400');
                
                // Don't show QR error - let user know to use WalletConnect
                console.log('Suggesting user to use WalletConnect for mobile wallets');
            }
        }
        
        // Generate WalletConnect QR Code (for mobile wallets via WalletConnect)
        async function generateCoinbaseQR() {
            try {
                console.log('=== generateCoinbaseQR called ===');
                showQRCodeLoading();
                
                // Reset URI to ensure fresh connection
                walletConnectURI = null;
                
                // Initialize WalletConnect if not already initialized
                if (!walletConnectProvider) {
                    console.log('WalletConnect provider not found, initializing...');
                    walletConnectProvider = await initializeWalletConnect();
                    if (!walletConnectProvider) {
                        console.error('Failed to initialize WalletConnect');
                        throw new Error('Failed to initialize WalletConnect. Please check console for details.');
                    }
                    console.log('WalletConnect provider initialized successfully');
                } else {
                    console.log('WalletConnect provider already exists');
                }
                
                console.log('Connecting to WalletConnect...');
                
                // Connect to WalletConnect - this will trigger the display_uri event for QR code
                try {
                    console.log('Calling walletConnectProvider.connect()...');
                    console.log('Provider:', walletConnectProvider);
                    console.log('Provider methods:', Object.keys(walletConnectProvider || {}));
                    
                    const connection = await walletConnectProvider.connect({
                        chains: [8453], // Base Mainnet (primary)
                        optionalChains: [84532] // Base Sepolia testnet (optional)
                    });
                    
                    console.log('WalletConnect connection initiated:', connection);
                    
                    // Wait for URI to be generated (for QR code)
                    // The display_uri event should fire, but we'll wait up to 5 seconds
                    console.log('Waiting for URI from display_uri event...');
                    let uriWaitAttempts = 0;
                    const maxWaitAttempts = 50; // 5 seconds
                    while (!walletConnectURI && uriWaitAttempts < maxWaitAttempts) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        uriWaitAttempts++;
                        if (uriWaitAttempts % 10 === 0) {
                            console.log('Still waiting for URI...', uriWaitAttempts, '/', maxWaitAttempts);
                        }
                    }
                    
                    // If URI is available, display it
                    if (walletConnectURI) {
                        console.log('URI received! Displaying QR code...');
                        await displayWalletConnectQR(walletConnectURI);
                    } else {
                        console.warn('URI not received after', maxWaitAttempts, 'attempts');
                        console.warn('This might mean:');
                        console.warn('1. Project ID is invalid');
                        console.warn('2. WalletConnect SDK version issue');
                        console.warn('3. Network connectivity issue');
                        console.warn('4. display_uri event not firing');
                        showQRCodeError();
                    }
                    
                } catch (connectError) {
                    console.error('WalletConnect connection error:', connectError);
                    console.error('Error details:', {
                        message: connectError.message,
                        code: connectError.code,
                        stack: connectError.stack
                    });
                    // If user rejects, that's okay
                    if (connectError.message && (connectError.message.includes('User rejected') || 
                        connectError.message.includes('rejected') ||
                        connectError.code === 5001)) {
                        console.log('User rejected WalletConnect connection');
                        resetQRCodeState();
                        return;
                    }
                    throw connectError;
                }
                
            } catch (error) {
                console.error('=== Failed to generate WalletConnect QR code ===');
                console.error('Error:', error);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showQRCodeError();
            }
        }
        
        // Display WalletConnect QR Code
        async function displayCoinbaseQR(qrUrl) {
            return displayWalletConnectQR(qrUrl);
        }
        
        // Display WalletConnect QR Code (main function)
        async function displayWalletConnectQR(uri) {
            try {
                console.log('=== displayWalletConnectQR called ===');
                console.log('URI:', uri ? uri.substring(0, 50) + '...' : 'null');
                
                showQRCodeLoading();
                
                // Wait for QRCode library to load if not already loaded
                let QRCodeLib = null;
                
                // Always use window.QRCode which has our wrapper with toCanvas
                if (typeof window.QRCode !== 'undefined') {
                    QRCodeLib = window.QRCode;
                    console.log('‚úÖ Found window.QRCode (with wrapper)');
                } else if (typeof QRCode !== 'undefined') {
                    // If global QRCode exists but window.QRCode doesn't, use it
                    QRCodeLib = QRCode;
                    window.QRCode = QRCode;
                    console.log('‚úÖ Found QRCode (global)');
                }
                
                // If not found, wait for it to load
                if (!QRCodeLib) {
                    console.log('QRCode library not found, waiting for it to load...');
                    let qrWaitAttempts = 0;
                    const maxQrWait = 100; // 10 seconds
                    while (!QRCodeLib && qrWaitAttempts < maxQrWait) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        qrWaitAttempts++;
                        
                        // Check again
                        if (typeof QRCode !== 'undefined') {
                            QRCodeLib = QRCode;
                            window.QRCode = QRCode;
                            console.log('‚úÖ Found QRCode after waiting (global)');
                            break;
                        } else if (typeof window.QRCode !== 'undefined') {
                            QRCodeLib = window.QRCode;
                            console.log('‚úÖ Found window.QRCode after waiting');
                            break;
                        }
                        
                        if (qrWaitAttempts % 20 === 0) {
                            console.log('Still waiting for QRCode...', qrWaitAttempts);
                        }
                    }
                }
                
                // Check if QRCode library is loaded
                if (!QRCodeLib) {
                    console.error('QRCode library not loaded after waiting');
                    console.error('typeof QRCode:', typeof QRCode);
                    console.error('typeof window.QRCode:', typeof window.QRCode);
                    console.error('window.qrcodeLoaded:', window.qrcodeLoaded);
                    console.error('window.qrcodeLoadError:', window.qrcodeLoadError);
                    
                    // Try to load QRCode library dynamically as last resort
                    console.log('Attempting to load QRCode library dynamically...');
                    try {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            // Try multiple CDNs in order
                            const cdnUrls = [
                                'https://unpkg.com/qrcode@1.5.3/lib/browser.js',
                                'https://cdn.jsdelivr.net/npm/qrcode@1.5.3/lib/browser.js'
                            ];
                            let cdnIndex = 0;
                            
                            function tryNextCDN() {
                                if (cdnIndex >= cdnUrls.length) {
                                    console.error('All QRCode CDNs failed');
                                    if (!resolved) {
                                        resolved = true;
                                        reject(new Error('QRCode library failed to load from all CDNs'));
                                    }
                                    return;
                                }
                                
                                script.src = cdnUrls[cdnIndex];
                                console.log('Trying QRCode CDN:', cdnUrls[cdnIndex]);
                                cdnIndex++;
                            }
                            
                            script.onerror = (err) => {
                                console.warn('QRCode CDN failed:', script.src);
                                if (cdnIndex < cdnUrls.length) {
                                    tryNextCDN();
                                } else {
                                    console.error('Failed to load QRCode dynamically:', err);
                                    if (!resolved) {
                                        resolved = true;
                                        reject(new Error('QRCode library failed to load'));
                                    }
                                }
                            };
                            
                            tryNextCDN();
                            script.crossOrigin = 'anonymous';
                            let resolved = false;
                            
                            script.onload = () => {
                                console.log('QRCode script loaded dynamically, checking availability...');
                                // Wait a moment for library to initialize
                                setTimeout(() => {
                                    // Try multiple ways to access QRCode
                                    if (typeof QRCode !== 'undefined') {
                                        window.QRCode = QRCode;
                                        QRCodeLib = QRCode;
                                        console.log('‚úÖ QRCode found after dynamic load (global)');
                                        if (!resolved) {
                                            resolved = true;
                                            resolve();
                                        }
                                    } else if (typeof window.QRCode !== 'undefined') {
                                        QRCodeLib = window.QRCode;
                                        console.log('‚úÖ QRCode found after dynamic load (window.QRCode)');
                                        if (!resolved) {
                                            resolved = true;
                                            resolve();
                                        }
                                    } else {
                                        // Check all window properties
                                        console.log('Checking all window properties for QRCode...');
                                        const allKeys = Object.keys(window);
                                        for (const key of allKeys) {
                                            try {
                                                const val = window[key];
                                                if (val && typeof val === 'object' && typeof val.toCanvas === 'function') {
                                                    window.QRCode = val;
                                                    QRCodeLib = val;
                                                    console.log('‚úÖ QRCode found via property:', key);
                                                    if (!resolved) {
                                                        resolved = true;
                                                        resolve();
                                                    }
                                                    return;
                                                }
                                            } catch(e) {}
                                        }
                                        console.error('‚ùå QRCode loaded but not accessible');
                                        if (!resolved) {
                                            resolved = true;
                                            reject(new Error('QRCode loaded but not accessible'));
                                        }
                                    }
                                }, 500);
                            };
                            
                            script.onerror = (err) => {
                                console.error('Failed to load QRCode dynamically:', err);
                                if (!resolved) {
                                    resolved = true;
                                    reject(new Error('QRCode library failed to load'));
                                }
                            };
                            
                            document.head.appendChild(script);
                        });
                    } catch (e) {
                        console.error('Dynamic QRCode load failed:', e);
                        showQRCodeError('QR Code generation unavailable. Please refresh the page and try again.');
                        return;
                    }
                }
                
                if (!QRCodeLib) {
                    console.error('QRCode library still not available after all attempts');
                    showQRCodeError('QR Code generation unavailable. Please refresh the page.');
                    return;
                }
                
                console.log('‚úÖ QRCode library found:', typeof QRCodeLib);
                console.log('QRCodeLib.toCanvas:', typeof QRCodeLib.toCanvas);
                if (QRCodeLib.toCanvas) {
                    console.log('QRCodeLib.toCanvas.length:', QRCodeLib.toCanvas.length);
                }
                
                // Check if canvas exists
                if (!qrCodeCanvas) {
                    console.error('QR code canvas element not found');
                    showQRCodeError();
                    return;
                }
                
                // Clear canvas
                const ctx = qrCodeCanvas.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, qrCodeCanvas.width, qrCodeCanvas.height);
                }
                
                // Generate QR code from URL
                await new Promise((resolve, reject) => {
                    try {
                        const options = {
                            width: 256,
                            margin: 2,
                            color: {
                                dark: '#000000',
                                light: '#FFFFFF'
                            },
                            errorCorrectionLevel: 'M'
                        };
                        
                        // Always use window.QRCode which has our wrapper with toCanvas
                        let QRCodeLibToUse = window.QRCode;
                        if (!QRCodeLibToUse && QRCodeLib) {
                            QRCodeLibToUse = QRCodeLib;
                        }
                        if (!QRCodeLibToUse && typeof QRCode !== 'undefined') {
                            QRCodeLibToUse = QRCode;
                        }
                        
                        if (!QRCodeLibToUse) {
                            reject(new Error('QRCode library not available'));
                            return;
                        }
                        
                        console.log('Using QRCodeLib to generate QR code...');
                        console.log('QRCodeLibToUse:', typeof QRCodeLibToUse);
                        console.log('QRCodeLibToUse.toCanvas:', typeof QRCodeLibToUse.toCanvas);
                        
                        // Our wrapper always has toCanvas, so check if it exists
                        if (typeof QRCodeLibToUse.toCanvas === 'function') {
                            // Call the toCanvas method (our wrapper handles both callback and promise APIs)
                            try {
                                const result = QRCodeLibToUse.toCanvas(qrCodeCanvas, uri, options, (error) => {
                                    if (error) {
                                        console.error('QRCode generation error:', error);
                                        reject(error);
                                    } else {
                                        console.log('QR code generated successfully');
                                        resolve();
                                    }
                                });
                                
                                // If it returns a promise, handle it
                                if (result && typeof result.then === 'function') {
                                    result.then(() => {
                                        console.log('QR code generated successfully (promise)');
                                        resolve();
                                    }).catch(reject);
                                }
                            } catch (syncError) {
                                console.error('Synchronous QRCode error:', syncError);
                                reject(syncError);
                            }
                        } else {
                            console.error('QRCodeLibToUse structure:', Object.keys(QRCodeLibToUse || {}).slice(0, 10));
                            reject(new Error('QRCode.toCanvas method not available. Available methods: ' + Object.keys(QRCodeLibToUse || {}).join(', ')));
                        }
                    } catch (syncError) {
                        reject(syncError);
                    }
                });
                
                // Show success state
                showQRCodeDisplay();
                
            } catch (error) {
                console.error('Failed to display QR code:', error);
                showQRCodeError();
            }
        }
        
        // Display Coinbase Wallet QR Code (for Coinbase Wallet extension)
        async function displayCoinbaseQR(qrUrl) {
            return displayWalletConnectQR(qrUrl);
        }
        
        // OLD - Display WalletConnect QR Code (deprecated)
        async function displayWalletConnectQROld(uri) {
            try {
                showQRCodeLoading();
                
                // Check if QRCode library is loaded
                if (typeof QRCode === 'undefined') {
                    console.error('QRCode library not loaded');
                    showQRCodeError();
                    return;
                }
                
                // Check if canvas exists
                if (!qrCodeCanvas) {
                    console.error('QR code canvas element not found');
                    showQRCodeError();
                    return;
                }
                
                // Clear canvas
                const ctx = qrCodeCanvas.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, qrCodeCanvas.width, qrCodeCanvas.height);
                }
                
                // Generate QR code
                await new Promise((resolve, reject) => {
                    try {
                        const options = {
                            width: 256,
                            margin: 2,
                            color: {
                                dark: '#000000',
                                light: '#FFFFFF'
                            },
                            errorCorrectionLevel: 'M'
                        };
                        
                        if (QRCode.toCanvas.length >= 3) {
                            // Callback API
                            QRCode.toCanvas(qrCodeCanvas, uri, options, (error) => {
                                if (error) {
                                    reject(error);
                                } else {
                                    resolve();
                                }
                            });
                        } else {
                            // Promise API
                            const result = QRCode.toCanvas(qrCodeCanvas, uri, options);
                            if (result && typeof result.then === 'function') {
                                result.then(resolve).catch(reject);
                            } else {
                                setTimeout(resolve, 100);
                            }
                        }
                    } catch (syncError) {
                        reject(syncError);
                    }
                });
                
                // Show success state
                showQRCodeDisplay();
                
            } catch (error) {
                console.error('Failed to display QR code:', error);
                showQRCodeError();
            }
        }
        
        // Reset QR code UI state
        function resetQRCodeState() {
            if (qrCodeCanvas) {
                const ctx = qrCodeCanvas.getContext('2d');
                ctx.clearRect(0, 0, qrCodeCanvas.width, qrCodeCanvas.height);
            }
            if (qrCodeLoading) {
                qrCodeLoading.classList.remove('hidden');
            }
            if (qrCodeDisplay) {
                qrCodeDisplay.classList.add('hidden');
            }
            if (qrCodeError) {
                qrCodeError.classList.add('hidden');
            }
            if (generateQRBtn) {
                generateQRBtn.disabled = false;
            }
            if (walletConnectStatus) {
                walletConnectStatus.classList.add('hidden');
                walletConnectStatus.textContent = '';
            }
        }
        
        // Show QR code loading state
        function showQRCodeLoading() {
            if (qrCodeLoading) {
                qrCodeLoading.classList.remove('hidden');
            }
            if (qrCodeDisplay) {
                qrCodeDisplay.classList.add('hidden');
            }
            if (qrCodeError) {
                qrCodeError.classList.add('hidden');
            }
        }
        
        // Show QR code display state
        function showQRCodeDisplay() {
            if (qrCodeLoading) {
                qrCodeLoading.classList.add('hidden');
            }
            if (qrCodeDisplay) {
                qrCodeDisplay.classList.remove('hidden');
            }
            if (qrCodeError) {
                qrCodeError.classList.add('hidden');
            }
        }
        
        // Show QR code error state
        function showQRCodeError() {
            if (qrCodeLoading) {
                qrCodeLoading.classList.add('hidden');
            }
            if (qrCodeDisplay) {
                qrCodeDisplay.classList.add('hidden');
            }
            if (qrCodeError) {
                qrCodeError.classList.remove('hidden');
            }
            // Ensure retry button is enabled and visible
            if (generateQRBtn) {
                generateQRBtn.disabled = false;
                generateQRBtn.style.opacity = '1';
                generateQRBtn.style.cursor = 'pointer';
                generateQRBtn.textContent = 'Retry QR Code';
            }
        }
        
        // Open wallet connect modal when button is clicked
        if (walletConnectBtn) {
            walletConnectBtn.addEventListener('click', async () => {
                if (walletConnectModal) {
                    walletConnectModal.classList.remove('hidden');
                    walletConnectModal.classList.add('flex');
                    // Close login modal if open
                    if (loginModal) {
                        loginModal.classList.add('hidden');
                        loginModal.classList.remove('flex');
                    }
                    // Reset QR code state
                    resetQRCodeState();
                    
                    // Initialize WalletConnect and auto-generate QR code when modal opens
                    setTimeout(async () => {
                        console.log('Modal opened, initializing WalletConnect...');
                        // Generate WalletConnect QR code automatically
                        await generateCoinbaseQR();
                    }, 300);
                }
            });
        }
        
        // Close wallet connect modal
        if (closeWalletModalBtn) {
            closeWalletModalBtn.addEventListener('click', () => {
                if (walletConnectModal) {
                    walletConnectModal.classList.add('hidden');
                    walletConnectModal.classList.remove('flex');
                }
            });
        }
        
        // Close modal when clicking outside
        if (walletConnectModal) {
            walletConnectModal.addEventListener('click', (e) => {
                if (e.target === walletConnectModal) {
                    walletConnectModal.classList.add('hidden');
                    walletConnectModal.classList.remove('flex');
                }
            });
        }
        
        // Connect with Coinbase Wallet Extension
        // Make sure the button exists and attach event listener
        const coinbaseBtn = document.getElementById('coinbaseExtensionBtn');
        if (coinbaseBtn) {
            coinbaseBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Coinbase Wallet button clicked (event listener)');
                try {
                    await connectCoinbaseWallet();
                } catch (error) {
                    console.error('Error in Coinbase Wallet button handler:', error);
                    showWalletConnectStatus('Failed to connect. Please try again.', 'text-red-400');
                }
            });
            console.log('‚úÖ Coinbase Wallet button event listener attached');
        } else {
            console.warn('‚ö†Ô∏è Coinbase Wallet button not found');
            // Try again after a delay
            setTimeout(() => {
                const retryBtn = document.getElementById('coinbaseExtensionBtn');
                if (retryBtn) {
                    retryBtn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Coinbase Wallet button clicked (retry listener)');
                        try {
                            await connectCoinbaseWallet();
                        } catch (error) {
                            console.error('Error in Coinbase Wallet button handler:', error);
                            showWalletConnectStatus('Failed to connect. Please try again.', 'text-red-400');
                        }
                    });
                    console.log('‚úÖ Coinbase Wallet button event listener attached (retry)');
                }
            }, 1000);
        }
        
        // Generate WalletConnect QR Code button handler
        if (generateQRBtn) {
            generateQRBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Generate QR Code button clicked');
                
                // Disable button during generation to prevent multiple clicks
                generateQRBtn.disabled = true;
                generateQRBtn.style.opacity = '0.6';
                generateQRBtn.style.cursor = 'not-allowed';
                
                try {
                    // Reset and generate QR code
                    resetQRCodeState();
                    await generateCoinbaseQR();
                } catch (error) {
                    console.error('Error in button handler:', error);
                    showQRCodeError();
                } finally {
                    // Re-enable button if still in error state
                    if (qrCodeError && !qrCodeError.classList.contains('hidden')) {
                        generateQRBtn.disabled = false;
                        generateQRBtn.style.opacity = '1';
                        generateQRBtn.style.cursor = 'pointer';
                    }
                }
            });
        }
        
        // OLD - MetaMask and WalletConnect functions removed (using Coinbase Wallet only)
        
        // Helper to generate random string for WalletConnect URI
        function generateRandomString(length) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        // Show wallet connect status
        function showWalletConnectStatus(message, colorClass) {
            if (walletConnectStatus) {
                walletConnectStatus.textContent = message;
                walletConnectStatus.className = `mt-4 text-sm text-center ${colorClass}`;
                walletConnectStatus.classList.remove('hidden');
            }
        }
        
        // Handle wallet connection (shared logic)
        async function handleWalletConnection(walletAddress, walletName) {
            try {
                let provider;
                let currentChainId;
                
                // Determine provider based on wallet name
                if (walletName === 'WalletConnect' && walletConnectProvider) {
                    // Use WalletConnect provider
                    provider = walletConnectProvider;
                    const chains = walletConnectProvider.chains;
                    currentChainId = chains && chains.length > 0 ? chains[0] : null;
                } else {
                    // Use browser extension provider
                    provider = window.ethereum || window.coinbaseWalletExtension;
                    currentChainId = await provider.request({ method: 'eth_chainId' });
                    // Convert hex to decimal if needed
                    if (typeof currentChainId === 'string' && currentChainId.startsWith('0x')) {
                        currentChainId = parseInt(currentChainId, 16);
                    }
                }
                
                // Normalize chain ID for comparison (handle both hex string and number)
                let normalizedChainId = currentChainId;
                if (typeof currentChainId === 'string') {
                    if (currentChainId.startsWith('0x')) {
                        normalizedChainId = parseInt(currentChainId, 16);
                    } else {
                        normalizedChainId = parseInt(currentChainId, 10);
                    }
                }
                
                // Check if already on Base Sepolia testnet
                const isBaseSepolia = normalizedChainId === BASE_SEPOLIA_CHAIN_ID;
                const isBaseMainnet = normalizedChainId === BASE_MAINNET_CHAIN_ID;
                
                // Prompt to switch to Base Sepolia testnet if not already on it (only for browser extensions)
                if (!isBaseSepolia && !isBaseMainnet && walletName !== 'WalletConnect') {
                    showWalletConnectStatus('Switching to Base Sepolia testnet...', 'text-blue-400');
                    try {
                        await switchToBaseNetwork(false); // false = use testnet (Base Sepolia)
                        // Update chain ID after switch
                        currentChainId = await provider.request({ method: 'eth_chainId' });
                        if (typeof currentChainId === 'string' && currentChainId.startsWith('0x')) {
                            normalizedChainId = parseInt(currentChainId, 16);
                        } else {
                            normalizedChainId = parseInt(currentChainId, 10);
                        }
                        // Update isBaseSepolia after switch
                        const isBaseSepoliaAfterSwitch = normalizedChainId === BASE_SEPOLIA_CHAIN_ID;
                        const isBaseMainnetAfterSwitch = normalizedChainId === BASE_MAINNET_CHAIN_ID;
                    } catch (switchError) {
                        console.warn('Failed to switch to Base Sepolia:', switchError);
                    }
                }
                
                // Store wallet info
                const walletInfo = {
                    address: walletAddress,
                    chainId: normalizedChainId ? normalizedChainId.toString() : null,
                    isBase: isBaseMainnet || isBaseSepolia,
                    isBaseSepolia: isBaseSepolia,
                    isBaseMainnet: isBaseMainnet,
                    walletName: walletName
                };
                
                // Close wallet connect modal
                if (walletConnectModal) {
                    walletConnectModal.classList.add('hidden');
                    walletConnectModal.classList.remove('flex');
                }
                
                // Handle successful login
                handleLoginSuccess('wallet', walletAddress, walletInfo);
                
                // Set up event listeners for wallet changes (only for browser extensions)
                if (provider && provider.on && walletName !== 'WalletConnect') {
                    provider.on('chainChanged', (chainId) => {
                        console.log('Chain changed to:', chainId);
                        let newChainId = chainId;
                        if (typeof chainId === 'string') {
                            newChainId = chainId.startsWith('0x') ? parseInt(chainId, 16) : parseInt(chainId, 10);
                        }
                        const isBaseSepolia = newChainId === BASE_SEPOLIA_CHAIN_ID;
                        const isBaseMainnet = newChainId === BASE_MAINNET_CHAIN_ID;
                        const isBase = isBaseSepolia || isBaseMainnet;
                        // Update stored wallet info
                        const loginData = localStorage.getItem('userLogin');
                        if (loginData) {
                            try {
                                const data = JSON.parse(loginData);
                                if (data.walletInfo) {
                                    data.walletInfo.chainId = newChainId.toString();
                                    data.walletInfo.isBase = isBase;
                                    data.walletInfo.isBaseSepolia = isBaseSepolia;
                                    data.walletInfo.isBaseMainnet = isBaseMainnet;
                                    localStorage.setItem('userLogin', JSON.stringify(data));
                                }
                            } catch (e) {
                                console.error('Error updating chain info:', e);
                            }
                        }
                    });
                    
                    provider.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            handleLogout();
                        } else {
                            const walletInfo = {
                                address: accounts[0],
                                chainId: provider.chainId,
                                walletName: walletName
                            };
                            handleLoginSuccess('wallet', accounts[0], walletInfo);
                        }
                    });
                }
                
                // For WalletConnect, set up its own event listeners
                if (walletName === 'WalletConnect' && walletConnectProvider) {
                    walletConnectProvider.on('chainChanged', (chainId) => {
                        let newChainId = chainId;
                        if (typeof chainId === 'string') {
                            newChainId = chainId.startsWith('0x') ? parseInt(chainId, 16) : parseInt(chainId, 10);
                        }
                        const isBaseSepolia = newChainId === BASE_SEPOLIA_CHAIN_ID;
                        const isBaseMainnet = newChainId === BASE_MAINNET_CHAIN_ID;
                        const isBase = isBaseSepolia || isBaseMainnet;
                        // Update stored wallet info
                        const loginData = localStorage.getItem('userLogin');
                        if (loginData) {
                            try {
                                const data = JSON.parse(loginData);
                                if (data.walletInfo) {
                                    data.walletInfo.chainId = newChainId.toString();
                                    data.walletInfo.isBase = isBase;
                                    localStorage.setItem('userLogin', JSON.stringify(data));
                                }
                            } catch (e) {
                                console.error('Error updating chain info:', e);
                            }
                        }
                    });
                }
            } catch (error) {
                showWalletConnectStatus('Connection failed', 'text-red-400');
                console.error('Wallet connection error:', error);
            }
        }
        
        
        // Helper function to show login status
        function showLoginStatus(message, colorClass) {
            if (loginStatus) {
                loginStatus.textContent = message;
                loginStatus.className = `mt-4 text-sm text-center ${colorClass}`;
                loginStatus.classList.remove('hidden');
            }
        }
        
        // Handle successful login
        async function handleLoginSuccess(provider, identifier, walletInfo = null) {
            // Determine user address and username
            let userAddress = null;
            let username = null;
            let email = null;
            
            if (provider === 'wallet' && identifier) {
                userAddress = identifier;
                username = `User ${identifier.slice(0, 6)}...${identifier.slice(-4)}`;
            } else if (provider === 'google' || provider === 'apple') {
                // For Google/Apple, use email as identifier and generate a wallet address
                email = identifier;
                username = email.split('@')[0];
                // Generate a deterministic address from email (for demo purposes)
                userAddress = '0x' + Array.from(email).reduce((acc, char) => acc + char.charCodeAt(0).toString(16), '').slice(0, 40).padEnd(40, '0');
            }
            
            // Create or update user in backend
            if (userAddress) {
                try {
                    const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                    const response = await fetch(`${API_URL}/api/users`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            address: userAddress,
                            username: username,
                            email: email,
                            loginMethod: provider === 'wallet' ? 'Wallet' : (provider === 'google' ? 'Google' : 'Apple')
                        })
                    });
                    
                    if (response.ok) {
                        const user = await response.json();
                        localStorage.setItem('userAddress', user.address);
                        localStorage.setItem('userName', user.username);
                        console.log('User created/updated in backend:', user);
                    }
                } catch (error) {
                    console.error('Error creating user in backend:', error);
                }
            }
            
            // Store login info in localStorage
            const loginData = {
                provider: provider,
                identifier: identifier,
                loggedInAt: new Date().toISOString(),
                walletInfo: walletInfo,
                userAddress: userAddress,
                username: username
            };
            localStorage.setItem('userLogin', JSON.stringify(loginData));
            if (userAddress) localStorage.setItem('userAddress', userAddress);
            if (username) localStorage.setItem('userName', username);
            
            // Update UI to show logged in state
            let statusMessage = `Successfully logged in with ${provider}!`;
            if (walletInfo && walletInfo.isBase) {
                statusMessage += ' (Connected to Base)';
            } else if (walletInfo && !walletInfo.isBase) {
                statusMessage += ' (Switch to Base for best experience)';
            }
            showLoginStatus(statusMessage, walletInfo && walletInfo.isBase ? 'text-green-400' : 'text-blue-400');
            
            // Update login button
            updateLoginButton(provider, identifier, true);
            
            // Close modal after short delay and redirect to dashboard
            setTimeout(() => {
                if (loginModal) {
                    loginModal.classList.add('hidden');
                    loginModal.classList.remove('flex');
                }
                if (loginStatus) {
                    loginStatus.classList.add('hidden');
                }
                // Redirect to dashboard
                openDashboard();
            }, 1500);
        }
        
        // Open dashboard
        function openDashboard() {
            console.log('openDashboard called');
            const dashboard = document.getElementById('userDashboard');
            const mainContent = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const helpSupportPage = document.getElementById('helpSupportPage');
            const howItWorksPage = document.getElementById('howItWorksPage');
            const settingsPage = document.getElementById('settingsPage');
            const nav = document.querySelector('nav');
            
            if (!dashboard) {
                console.error('Dashboard element not found');
                alert('Dashboard not found. Please refresh the page.');
                return;
            }
            
            console.log('Dashboard element found:', dashboard);
            
            // Update URL to indicate dashboard is open (without poll parameter)
            // Use replaceState to avoid adding to history stack
            if (window.history && window.history.replaceState) {
                window.history.replaceState({ page: 'dashboard' }, '', window.location.pathname);
            }
            
            // Hide all other pages with !important
            if (mainContent) {
                console.log('Hiding main content');
                mainContent.style.setProperty('display', 'none', 'important');
                mainContent.style.setProperty('visibility', 'hidden', 'important');
            }
            if (marketsContainer) {
                marketsContainer.style.setProperty('display', 'none', 'important');
                marketsContainer.style.setProperty('visibility', 'hidden', 'important');
            }
            if (pollDetailPage) {
                console.log('Hiding poll detail page');
                pollDetailPage.style.setProperty('display', 'none', 'important');
                pollDetailPage.style.setProperty('visibility', 'hidden', 'important');
            }
            if (helpSupportPage) {
                console.log('Hiding Help & Support page');
                helpSupportPage.classList.add('hidden');
                helpSupportPage.style.setProperty('display', 'none', 'important');
                helpSupportPage.style.setProperty('visibility', 'hidden', 'important');
            }
            if (howItWorksPage) {
                howItWorksPage.style.setProperty('display', 'none', 'important');
                howItWorksPage.style.setProperty('visibility', 'hidden', 'important');
            }
            if (settingsPage) {
                settingsPage.style.setProperty('display', 'none', 'important');
                settingsPage.style.setProperty('visibility', 'hidden', 'important');
            }
            // Keep nav visible - don't hide it
            
            // Show dashboard with !important
            console.log('Showing dashboard');
            dashboard.classList.remove('hidden');
            dashboard.style.setProperty('display', 'block', 'important');
            dashboard.style.setProperty('visibility', 'visible', 'important');
            dashboard.style.setProperty('opacity', '1', 'important');
            dashboard.style.setProperty('position', 'relative', 'important');
            dashboard.style.setProperty('z-index', '10', 'important');
            
            // Verify dashboard is visible
            const computedStyle = window.getComputedStyle(dashboard);
            console.log('Dashboard display:', computedStyle.display);
            console.log('Dashboard visibility:', computedStyle.visibility);
            
            // Load dashboard data - ensure it's called after dashboard is visible
            setTimeout(() => {
                if (typeof loadDashboardData === 'function') {
                loadDashboardData();
                } else if (typeof window.loadDashboardData === 'function') {
                    window.loadDashboardData();
                } else {
                    console.warn('loadDashboardData function not found');
                }
            }, 50); // Small delay to ensure DOM is ready
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            
            console.log('Dashboard opened successfully');
            
            // Double-check after a short delay to prevent homepage redirect
            setTimeout(() => {
                const dashboardCheck = document.getElementById('userDashboard');
                const mainCheck = document.querySelector('main');
                const pollDetailCheck = document.getElementById('pollDetailPage');
                
                // Force dashboard to be visible
                if (dashboardCheck) {
                    if (dashboardCheck.style.display === 'none' || window.getComputedStyle(dashboardCheck).display === 'none') {
                        console.warn('Dashboard was hidden after opening! Re-showing...');
                        dashboardCheck.style.display = 'block';
                        dashboardCheck.style.visibility = 'visible';
                    }
                }
                
                // Force main content to be hidden
                if (mainCheck) {
                    if (mainCheck.style.display !== 'none' && window.getComputedStyle(mainCheck).display !== 'none') {
                        console.warn('Main content is still visible! Hiding...');
                        mainCheck.style.display = 'none';
                    }
                }
                
                // Force poll detail to be hidden
                if (pollDetailCheck) {
                    if (pollDetailCheck.style.display !== 'none' && window.getComputedStyle(pollDetailCheck).display !== 'none') {
                        pollDetailCheck.style.display = 'none';
                    }
                }
            }, 100);
        }
        
        // Close dashboard
        function closeDashboard() {
            const dashboard = document.getElementById('userDashboard');
            const mainContent = document.querySelector('main');
            const pollDetailPage = document.getElementById('pollDetailPage');
            
            if (dashboard) {
                dashboard.style.display = 'none';
            }
            
            // Check if there's a poll detail page open
            if (pollDetailPage && pollDetailPage.style.display !== 'none') {
                // Keep poll detail page open
                return;
            }
            
            // Show main content if no poll detail is open
            if (mainContent) {
                mainContent.style.display = 'block';
            }
            
            // Update URL state
            if (window.history && window.history.replaceState) {
                window.history.replaceState({}, '', window.location.pathname);
            }
        }
        
        // Load dashboard data
        function loadDashboardData() {
            console.log('loadDashboardData called');
            const loginData = localStorage.getItem('userLogin');
            if (!loginData) {
                console.warn('No login data found, showing default values');
                // Don't close dashboard - just show default values
                const userInfoEl = document.getElementById('dashboardUserInfo');
                const userNameEl = document.getElementById('dashboardUserName');
                const userInitialEl = document.getElementById('dashboardUserInitial');
                
                if (userInfoEl) userInfoEl.textContent = 'Not logged in';
                if (userNameEl) userNameEl.textContent = 'Guest';
                if (userInitialEl) userInitialEl.textContent = 'G';
                
                // Update logout button to show "Log In" when not logged in
                const logoutBtn = document.getElementById('dashboardLogoutBtn');
                if (logoutBtn) {
                    logoutBtn.textContent = 'Log In';
                    logoutBtn.style.backgroundColor = '#9333ea'; // Purple for login
                }
                
                // Set all stats to 0
                const totalInvestedEl = document.getElementById('dashboardTotalInvested');
                const activePositionsEl = document.getElementById('dashboardActivePositions');
                const marketsCreatedEl = document.getElementById('dashboardMarketsCreated');
                if (totalInvestedEl) totalInvestedEl.textContent = '$0';
                if (activePositionsEl) activePositionsEl.textContent = '0';
                if (marketsCreatedEl) marketsCreatedEl.textContent = '0';
                
                return;
            }
            
            try {
                const data = JSON.parse(loginData);
                const identifier = data.identifier || '';
                const provider = data.provider || '';
                const walletInfo = data.walletInfo || null;
                // Get username from login data or localStorage
                const username = data.username || localStorage.getItem('userName') || null;
                
                console.log('Loading dashboard data:', { identifier, provider, username, walletInfo, data });
                
                // Update user info - ensure elements exist
                const userNameEl = document.getElementById('dashboardUserName');
                const userInfoEl = document.getElementById('dashboardUserInfo');
                const userInitialEl = document.getElementById('dashboardUserInitial');
                
                console.log('Dashboard elements found:', { 
                    userNameEl: !!userNameEl, 
                    userInfoEl: !!userInfoEl, 
                    userInitialEl: !!userInitialEl 
                });
                
                // Always update userInfoEl to remove "Loading..." text
                if (!userInfoEl) {
                    console.error('dashboardUserInfo element not found!');
                }
                
                if (!userNameEl) {
                    console.error('dashboardUserName element not found!');
                }
                
                // Use username if available, otherwise fall back to provider-specific names
                if (username) {
                if (userNameEl) {
                        userNameEl.textContent = username;
                    }
                        if (userInfoEl) {
                        if (provider === 'wallet' && identifier) {
                            const shortAddress = identifier.length > 10 
                                ? `${identifier.substring(0, 6)}...${identifier.substring(identifier.length - 4)}`
                                : identifier;
                            userInfoEl.textContent = `${shortAddress}${walletInfo && walletInfo.isBase ? ' ‚Ä¢ Base Network' : ''}`;
                        } else {
                            userInfoEl.textContent = identifier || 'User';
                        }
                        }
                        if (userInitialEl) {
                        userInitialEl.textContent = username.substring(0, 1).toUpperCase();
                    }
                } else if (provider === 'wallet' && walletInfo) {
                    if (userNameEl) {
                        userNameEl.textContent = walletInfo.walletName || 'Wallet';
                    }
                    if (userInfoEl) {
                        const shortAddress = identifier.length > 10 
                            ? `${identifier.substring(0, 6)}...${identifier.substring(identifier.length - 4)}`
                            : identifier;
                        userInfoEl.textContent = `${shortAddress}${walletInfo.isBase ? ' ‚Ä¢ Base Network' : ''}`;
                    }
                    if (userInitialEl && identifier) {
                            userInitialEl.textContent = identifier.substring(2, 3).toUpperCase();
                        }
                    } else {
                    // Fallback for other providers
                    if (userNameEl) {
                        if (provider === 'google') {
                            userNameEl.textContent = 'Google User';
                        } else if (provider === 'apple') {
                            userNameEl.textContent = 'Apple User';
                        } else {
                            userNameEl.textContent = identifier || 'User';
                        }
                    }
                        if (userInfoEl) {
                        userInfoEl.textContent = identifier || 'User';
                        }
                    if (userInitialEl && identifier) {
                            userInitialEl.textContent = identifier.substring(0, 1).toUpperCase();
                    }
                }
                
                console.log('User info updated:', {
                    userName: userNameEl ? userNameEl.textContent : 'N/A',
                    userInfo: userInfoEl ? userInfoEl.textContent : 'N/A',
                    userInitial: userInitialEl ? userInitialEl.textContent : 'N/A'
                });
                
                // Update logout button to show "Log Out" when logged in
                const logoutBtn = document.getElementById('dashboardLogoutBtn');
                if (logoutBtn) {
                    logoutBtn.textContent = 'Log Out';
                    logoutBtn.style.backgroundColor = '#dc2626'; // Red for logout
                }
                
                // Load markets from localStorage before calculating stats
                let markets = [];
                try {
                    // Use the same function that loads markets elsewhere
                    if (typeof loadMarketsFromStorage === 'function') {
                        const storedMarkets = loadMarketsFromStorage();
                        if (storedMarkets && storedMarkets.length > 0) {
                            markets = storedMarkets;
                        }
                    } else {
                        // Fallback: try loading directly from localStorage
                        const STORAGE_KEY = 'pollit_markets';
                        const storedMarkets = localStorage.getItem(STORAGE_KEY);
                        if (storedMarkets) {
                            const parsed = JSON.parse(storedMarkets);
                            if (Array.isArray(parsed) && parsed.length > 0) {
                                markets = parsed;
                            }
                        }
                    }
                    
                    // If no stored markets, try to get from window.markets (global variable)
                    if (markets.length === 0 && typeof window !== 'undefined' && window.markets && Array.isArray(window.markets)) {
                        markets = window.markets;
                        console.log('Using window.markets:', markets.length);
                    }
                } catch (e) {
                    console.error('Error loading markets from localStorage:', e);
                }
                
                console.log('Markets loaded for dashboard:', markets.length, markets);
                
                // Calculate stats - filter by user's identifier/address
                // For wallet users, use the wallet address; for others, use identifier
                const userIdentifier = (provider === 'wallet' && identifier) ? identifier.toLowerCase() : identifier;
                
                const userMarkets = markets.filter(m => {
                    // Check if market has creator field and match it with user identifier
                    if (m.creator) {
                        return m.creator.toLowerCase() === userIdentifier;
                    }
                    // Fallback: if no creator field, return false (new users should see 0)
                    return false;
                });
                
                const marketsCreatedEl = document.getElementById('dashboardMarketsCreated');
                const marketsCreatedListEl = document.getElementById('dashboardMarketsCreatedList');
                
                if (marketsCreatedEl) {
                    marketsCreatedEl.textContent = userMarkets.length || '0';
                }
                
                // Show market details - dynamically fit as many as possible
                if (marketsCreatedListEl) {
                    if (userMarkets.length === 0) {
                        marketsCreatedListEl.innerHTML = '<div class="text-[#6b7280]">No markets created yet</div>';
                    } else {
                        // Function to calculate and render markets
                        const renderMarketsList = () => {
                            // Get the container's available space
                            const container = marketsCreatedListEl.closest('.rounded-xl') || marketsCreatedListEl.parentElement;
                            let maxVisible = userMarkets.length; // Default: show all
                            
                            if (container && container.offsetHeight > 0) {
                                // Get container height
                                const containerHeight = container.offsetHeight || container.getBoundingClientRect().height;
                                
                                if (containerHeight > 0) {
                                    // Estimate: header (title + count + button) ~100px, padding ~24px, "+X more" text ~24px
                                    const reservedHeight = 100 + 24 + 24; // Header + padding + footer text
                                    const availableHeight = Math.max(0, containerHeight - reservedHeight);
                                    
                                    // Each market item is approximately 36px tall (py-1.5 = 12px + content ~24px)
                                    const itemHeight = 36;
                                    const maxItems = Math.max(1, Math.floor(availableHeight / itemHeight));
                                    
                                    // Don't show more than we have
                                    maxVisible = Math.min(maxItems, userMarkets.length);
                                    
                                    // Ensure we show at least 1 if there are markets
                                    if (maxVisible < 1 && userMarkets.length > 0) {
                                        maxVisible = 1;
                                    }
                                }
                            }
                            
                            const marketsToShow = userMarkets.slice(0, maxVisible);
                            const remaining = userMarkets.length - maxVisible;
                            
                            const marketsList = marketsToShow.map(m => {
                                const emoji = (m.category && categoryEmojis[m.category]) || m.emoji || 'üìä';
                                const vol = parseFloat(m.volume) || 0;
                                const volText = vol >= 1000 ? `$${(vol / 1000).toFixed(1)}k` : `$${vol.toFixed(0)}`;
                                return `<div class="flex items-center justify-between py-1.5 px-2 -mx-2 rounded cursor-pointer hover:bg-gray-800 transition-all group" onclick="event.stopPropagation(); (function() { const pollId = '${m.id}'; const dashboard = document.getElementById('userDashboard'); if(dashboard) dashboard.style.display = 'none'; if(typeof openPollDetail === 'function') { openPollDetail(pollId); } else if(typeof window.openPollDetail === 'function') { window.openPollDetail(pollId); } else { console.error('openPollDetail function not found'); } })();"><span class="flex items-center gap-1.5 truncate max-w-[140px] flex-1"><span>${emoji}</span><span class="truncate text-white group-hover:text-purple-300 transition-colors">${m.title}</span></span><span class="text-white font-medium ml-2">${volText}</span></div>`;
                            }).join('');
                            
                            // Only show "+X more" if there are actually more markets that don't fit
                            const remainingText = remaining > 0 ? `<div class="text-[#6b7280] mt-1 text-xs cursor-pointer hover:text-white transition-colors" onclick="event.stopPropagation(); showMarketsCreatedDetail();">+${remaining} more market${remaining !== 1 ? 's' : ''} ‚Ä¢ Click to view all</div>` : '';
                            marketsCreatedListEl.innerHTML = marketsList + remainingText;
                        };
                        
                        // Render immediately
                        renderMarketsList();
                        
                        // Re-render after a short delay to ensure container dimensions are available
                        setTimeout(() => {
                            renderMarketsList();
                        }, 100);
                    }
                }
                
                // Store user markets for detail view
                window.dashboardUserMarkets = userMarkets;
                
                // Calculate active positions (markets where user has traded)
                // Initialize activePositions here before it's used
                let activePositions = [];
                let totalPnL = 0;
                let winningPnL = 0;
                let losingPnL = 0;
                // Get user address from multiple sources to ensure we match trades
                let userAddress = userIdentifier;
                if (provider === 'wallet' && identifier) {
                    userAddress = identifier.toLowerCase();
                } else {
                    // Try to get from login data
                    const loginData = localStorage.getItem('userLogin');
                    if (loginData) {
                        try {
                            const loginDataObj = JSON.parse(loginData);
                            userAddress = (loginDataObj.userAddress || loginDataObj.identifier || identifier).toLowerCase();
                        } catch (e) {
                            console.warn('Error parsing login data:', e);
                        }
                    }
                }
                
                console.log('Loading positions for user:', userAddress);
                console.log('User identifier:', userIdentifier);
                console.log('Provider:', provider);
                
                // Check localStorage for trade history
                const tradeHistory = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
                console.log('Trade history (all):', tradeHistory);
                console.log('Trade history length:', tradeHistory.length);
                
                // Show all unique addresses in trade history
                const allAddressesInHistory = [...new Set(tradeHistory.map(t => t.userAddress).filter(a => a))];
                console.log('All addresses found in trade history:', allAddressesInHistory);
                
                // Try multiple address formats to match trades
                // Get userAddress from localStorage first (same way trades are saved)
                let storedUserAddress = localStorage.getItem('userAddress');
                const possibleAddresses = [
                    userAddress,
                    userIdentifier.toLowerCase(),
                    identifier.toLowerCase()
                ];
                
                // Add userAddress from localStorage if available
                if (storedUserAddress) {
                    possibleAddresses.push(storedUserAddress.toLowerCase());
                }
                
                // Add userAddress from login data if available
                try {
                    const loginDataCheck = localStorage.getItem('userLogin');
                    if (loginDataCheck) {
                        const loginDataObj = JSON.parse(loginDataCheck);
                        if (loginDataObj.userAddress) {
                            possibleAddresses.push(loginDataObj.userAddress.toLowerCase());
                        }
                        // Also check identifier from login data
                        if (loginDataObj.identifier) {
                            possibleAddresses.push(loginDataObj.identifier.toLowerCase());
                        }
                    }
                } catch (e) {
                    console.warn('Error getting userAddress from login data:', e);
                }
                
                // Remove duplicates and null/undefined
                const uniqueAddresses = [...new Set(possibleAddresses.filter(a => a))];
                
                console.log('All possible addresses for matching:', uniqueAddresses);
                
                console.log('Possible addresses to match:', uniqueAddresses);
                
                const userTrades = tradeHistory.filter(t => {
                    if (!t.userAddress) {
                        console.log('Trade missing userAddress:', t);
                        return false;
                    }
                    const tradeAddress = t.userAddress.toLowerCase();
                    // Check against all possible address formats
                    const match = uniqueAddresses.some(addr => tradeAddress === addr);
                    if (match) {
                        console.log('Matched trade:', { tradeAddress, matchedAddress: uniqueAddresses.find(a => tradeAddress === a), trade: t });
                    }
                    return match;
                });
                
                console.log('User trades found:', userTrades.length, userTrades);
                
                if (userTrades.length === 0 && tradeHistory.length > 0) {
                    console.warn('‚ö†Ô∏è No trades matched!');
                    console.warn('Trade history addresses:', allAddressesInHistory);
                    console.warn('Looking for addresses:', uniqueAddresses);
                    console.warn('Current userAddress:', userAddress);
                    console.warn('Current userIdentifier:', userIdentifier);
                    console.warn('Current identifier:', identifier);
                    
                    // Try fuzzy matching as fallback
                    console.log('Attempting fuzzy matching...');
                    const fuzzyMatches = tradeHistory.filter(t => {
                        if (!t.userAddress) return false;
                        const tradeAddr = t.userAddress.toLowerCase();
                        return uniqueAddresses.some(addr => {
                            // Exact match
                            if (tradeAddr === addr) return true;
                            // Check if addresses are similar (e.g., one contains the other)
                            if (tradeAddr.includes(addr) || addr.includes(tradeAddr)) return true;
                            return false;
                        });
                    });
                    console.log('Fuzzy matches found:', fuzzyMatches.length, fuzzyMatches);
                    if (fuzzyMatches.length > 0) {
                        console.log('Using fuzzy matches for stats calculation');
                        // Add fuzzy matches to userTrades
                        fuzzyMatches.forEach(t => {
                            if (!userTrades.find(ut => ut.marketId === t.marketId && ut.outcomeIndex === t.outcomeIndex && ut.timestamp === t.timestamp)) {
                                userTrades.push(t);
                            }
                        });
                    }
                }
                if (userTrades.length === 0 && tradeHistory.length > 0) {
                    console.warn('No trades matched! Trade history addresses:', tradeHistory.map(t => t.userAddress));
                    console.warn('Looking for addresses:', possibleAddresses);
                }
                
                if (userTrades.length > 0) {
                    // Group trades by market
                    const tradesByMarket = {};
                    userTrades.forEach(trade => {
                        if (!tradesByMarket[trade.marketId]) {
                            tradesByMarket[trade.marketId] = [];
                        }
                        tradesByMarket[trade.marketId].push(trade);
                    });
                    
                    // Calculate positions - separate buys from sells
                    Object.keys(tradesByMarket).forEach(marketId => {
                        const market = markets.find(m => m.id === marketId);
                        if (market) {
                            const trades = tradesByMarket[marketId];
                            
                            // Separate buys and sells
                            const buys = trades.filter(t => t.tradeType === 'buy');
                            const sells = trades.filter(t => t.tradeType === 'sell');
                            
                            // Calculate totals
                            const totalBought = buys.reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                            const totalSold = sells.reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                            const remainingPosition = Math.max(0, totalBought - totalSold);
                            
                            // Only show position if there's a remaining position
                            if (remainingPosition > 0) {
                                const percentages = market.percentages || [];
                                const maxPct = percentages.length > 0 ? Math.max(...percentages) : 50;
                                
                                // Calculate PnL based on remaining position
                                const currentValue = remainingPosition * (maxPct / 100);
                                const pnl = currentValue - remainingPosition;
                                
                                activePositions.push({
                                    marketId: marketId,
                                    title: market.title,
                                    volume: remainingPosition, // Show remaining position, not total invested
                                    totalBought: totalBought,
                                    totalSold: totalSold,
                                    pnl: pnl,
                                    outcomeIndex: trades[0].outcomeIndex
                                });
                                
                                totalPnL += pnl;
                                if (pnl > 0) {
                                    winningPnL += pnl;
                                } else {
                                    losingPnL += Math.abs(pnl);
                                }
                            }
                        }
                    });
                }
                
                // Calculate total invested (only buys) and total sold from all user trades
                let totalInvested = 0; // Total amount bought
                let totalSold = 0; // Total amount sold
                if (userTrades.length > 0) {
                    totalInvested = userTrades
                        .filter(t => t.tradeType === 'buy')
                        .reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                    totalSold = userTrades
                        .filter(t => t.tradeType === 'sell')
                        .reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                }
                
                const remainingPosition = Math.max(0, totalInvested - totalSold);
                
                console.log('Calculated stats:', {
                    totalInvested,
                    totalSold,
                    remainingPosition,
                    activePositionsCount: activePositions.length,
                    totalPnL,
                    winningPnL,
                    losingPnL
                });
                
                // Update Total Invested section
                const totalInvestedEl = document.getElementById('dashboardTotalInvested');
                const totalPnLEl = document.getElementById('dashboardTotalPnL');
                const volumeBreakdownEl = document.getElementById('dashboardVolumeBreakdown');
                
                console.log('Dashboard elements found:', {
                    totalInvestedEl: !!totalInvestedEl,
                    totalPnLEl: !!totalPnLEl,
                    volumeBreakdownEl: !!volumeBreakdownEl
                });
                
                // Show Total Invested (all buys)
                if (totalInvestedEl) {
                    if (totalInvested === 0) {
                        totalInvestedEl.textContent = '$0';
                    } else if (totalInvested < 1000) {
                        totalInvestedEl.textContent = `$${totalInvested.toFixed(2)}`;
                    } else {
                        totalInvestedEl.textContent = `$${(totalInvested / 1000).toFixed(2)}k`;
                    }
                    console.log('Updated totalInvestedEl:', totalInvestedEl.textContent);
                } else {
                    console.error('totalInvestedEl not found!');
                }
                
                // Show Total P&L and position breakdown
                if (totalPnLEl) {
                    if (totalInvested === 0) {
                        totalPnLEl.innerHTML = '<span class="text-[#6b7280] text-xs">Start trading to see your P&L</span>';
                    } else {
                        const pnlColor = totalPnL >= 0 ? '#10b981' : '#ef4444';
                        const pnlIcon = totalPnL >= 0 ? 'üìà' : 'üìâ';
                        const pnlSign = totalPnL >= 0 ? '+' : '';
                        
                        let positionInfo = '';
                        if (totalSold > 0) {
                            const remainingText = remainingPosition < 1000 ? `$${remainingPosition.toFixed(2)}` : `$${(remainingPosition / 1000).toFixed(2)}k`;
                            const soldText = totalSold < 1000 ? `$${totalSold.toFixed(2)}` : `$${(totalSold / 1000).toFixed(2)}k`;
                            positionInfo = `<div class="text-xs mt-1 space-y-0.5"><div class="text-[#8b949e]">Current Position: <span class="text-white font-medium">${remainingText}</span></div><div class="text-[#8b949e]">Amount Sold: <span class="text-[#ef4444] font-medium">${soldText}</span></div></div>`;
                        }
                        
                        totalPnLEl.innerHTML = `<span class="font-semibold" style="color: ${pnlColor};">${pnlIcon} ${pnlSign}$${totalPnL.toFixed(2)} P&L</span>${positionInfo}`;
                    }
                }
                
                // Show breakdown of where money is invested (remaining positions only)
                if (volumeBreakdownEl) {
                    if (activePositions.length === 0) {
                        if (totalSold > 0 && totalInvested > 0) {
                            volumeBreakdownEl.innerHTML = '<span class="text-[#6b7280]">All positions sold</span>';
                        } else {
                            volumeBreakdownEl.innerHTML = '<span class="text-[#6b7280]">No active positions</span>';
                        }
                    } else {
                        const breakdown = activePositions.slice(0, 2).map(pos => {
                            const market = markets.find(m => m.id === pos.marketId);
                            const emoji = market ? ((market.category && categoryEmojis[market.category]) || market.emoji || 'üìä') : 'üìä';
                            // Show remaining position, not total bought
                            return `<div class="flex items-center justify-between"><span class="flex items-center gap-1.5 truncate max-w-[120px]"><span>${emoji}</span><span class="truncate text-white">${pos.title}</span></span><span class="font-medium text-white">$${pos.volume.toFixed(0)}</span></div>`;
                        }).join('');
                        const remaining = activePositions.length - 2;
                        const remainingText = remaining > 0 ? `<div class="text-[#6b7280] mt-1">+${remaining} more position${remaining !== 1 ? 's' : ''}</div>` : '';
                        volumeBreakdownEl.innerHTML = breakdown + remainingText;
                    }
                }
                
                const activePositionsEl = document.getElementById('dashboardActivePositions');
                const positionsInfoEl = document.getElementById('dashboardPositionsInfo');
                
                console.log('Active positions elements found:', {
                    activePositionsEl: !!activePositionsEl,
                    positionsInfoEl: !!positionsInfoEl
                });
                
                // Store active positions for detail view (after calculation)
                window.dashboardActivePositions = activePositions;
                
                if (activePositionsEl) {
                    activePositionsEl.textContent = activePositions.length.toString();
                    console.log('Updated activePositionsEl:', activePositionsEl.textContent);
                } else {
                    console.error('activePositionsEl not found!');
                }
                
                // Show positions info - where bets are placed
                if (positionsInfoEl) {
                    if (activePositions.length === 0) {
                        positionsInfoEl.innerHTML = '<div class="text-[#6b7280] space-y-1"><div>No active positions</div><div class="text-xs">Start trading to see your positions</div></div>';
                    } else {
                        const positionsList = activePositions.slice(0, 3).map(pos => {
                            const market = markets.find(m => m.id === pos.marketId);
                            const emoji = market ? ((market.category && categoryEmojis[market.category]) || market.emoji || 'üìä') : 'üìä';
                            const outcomeName = market && market.outcomes && market.outcomes[pos.outcomeIndex] ? market.outcomes[pos.outcomeIndex] : 'Unknown';
                            const pnlColor = pos.pnl >= 0 ? '#10b981' : '#ef4444';
                            const pnlSign = pos.pnl >= 0 ? '+' : '';
                            // Show remaining position amount, and optionally show sold amount if any
                            let soldInfo = '';
                            if (pos.totalSold && pos.totalSold > 0) {
                                soldInfo = `<div class="text-[#ef4444] text-xs">Sold: $${pos.totalSold.toFixed(0)}</div>`;
                            }
                            return `<div class="flex items-center justify-between py-1"><div class="flex items-center gap-1.5 truncate max-w-[140px] flex-1"><span>${emoji}</span><div class="flex-1 min-w-0"><div class="truncate text-white text-xs">${pos.title}</div><div class="text-[#6b7280] text-xs truncate">${outcomeName}</div></div></div><div class="flex flex-col items-end ml-2"><span class="text-white font-medium text-xs">$${pos.volume.toFixed(0)}</span>${soldInfo}<span class="text-xs font-medium" style="color: ${pnlColor};">${pnlSign}$${pos.pnl.toFixed(2)}</span></div></div>`;
                        }).join('');
                        const remaining = activePositions.length - 3;
                        const remainingText = remaining > 0 ? `<div class="text-[#6b7280] mt-1 text-xs">+${remaining} more position${remaining !== 1 ? 's' : ''} ‚Ä¢ Click to view all</div>` : '';
                        positionsInfoEl.innerHTML = positionsList + remainingText;
                    }
                }
                
                // Render user's markets
                renderDashboardMarkets(userMarkets.slice(0, 10)); // Show first 10
                
                // Load and display Recent Activity
                loadRecentActivity(userTrades, userMarkets, markets);
                
            } catch (error) {
                console.error('Error loading dashboard data:', error);
                console.error('Error stack:', error.stack);
                // Ensure "Loading..." text is replaced even on error
                const userInfoEl = document.getElementById('dashboardUserInfo');
                const userNameEl = document.getElementById('dashboardUserName');
                const userInitialEl = document.getElementById('dashboardUserInitial');
                
                if (userInfoEl) {
                    if (userInfoEl.textContent === 'Loading...' || !userInfoEl.textContent) {
                        // Try to get basic info from localStorage
                        try {
                            const loginData = localStorage.getItem('userLogin');
                            if (loginData) {
                                const data = JSON.parse(loginData);
                                userInfoEl.textContent = data.identifier || 'User';
                            } else {
                                userInfoEl.textContent = 'Not logged in';
                            }
                        } catch (e) {
                            userInfoEl.textContent = 'Unable to load user info';
                        }
                    }
                }
                
                if (userNameEl) {
                    if (userNameEl.textContent === 'User' || !userNameEl.textContent) {
                        try {
                            const loginData = localStorage.getItem('userLogin');
                            if (loginData) {
                                const data = JSON.parse(loginData);
                                userNameEl.textContent = data.username || data.name || data.identifier || 'User';
                            }
                        } catch (e) {
                            userNameEl.textContent = 'User';
                        }
                    }
                }
                
                if (userInitialEl) {
                    try {
                        const loginData = localStorage.getItem('userLogin');
                        if (loginData) {
                            const data = JSON.parse(loginData);
                            const name = data.username || data.name || data.identifier || 'U';
                            userInitialEl.textContent = name.substring(0, 1).toUpperCase();
                        } else {
                            userInitialEl.textContent = 'U';
                        }
                    } catch (e) {
                        userInitialEl.textContent = 'U';
                    }
                }
                
                // Ensure stats show 0 instead of staying blank
                const totalInvestedEl = document.getElementById('dashboardTotalInvested');
                const activePositionsEl = document.getElementById('dashboardActivePositions');
                const marketsCreatedEl = document.getElementById('dashboardMarketsCreated');
                
                if (totalInvestedEl && (!totalInvestedEl.textContent || totalInvestedEl.textContent === '')) {
                    totalInvestedEl.textContent = '$0';
                }
                if (activePositionsEl && (!activePositionsEl.textContent || activePositionsEl.textContent === '')) {
                    activePositionsEl.textContent = '0';
                }
                if (marketsCreatedEl && (!marketsCreatedEl.textContent || marketsCreatedEl.textContent === '')) {
                    marketsCreatedEl.textContent = '0';
                }
            }
        }
        
        // Handle dashboard auth button (Log In / Log Out)
        function handleDashboardAuth() {
            const loginData = localStorage.getItem('userLogin');
            if (!loginData) {
                // Not logged in - open login modal
                closeDashboard();
                const loginModal = document.getElementById('loginModal');
                if (loginModal) {
                    loginModal.classList.remove('hidden');
                    loginModal.classList.add('flex');
                }
            } else {
                // Logged in - log out
                handleLogout();
                closeDashboard();
            }
        }
        
        // Make functions globally accessible
        window.loadDashboardData = loadDashboardData;
        window.handleDashboardAuth = handleDashboardAuth;
        window.loadRecentActivity = loadRecentActivity;
        window.getTimeAgo = getTimeAgo;
        
        // Load and display Recent Activity
        function loadRecentActivity(userTrades, userMarkets, allMarkets) {
            console.log('loadRecentActivity called:', { 
                userTradesCount: userTrades ? userTrades.length : 0, 
                userMarketsCount: userMarkets ? userMarkets.length : 0,
                allMarketsCount: allMarkets ? allMarkets.length : 0
            });
            
            const recentActivityEl = document.getElementById('dashboardRecentActivity');
            if (!recentActivityEl) {
                console.warn('Recent Activity element not found');
                return;
            }
            
            // Combine trades and market creation into a single activity array
            const activities = [];
            
            // Add market creation activities
            if (userMarkets && userMarkets.length > 0) {
                userMarkets.forEach(market => {
                    if (market.createdAt) {
                        activities.push({
                            type: 'market_created',
                            timestamp: new Date(market.createdAt).getTime(),
                            date: new Date(market.createdAt),
                            marketId: market.id,
                            marketTitle: market.title,
                            emoji: (market.category && categoryEmojis[market.category]) || market.emoji || 'üìä'
                        });
                    }
                });
            }
            
            // Add trade activities
            if (userTrades && userTrades.length > 0) {
                userTrades.forEach(trade => {
                    const market = allMarkets.find(m => m.id === trade.marketId);
                    if (market) {
                        const outcomeName = market.outcomes && market.outcomes[trade.outcomeIndex] 
                            ? market.outcomes[trade.outcomeIndex] 
                            : `Outcome ${trade.outcomeIndex + 1}`;
                        
                        const tradeTimestamp = trade.timestamp || trade.date || new Date().toISOString();
                        activities.push({
                            type: trade.tradeType === 'buy' ? 'trade_buy' : 'trade_sell',
                            timestamp: new Date(tradeTimestamp).getTime(),
                            date: new Date(tradeTimestamp),
                            marketId: trade.marketId,
                            marketTitle: market.title,
                            outcomeName: outcomeName,
                            amount: parseFloat(trade.amount) || 0,
                            emoji: (market.category && categoryEmojis[market.category]) || market.emoji || 'üìä'
                        });
                    }
                });
            }
            
            // Sort by timestamp (most recent first)
            activities.sort((a, b) => b.timestamp - a.timestamp);
            
            console.log('Activities found:', activities.length, activities);
            
            // Show only the most recent 10 activities
            const recentActivities = activities.slice(0, 10);
            
            if (recentActivities.length === 0) {
                console.log('No recent activities to display');
                recentActivityEl.innerHTML = `
                    <div class="p-4 rounded-lg" style="background-color: #161b22; border: 1px solid #30363d;">
                        <p class="text-sm text-[#6b7280]">No recent activity</p>
                    </div>
                `;
                return;
            }
            
            console.log('Displaying', recentActivities.length, 'recent activities');
            
            // Format activities for display
            recentActivityEl.innerHTML = recentActivities.map(activity => {
                const timeAgo = getTimeAgo(activity.date);
                let activityText = '';
                let activityIcon = '';
                let activityColor = '#8b949e';
                
                if (activity.type === 'market_created') {
                    activityIcon = '‚ú®';
                    activityText = `Created market "${activity.marketTitle}"`;
                    activityColor = '#9333ea';
                } else if (activity.type === 'trade_buy') {
                    activityIcon = 'üìà';
                    const amountText = activity.amount >= 1000 ? `$${(activity.amount / 1000).toFixed(1)}k` : `$${activity.amount.toFixed(2)}`;
                    activityText = `Bought ${amountText} of "${activity.outcomeName}" in "${activity.marketTitle}"`;
                    activityColor = '#10b981';
                } else if (activity.type === 'trade_sell') {
                    activityIcon = 'üìâ';
                    const amountText = activity.amount >= 1000 ? `$${(activity.amount / 1000).toFixed(1)}k` : `$${activity.amount.toFixed(2)}`;
                    activityText = `Sold ${amountText} of "${activity.outcomeName}" in "${activity.marketTitle}"`;
                    activityColor = '#ef4444';
                }
                
                return `
                    <div class="p-4 rounded-lg cursor-pointer hover:opacity-90 transition-opacity" 
                         style="background-color: #161b22; border: 1px solid #30363d;"
                         onclick="event.stopPropagation(); (function() { const pollId = '${activity.marketId}'; const dashboard = document.getElementById('userDashboard'); if(dashboard) dashboard.style.display = 'none'; if(typeof openPollDetail === 'function') { openPollDetail(pollId); } else if(typeof window.openPollDetail === 'function') { window.openPollDetail(pollId); } })();">
                        <div class="flex items-start gap-3">
                            <div class="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-lg" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2) 0%, rgba(147, 51, 234, 0.1) 100%);">
                                ${activity.emoji}
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-sm text-white mb-1">
                                    <span style="color: ${activityColor};">${activityIcon}</span>
                                    <span class="ml-1">${activityText}</span>
                                </p>
                                <p class="text-xs" style="color: #6b7280;">${timeAgo}</p>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Helper function to get time ago string
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now.getTime() - date.getTime();
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) {
                return 'Just now';
            } else if (diffMins < 60) {
                return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
            } else if (diffHours < 24) {
                return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
            } else if (diffDays < 7) {
                return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
            } else {
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined });
            }
        }
        
        // Render markets in dashboard
        function renderDashboardMarkets(userMarkets) {
            const container = document.getElementById('dashboardMyMarkets');
            if (!container) return;
            
            if (userMarkets.length === 0) {
                container.innerHTML = `
                    <div class="p-6 rounded-xl text-center" style="background-color: #161b22; border: 1px solid #30363d;">
                        <p class="text-[#8b949e] mb-4">You haven't created any markets yet.</p>
                        <button onclick="closeDashboard(); document.getElementById('createMarketBtn').click();" class="px-4 py-2 rounded-lg text-white font-medium hover:opacity-90 transition-opacity" style="background-color: #9333ea;">
                            Create Your First Market
                        </button>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = userMarkets.map(market => {
                const emoji = (market.category && categoryEmojis[market.category]) || market.emoji || 'üìä';
                const volume = parseFloat(market.volume) || 0;
                const volumeDisplay = volume >= 1000 ? `$${(volume / 1000).toFixed(1)}k` : `$${volume.toFixed(0)}`;
                
                return `
                    <div class="p-4 rounded-xl cursor-pointer hover:opacity-90 transition-opacity" style="background-color: #161b22; border: 1px solid #30363d;" onclick="openPollDetail('${market.id}'); closeDashboard();">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-3 flex-1">
                                <span class="text-2xl" style="display: inline-block;">${emoji}</span>
                                <div class="flex-1">
                                    <h4 class="text-white font-medium mb-1">${market.title}</h4>
                                    <p class="text-sm text-[#8b949e]">${volumeDisplay} Vol.</p>
                                </div>
                            </div>
                            <svg class="w-5 h-5 text-[#8b949e]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                            </svg>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update login button UI
        function updateLoginButton(provider, identifier, isLoggedIn) {
            const sidebarUserInfo = document.getElementById('sidebarUserInfo');
            const sidebarUserName = document.getElementById('sidebarUserName');
            const sidebarUserInitial = document.getElementById('sidebarUserInitial');
            const sidebarUserAddressText = document.getElementById('sidebarUserAddress');
            
            if (menuLoginBtn) {
                if (isLoggedIn) {
                    // Change button to Log Out
                    menuLoginBtn.innerHTML = `
                        <span class="flex items-center justify-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                            </svg>
                            Log Out
                        </span>
                    `;
                    menuLoginBtn.style.backgroundColor = '#dc2626'; // Red for logout
                    menuLoginBtn.setAttribute('data-logged-in', 'true');
                    
                    // Show user info in sidebar
                    if (sidebarUserInfo) {
                        sidebarUserInfo.classList.remove('hidden');
                        sidebarUserInfo.classList.add('block');
                    }
                    
                    // Update user info
                    if (provider === 'wallet' && identifier) {
                        // Get wallet info from localStorage
                        const loginData = localStorage.getItem('userLogin');
                        if (loginData) {
                            try {
                                const data = JSON.parse(loginData);
                                const walletInfo = data.walletInfo || {};
                                
                                if (sidebarUserName) {
                                    sidebarUserName.textContent = walletInfo.walletName || 'Wallet User';
                                }
                                
                                if (sidebarUserAddressText) {
                                    const shortAddress = identifier.length > 10 
                                        ? `${identifier.substring(0, 6)}...${identifier.substring(identifier.length - 4)}`
                                        : identifier;
                                    sidebarUserAddressText.textContent = shortAddress;
                                }
                                
                                if (sidebarUserInitial) {
                                    sidebarUserInitial.textContent = identifier.substring(2, 3).toUpperCase();
                                }
                            } catch (e) {
                                console.error('Error parsing login data:', e);
                            }
                        }
                    } else {
                        // Google/Apple login
                        if (sidebarUserName) {
                            sidebarUserName.textContent = provider === 'google' ? 'Google User' : provider === 'apple' ? 'Apple User' : 'User';
                        }
                        
                        if (sidebarUserAddressText) {
                            sidebarUserAddressText.textContent = identifier || '';
                        }
                        
                        if (sidebarUserInitial) {
                            sidebarUserInitial.textContent = (identifier || 'U').substring(0, 1).toUpperCase();
                        }
                    }
                } else {
                    // Not logged in
                    menuLoginBtn.innerHTML = `
                        <span class="flex items-center justify-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"></path>
                            </svg>
                            Log In
                        </span>
                    `;
                    menuLoginBtn.style.backgroundColor = '#9333ea'; // Purple for login
                    menuLoginBtn.removeAttribute('data-logged-in');
                    
                    // Hide user info in sidebar
                    if (sidebarUserInfo) {
                        sidebarUserInfo.classList.add('hidden');
                        sidebarUserInfo.classList.remove('block');
                    }
                }
            }
        }
        
        // Handle logout
        function handleLogout() {
            localStorage.removeItem('userLogin');
            updateLoginButton(null, null, false);
            
            // Close dashboard if open
            closeDashboard();
            
            // If wallet was connected, disconnect
            if (window.ethereum && window.ethereum.removeListener) {
                // Note: MetaMask doesn't have a disconnect method, but we clear local state
                console.log('Logged out from wallet');
            }
        }
        
        // Update login button click handler to support logout
        // We'll handle this in the existing click handler by checking login state
        
        // Check if user is already logged in on page load
        async function checkExistingLogin() {
            const loginData = localStorage.getItem('userLogin');
            if (loginData) {
                try {
                    const data = JSON.parse(loginData);
                    updateLoginButton(data.provider, data.identifier, true);
                    
                    // If wallet login, verify connection is still active
                    if (data.provider === 'wallet' && typeof window.ethereum !== 'undefined') {
                        try {
                            const accounts = await window.ethereum.request({
                                method: 'eth_accounts'
                            });
                            
                            if (accounts.length > 0 && accounts[0].toLowerCase() === data.identifier.toLowerCase()) {
                                // Still connected, check if on Base
                                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                                // Normalize chain ID for comparison
                                let normalizedChainId = chainId;
                                if (typeof chainId === 'string') {
                                    normalizedChainId = chainId.startsWith('0x') ? parseInt(chainId, 16) : parseInt(chainId, 10);
                                }
                                const isBase = normalizedChainId === BASE_SEPOLIA_CHAIN_ID || normalizedChainId === BASE_MAINNET_CHAIN_ID;
                                
                                // Update wallet info
                                const walletInfo = {
                                    address: accounts[0],
                                    chainId: chainId,
                                    isBase: isBase
                                };
                                
                                // Update stored login data
                                data.walletInfo = walletInfo;
                                localStorage.setItem('userLogin', JSON.stringify(data));
                            } else {
                                // Account changed or disconnected
                                handleLogout();
                            }
                        } catch (error) {
                            console.error('Error checking wallet connection:', error);
                        }
                    }
                } catch (e) {
                    console.error('Error parsing login data:', e);
                }
            }
        }
        
        // Check login status on page load
        checkExistingLogin();
        
        // Note: QRCode library is now loaded via CDN in the head
        // The WalletConnect SDK handles the connection logic
        
        // Create Market Modal functionality
        const createMarketBtn = document.getElementById('createMarketBtn');
        const createMarketModal = document.getElementById('createMarketModal');
        
        if (!createMarketBtn) {
            console.error('createMarketBtn not found!');
        }
        if (!createMarketModal) {
            console.error('createMarketModal not found!');
        }
        
        // Function to open create market modal
        function openCreateMarketModal() {
            console.log('openCreateMarketModal called');
            if (!createMarketModal) {
                console.error('Create market modal not found');
                alert('Create market modal not found. Please refresh the page.');
                return;
            }
            
            // Hide other pages/modals
            const howItWorksPage = document.getElementById('howItWorksPage');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const userDashboard = document.getElementById('userDashboard');
            
            if (howItWorksPage) howItWorksPage.style.display = 'none';
            if (pollDetailPage) pollDetailPage.style.display = 'none';
            if (userDashboard) userDashboard.style.display = 'none';
            
            // Show modal
            createMarketModal.classList.remove('hidden');
            createMarketModal.style.display = 'flex';
            createMarketModal.style.visibility = 'visible';
            createMarketModal.style.opacity = '1';
            createMarketModal.style.zIndex = '1000';
            
            // Reset form and show first step
            if (typeof resetResolutionCriteria === 'function') {
                resetResolutionCriteria();
            }
            // Ensure step1 is visible
            const step1 = document.getElementById('step1');
            if (step1) {
                step1.classList.remove('hidden');
                step1.style.display = 'block';
            }
            // Hide step2 if it exists
            const step2 = document.getElementById('step2');
            if (step2) {
                step2.classList.add('hidden');
            }
            if (typeof showStep === 'function') {
                showStep(1);
            }
            
            // Setup date/time picker listeners when modal opens
            setTimeout(() => {
                if (typeof setupDateTimePickerListeners === 'function') {
                    setupDateTimePickerListeners();
                }
            }, 100);
        }
        
        // Setup date/time picker event listeners when modal opens
        function setupDateTimePickerListeners() {
            const endTimeInput = document.getElementById('endTime');
            const endTimeDisplay = document.getElementById('endTimeDisplay');
            const endTimeDisplayValue = document.getElementById('endTimeDisplayValue');
            const calendarIconWrapper = document.getElementById('calendarIconWrapper');
            const endTimePlaceholder = document.getElementById('endTimePlaceholder');
            
            // Hide/show placeholder based on input value
            function updatePlaceholder() {
                if (endTimePlaceholder) {
                    if (endTimeInput.value) {
                        endTimePlaceholder.style.opacity = '0';
                        endTimePlaceholder.style.pointerEvents = 'none';
                    } else {
                        endTimePlaceholder.style.opacity = '1';
                        endTimePlaceholder.style.pointerEvents = 'none';
                    }
                }
            }
            
            if (endTimeInput) {
                // Initial placeholder state
                updatePlaceholder();
                
                // Animate calendar icon on hover
                endTimeInput.addEventListener('mouseenter', function() {
                    if (calendarIconWrapper) {
                        calendarIconWrapper.style.transform = 'translateY(-50%) scale(1.1)';
                    }
                });
                endTimeInput.addEventListener('mouseleave', function() {
                    if (calendarIconWrapper) {
                        calendarIconWrapper.style.transform = 'translateY(-50%) scale(1)';
                    }
                });
                
                // Update placeholder visibility
                endTimeInput.addEventListener('focus', function() {
                    if (endTimePlaceholder) {
                        endTimePlaceholder.style.opacity = '0';
                    }
                });
                endTimeInput.addEventListener('blur', updatePlaceholder);
                endTimeInput.addEventListener('input', updatePlaceholder);
                endTimeInput.addEventListener('change', updatePlaceholder);
                
                // Update display when date is selected
                endTimeInput.addEventListener('change', function() {
                    if (this.value) {
                        const date = new Date(this.value);
                        if (!isNaN(date.getTime())) {
                            // Format date nicely
                            const formattedDate = date.toLocaleDateString('en-US', {
                                weekday: 'long',
                                month: 'long',
                                day: 'numeric',
                                year: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: true
                            });
                            
                            // Calculate time until end date
                            const now = new Date();
                            const timeDiff = date - now;
                            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                            const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                            
                            let timeUntilText = '';
                            if (days > 0) {
                                timeUntilText = `${days} day${days !== 1 ? 's' : ''} and ${hours} hour${hours !== 1 ? 's' : ''}`;
                            } else if (hours > 0) {
                                timeUntilText = `${hours} hour${hours !== 1 ? 's' : ''}`;
                } else {
                                const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                                timeUntilText = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
                            }
                            
                            if (endTimeDisplayValue) {
                                endTimeDisplayValue.innerHTML = `
                                    <div class="text-white font-medium">${formattedDate}</div>
                                    <div class="text-xs mt-1 flex items-center gap-1" style="color: #8b949e;">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                        Poll closes in ${timeUntilText}
                                    </div>
                                `;
                            }
                            if (endTimeDisplay) {
                                endTimeDisplay.classList.remove('hidden');
                                endTimeDisplay.classList.add('flex');
                                // Add a subtle animation
                                endTimeDisplay.style.opacity = '0';
                                endTimeDisplay.style.transform = 'translateY(-5px)';
                                setTimeout(() => {
                                    endTimeDisplay.style.transition = 'all 0.3s ease-out';
                                    endTimeDisplay.style.opacity = '1';
                                    endTimeDisplay.style.transform = 'translateY(0)';
                                }, 10);
                            }
                            
                            // Update input border color to green to indicate success
                            this.style.borderColor = '#10b981';
                            if (calendarIconWrapper) {
                                calendarIconWrapper.querySelector('svg').style.color = '#10b981';
                            }
                            setTimeout(() => {
                                this.style.borderColor = '#30363d';
                                if (calendarIconWrapper) {
                                    calendarIconWrapper.querySelector('svg').style.color = '#9333ea';
                                }
                            }, 2000);
                        }
            } else {
                        if (endTimeDisplay) {
                            endTimeDisplay.classList.add('hidden');
                            endTimeDisplay.classList.remove('flex');
                        }
                    }
                });
                
                // Add input event for real-time feedback
                endTimeInput.addEventListener('input', function() {
                    if (this.value) {
                        this.style.borderColor = '#9333ea';
                        if (calendarIconWrapper) {
                            calendarIconWrapper.querySelector('svg').style.color = '#9333ea';
                        }
                    }
                });
            }
        }
        const closeCreateModal = document.getElementById('closeCreateModal');
        const visibilityType = document.getElementById('visibilityType');
        const visibilityDesc = document.getElementById('visibilityDesc');

        if (createMarketBtn) {
            // Remove old listeners by cloning
            const newBtn = createMarketBtn.cloneNode(true);
            createMarketBtn.parentNode.replaceChild(newBtn, createMarketBtn);
            
            // Get the new button reference
            const btn = document.getElementById('createMarketBtn');
            if (btn) {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Create Market button clicked');
                    openCreateMarketModal();
                });
            }
        } else {
            console.error('createMarketBtn element not found when setting up listener');
        }
        
        // Initialize validation on page load
        setupResolutionCriteriaValidation();

        if (closeCreateModal) {
            closeCreateModal.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Close create modal clicked');
                createMarketModal.classList.add('hidden');
                createMarketModal.style.display = 'none';
                // Reset form
                const form = document.getElementById('createMarketForm');
                if (form) {
                    form.reset();
                }
                // Reset to step 1
                if (typeof showStep === 'function') {
                    showStep(1);
                }
            });
        }
        
        // Ensure Create Market submit button is clickable
        const createMarketSubmitBtn = document.getElementById('createMarketSubmitBtn');
        if (createMarketSubmitBtn) {
            createMarketSubmitBtn.addEventListener('click', function(e) {
                console.log('Create Market submit button clicked directly');
                // Don't prevent default - let form submit naturally
            });
        }
        
        // Also add click handler via event delegation for dynamically rendered buttons
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'createMarketSubmitBtn') {
                console.log('Create Market button clicked via delegation');
            }
        });
        
        // Invite Link Modal functionality
        function showInviteLinkModal(inviteLink, marketTitle) {
            const modal = document.getElementById('inviteLinkModal');
            const input = document.getElementById('inviteLinkInput');
            const title = document.getElementById('inviteMarketTitle');
            
            if (modal && input && title) {
                input.value = inviteLink;
                title.textContent = `"${marketTitle}" - Share this link to invite participants:`;
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                
                // Focus and select the input text
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 100);
            }
        }
        
        function closeInviteLinkModal() {
            const modal = document.getElementById('inviteLinkModal');
            if (modal) {
                modal.classList.add('hidden');
                modal.style.display = 'none';
            }
        }
        
        // Copy invite link functionality
        const copyInviteLinkBtn = document.getElementById('copyInviteLink');
        const closeInviteModalBtn = document.getElementById('closeInviteModalBtn');
        const closeInviteModal = document.getElementById('closeInviteModal');
        
        if (copyInviteLinkBtn) {
            copyInviteLinkBtn.addEventListener('click', () => {
                const input = document.getElementById('inviteLinkInput');
                if (input) {
                    input.select();
                    input.setSelectionRange(0, 99999); // For mobile devices
                    try {
                        document.execCommand('copy');
                        copyInviteLinkBtn.textContent = 'Copied!';
                        copyInviteLinkBtn.style.backgroundColor = '#10b981';
                        setTimeout(() => {
                            copyInviteLinkBtn.textContent = 'Copy';
                            copyInviteLinkBtn.style.backgroundColor = '#9333ea';
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                        alert('Failed to copy link. Please copy it manually.');
                    }
                }
            });
        }
        
        if (closeInviteModalBtn) {
            closeInviteModalBtn.addEventListener('click', closeInviteLinkModal);
        }
        
        if (closeInviteModal) {
            closeInviteModal.addEventListener('click', closeInviteLinkModal);
        }
        
        // Close modal when clicking outside
        const inviteLinkModal = document.getElementById('inviteLinkModal');
        if (inviteLinkModal) {
            inviteLinkModal.addEventListener('click', (e) => {
                if (e.target === inviteLinkModal) {
                    closeInviteLinkModal();
                }
            });
        }

        // Custom Date/Time Picker functionality
        let selectedDate = null;
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();
        let selectedDay = null;
        let selectedHour = 12;
        let selectedMinute = 0;
        let selectedAMPM = 'PM';

        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

        function openDateTimePicker() {
            console.log('openDateTimePicker called');
            const modal = document.getElementById('dateTimePickerModal');
            console.log('Modal element:', modal);
            console.log('Modal background color:', modal ? window.getComputedStyle(modal).backgroundColor : 'N/A');
            if (modal) {
                // Remove hidden class first (if it exists)
                modal.classList.remove('hidden');
                
                // Remove any inline display styles that might conflict
                modal.style.removeProperty('display');
                
                // Use setProperty with !important to override any CSS
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.setProperty('z-index', '10000', 'important');
                modal.style.setProperty('position', 'fixed', 'important');
                modal.style.setProperty('top', '0', 'important');
                modal.style.setProperty('left', '0', 'important');
                modal.style.setProperty('right', '0', 'important');
                modal.style.setProperty('bottom', '0', 'important');
                modal.style.setProperty('width', '100%', 'important');
                modal.style.setProperty('height', '100%', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '0', 'important');
                modal.style.setProperty('background-color', 'rgba(0, 0, 0, 0.75)', 'important');
                modal.style.setProperty('backdrop-filter', 'blur(4px)', 'important');
                modal.style.setProperty('align-items', 'center', 'important');
                modal.style.setProperty('justify-content', 'center', 'important');
                
                // Force dark background on modal content and all children
                const modalContent = modal.querySelector('div');
                if (modalContent) {
                    modalContent.style.setProperty('background', 'linear-gradient(135deg, #161b22 0%, #0d1117 100%)', 'important');
                    modalContent.style.setProperty('color', 'white', 'important');
                    
                    // Force dark backgrounds on all child elements
                    const allElements = modalContent.querySelectorAll('*');
                    allElements.forEach(el => {
                        if (el.tagName === 'SELECT' || el.tagName === 'INPUT') {
                            el.style.setProperty('background-color', el.tagName === 'SELECT' ? '#161b22' : '#0d1117', 'important');
                            el.style.setProperty('color', 'white', 'important');
                            el.style.setProperty('border-color', '#30363d', 'important');
                        }
                        // Force white text on all text elements
                        if (['H3', 'P', 'LABEL', 'SPAN', 'BUTTON'].includes(el.tagName)) {
                            if (!el.style.backgroundColor || el.style.backgroundColor === 'transparent' || el.style.backgroundColor === 'rgba(0, 0, 0, 0)') {
                                el.style.setProperty('color', 'white', 'important');
                            }
                        }
                    });
                }
                
                document.body.style.overflow = 'hidden';
                
                // Animate fade in
                setTimeout(() => {
                    modal.style.transition = 'opacity 0.3s ease-out';
                    modal.style.setProperty('opacity', '1', 'important');
                }, 10);
                
                // Force a reflow to ensure styles are applied
                void modal.offsetHeight;
                
                console.log('Modal styles applied. Display:', window.getComputedStyle(modal).display);
                console.log('Modal visibility:', window.getComputedStyle(modal).visibility);
                console.log('Modal opacity:', window.getComputedStyle(modal).opacity);
                console.log('Modal z-index:', window.getComputedStyle(modal).zIndex);
                
                // Initialize if not already set
                if (!selectedDate) {
                    selectedDate = new Date();
                    selectedDay = selectedDate.getDate();
                    currentMonth = selectedDate.getMonth();
                    currentYear = selectedDate.getFullYear();
                    selectedHour = selectedDate.getHours() % 12 || 12;
                    selectedMinute = selectedDate.getMinutes();
                    selectedAMPM = selectedDate.getHours() >= 12 ? 'PM' : 'AM';
                }
                
                try {
                    // Wait a moment for modal to be fully rendered
                    setTimeout(() => {
                        try {
                            populateMonthYearDropdowns();
                            updateCalendar();
                            updateTimeInputs();
                            setAMPM(selectedAMPM);
                            console.log('Calendar initialized successfully');
                            
                            // Verify elements exist
                            const calendarGrid = document.getElementById('calendarGrid');
                            const monthSelect = document.getElementById('monthSelect');
                            const yearSelect = document.getElementById('yearSelect');
                            console.log('Calendar elements check:', {
                                calendarGrid: !!calendarGrid,
                                monthSelect: !!monthSelect,
                                yearSelect: !!yearSelect
                            });
                        } catch (error) {
                            console.error('Error initializing calendar:', error);
                            console.error('Error stack:', error.stack);
                        }
                    }, 100);
                } catch (error) {
                    console.error('Error in calendar initialization wrapper:', error);
                }
            } else {
                console.error('Modal element not found!');
            }
        }

        function closeDateTimePicker() {
            const modal = document.getElementById('dateTimePickerModal');
            if (modal) {
                modal.classList.add('hidden');
                modal.style.setProperty('display', 'none', 'important');
                document.body.style.overflow = 'auto';
            }
        }

        function populateMonthYearDropdowns() {
            const monthSelect = document.getElementById('monthSelect');
            const yearSelect = document.getElementById('yearSelect');
            
            if (monthSelect) {
                monthSelect.innerHTML = months.map((month, idx) => 
                    `<option value="${idx}" ${idx === currentMonth ? 'selected' : ''}>${month}</option>`
                ).join('');
            }
            
            if (yearSelect) {
                const currentYearNum = new Date().getFullYear();
                yearSelect.innerHTML = '';
                for (let year = currentYearNum; year <= currentYearNum + 10; year++) {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    if (year === currentYear) option.selected = true;
                    yearSelect.appendChild(option);
                }
            }
        }

        function changeMonth(direction) {
            currentMonth += direction;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            } else if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            document.getElementById('monthSelect').value = currentMonth;
            document.getElementById('yearSelect').value = currentYear;
            updateCalendar();
        }

        function updateCalendar() {
            const monthSelect = document.getElementById('monthSelect');
            const yearSelect = document.getElementById('yearSelect');
            if (monthSelect) currentMonth = parseInt(monthSelect.value);
            if (yearSelect) currentYear = parseInt(yearSelect.value);

            const calendarGrid = document.getElementById('calendarGrid');
            if (!calendarGrid) return;

            const firstDay = new Date(currentYear, currentMonth, 1).getDay();
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            const daysInPrevMonth = new Date(currentYear, currentMonth, 0).getDate();
            
            const today = new Date();
            const isTodayMonth = today.getMonth() === currentMonth && today.getFullYear() === currentYear;

            let html = '';
            
            // Previous month days
            for (let i = firstDay - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                html += `<div class="text-center py-3 text-sm rounded-xl cursor-not-allowed opacity-30" style="color: #484f58;">${day}</div>`;
            }
            
            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                const isSelected = selectedDay === day && selectedDate && 
                                 selectedDate.getMonth() === currentMonth && 
                                 selectedDate.getFullYear() === currentYear;
                const isToday = isTodayMonth && day === today.getDate();
                const isPast = new Date(currentYear, currentMonth, day) < new Date().setHours(0, 0, 0, 0);
                
                let classes = 'text-center py-3 text-sm rounded-xl cursor-pointer transition-all duration-200 font-semibold relative';
                let styles = '';
                
                if (isSelected) {
                    styles = 'background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%); color: white; border: 2px solid #a855f7; box-shadow: 0 4px 6px -1px rgba(147, 51, 234, 0.4); transform: scale(1.05);';
                } else if (isToday) {
                    styles = 'background-color: #0d1117; color: white; border: 2px solid #10b981; box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.3);';
                } else if (isPast) {
                    styles = 'color: #484f58; cursor: not-allowed; opacity: 40%;';
                    classes += ' hover:bg-transparent';
                } else {
                    styles = 'color: white; border: 2px solid transparent;';
                    classes += ' hover:bg-gray-800 hover:border-purple-500/30';
                }
                
                html += `<div class="${classes}" style="${styles}" ${!isPast ? `onclick="if(typeof window.selectDay === 'function') { window.selectDay(${day}); }"` : ''}>${day}</div>`;
            }
            
            // Next month days
            const totalCells = 42; // 6 weeks * 7 days
            const remainingCells = totalCells - (firstDay + daysInMonth);
            for (let day = 1; day <= remainingCells; day++) {
                html += `<div class="text-center py-3 text-sm rounded-xl cursor-not-allowed opacity-30" style="color: #484f58;">${day}</div>`;
            }
            
            calendarGrid.innerHTML = html;
        }

        function selectDay(day) {
            selectedDay = day;
            if (!selectedDate) selectedDate = new Date();
            selectedDate.setFullYear(currentYear, currentMonth, day);
            updateCalendar();
        }

        function setToday() {
            const today = new Date();
            selectedDate = new Date(today);
            selectedDay = today.getDate();
            currentMonth = today.getMonth();
            currentYear = today.getFullYear();
            selectedHour = today.getHours() % 12 || 12;
            selectedMinute = today.getMinutes();
            selectedAMPM = today.getHours() >= 12 ? 'PM' : 'AM';
            
            populateMonthYearDropdowns();
            updateCalendar();
            updateTimeInputs();
            setAMPM(selectedAMPM);
        }

        function clearDateTime() {
            const endTimeInput = document.getElementById('endTime');
            const endTimeDisplay = document.getElementById('endTimeDisplay');
            
            if (endTimeInput) endTimeInput.value = '';
            if (endTimeDisplay) {
                endTimeDisplay.classList.add('hidden');
                endTimeDisplay.classList.remove('flex');
            }
        }

        function updateTimeInputs() {
            const hourInput = document.getElementById('timeHour');
            const minuteInput = document.getElementById('timeMinute');
            
            if (hourInput) hourInput.value = selectedHour;
            if (minuteInput) minuteInput.value = selectedMinute.toString().padStart(2, '0');
        }

        function updateTimeDisplay() {
            const hourInput = document.getElementById('timeHour');
            const minuteInput = document.getElementById('timeMinute');
            
            if (hourInput) selectedHour = parseInt(hourInput.value) || 12;
            if (minuteInput) selectedMinute = parseInt(minuteInput.value) || 0;
            
            // Validate
            if (selectedHour < 1) selectedHour = 1;
            if (selectedHour > 12) selectedHour = 12;
            if (selectedMinute < 0) selectedMinute = 0;
            if (selectedMinute > 59) selectedMinute = 59;
            
            if (hourInput) hourInput.value = selectedHour;
            if (minuteInput) minuteInput.value = selectedMinute.toString().padStart(2, '0');
        }

        function setAMPM(ampm) {
            selectedAMPM = ampm;
            const amBtn = document.getElementById('timeAM');
            const pmBtn = document.getElementById('timePM');
            
            if (ampm === 'AM') {
                if (amBtn) {
                    amBtn.style.backgroundColor = '#9333ea';
                    amBtn.style.color = 'white';
                    amBtn.style.border = 'none';
                }
                if (pmBtn) {
                    pmBtn.style.backgroundColor = '#0d1117';
                    pmBtn.style.border = '1px solid #30363d';
                    pmBtn.style.color = '#8b949e';
                }
            } else {
                if (pmBtn) {
                    pmBtn.style.backgroundColor = '#9333ea';
                    pmBtn.style.color = 'white';
                    pmBtn.style.border = 'none';
                }
                if (amBtn) {
                    amBtn.style.backgroundColor = '#0d1117';
                    amBtn.style.border = '1px solid #30363d';
                    amBtn.style.color = '#8b949e';
                }
            }
        }

        function confirmDateTime() {
            if (!selectedDate || !selectedDay) {
                alert('Please select a date');
                return;
            }

            const hour24 = selectedAMPM === 'PM' && selectedHour !== 12 
                ? selectedHour + 12 
                : selectedAMPM === 'AM' && selectedHour === 12 
                ? 0 
                : selectedHour;

            selectedDate.setHours(hour24, selectedMinute, 0, 0);

            // Check if date is in the past
            if (selectedDate < new Date()) {
                alert('Please select a future date and time');
                return;
            }

            const endTimeInput = document.getElementById('endTime');
            const endTimeValue = document.getElementById('endTimeValue');
            const endTimeDisplay = document.getElementById('endTimeDisplay');
            const endTimeDisplayValue = document.getElementById('endTimeDisplayValue');
            const endTimeContainer = document.getElementById('endTimeContainer');
            const calendarIcon = document.getElementById('calendarIcon');
            
            // Event listeners are set up in setupDateTimePickerListeners() function
            // No need to duplicate here

            const formattedDate = selectedDate.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            const isoString = selectedDate.toISOString().slice(0, 16);

            if (endTimeInput) {
                endTimeInput.value = formattedDate;
            }
            
            if (endTimeContainer) {
                endTimeContainer.style.borderColor = '#10b981';
                setTimeout(() => {
                    endTimeContainer.style.borderColor = '#30363d';
                }, 1500);
            }
            
            if (endTimeValue) endTimeValue.value = isoString;
            if (endTimeDisplayValue) endTimeDisplayValue.textContent = formattedDate;
            
            if (endTimeDisplay) {
                endTimeDisplay.classList.remove('hidden');
                endTimeDisplay.classList.add('flex');
            }

            closeDateTimePicker();
        }

        // Close modal when clicking outside
        document.getElementById('dateTimePickerModal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeDateTimePicker();
            }
        });

        // Close modal when clicking outside
        createMarketModal.addEventListener('click', (e) => {
            if (e.target === createMarketModal) {
                createMarketModal.classList.add('hidden');
            }
        });

        // Step navigation
        function showStep(step) {
            // Hide all steps
            const step1 = document.getElementById('step1');
            const step2 = document.getElementById('step2');
            
            if (step1) step1.classList.add('hidden');
            if (step2) step2.classList.add('hidden');
            
            // Show the requested step
            if (step === 1 && step1) {
                step1.classList.remove('hidden');
            } else if (step === 2 && step2) {
                step2.classList.remove('hidden');
            }
        }
        
        // Show confirmation modal popup
        function showConfirmationModal() {
            console.log('showConfirmationModal called');
            
            // Validate form first
            if (!validateResolutionCriteria()) {
                return;
            }
            
            // Get form values
            const category = document.getElementById('marketCategory').value;
            const title = document.getElementById('marketTitle').value;
            const description = document.getElementById('marketDescription').value;
            const endTimeInput = document.getElementById('endTime');
            const endTimeRaw = endTimeInput ? endTimeInput.value : '';
            
            // Get resolution criteria
            const resolutionInputs = document.querySelectorAll('.resolution-criteria-input');
            const resolutionCriteria = Array.from(resolutionInputs)
                .map(input => input.value.trim())
                .filter(value => value.length > 0);
            
            // Validate required fields
            if (!category || !title || !endTimeRaw || resolutionCriteria.length < 2) {
                alert('Please fill in all required fields.');
                return;
            }
            
            // Format end time
            let endTimeDisplay = endTimeRaw;
            try {
                if (endTimeRaw.includes('T')) {
                    const date = new Date(endTimeRaw);
                    if (!isNaN(date.getTime())) {
                        endTimeDisplay = date.toLocaleString('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: true
                        });
                    }
                }
            } catch (e) {
                console.warn('Could not format end time:', e);
            }
            
            // Get category display name
            const categoryNames = {
                'other': 'üëø Others',
                'gaming': 'üéÆ Gaming',
                'wellness': 'üí™ Fitness',
                'socials': 'üéâ Socials',
                'foodies': 'üçî Foodies',
                'office': 'üíº Office',
                'entertainment': 'üé¨ Entertainment',
                'sports': '‚öΩ Sports',
                'education': 'üìö Education'
            };
            
            // Populate confirmation fields
            const confirmCategory = document.getElementById('confirmCategory');
            const confirmTitle = document.getElementById('confirmTitle');
            const confirmDescription = document.getElementById('confirmDescription');
            const confirmEndTime = document.getElementById('confirmEndTime');
            const confirmOutcomes = document.getElementById('confirmOutcomes');
            
            if (confirmCategory) confirmCategory.textContent = categoryNames[category] || category;
            if (confirmTitle) confirmTitle.textContent = title;
            if (confirmDescription) confirmDescription.textContent = description || '(No description)';
            if (confirmEndTime) confirmEndTime.textContent = endTimeDisplay;
            
            // Populate outcomes list
            if (confirmOutcomes) {
                confirmOutcomes.innerHTML = resolutionCriteria.map(outcome => 
                    `<li>${outcome}</li>`
                ).join('');
            }
            
            // Show confirmation modal
            const confirmationModal = document.getElementById('confirmationModal');
            if (confirmationModal) {
                confirmationModal.classList.remove('hidden');
                confirmationModal.style.display = 'flex';
            }
        }
        
        // Close confirmation modal
        function closeConfirmationModal() {
            const confirmationModal = document.getElementById('confirmationModal');
            if (confirmationModal) {
                confirmationModal.classList.add('hidden');
                confirmationModal.style.display = 'none';
            }
        }
        
        // Execute onchain market creation
        async function executeOnchainMarketCreation() {
            console.log('executeOnchainMarketCreation called');
            
            const confirmBtn = document.getElementById('confirmCreateMarketBtn');
            if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.textContent = 'Processing...';
            }
            
            try {
                // Check if wallet is connected
                if (!window.ethereum) {
                    alert('Please install MetaMask or connect a wallet to create a market onchain.');
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'Confirm & Create on Chain';
                    }
                    return;
                }
                
                // Request account access
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    alert('Please connect your wallet to create a market.');
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'Confirm & Create on Chain';
                    }
                    return;
                }
                
                // Get form values
                const category = document.getElementById('marketCategory').value;
                const title = document.getElementById('marketTitle').value;
                const description = document.getElementById('marketDescription').value;
                const endTimeInput = document.getElementById('endTime');
                const endTimeRaw = endTimeInput ? endTimeInput.value : '';
                
                // Get resolution criteria
                const resolutionInputs = document.querySelectorAll('.resolution-criteria-input');
                const resolutionCriteria = Array.from(resolutionInputs)
                    .map(input => input.value.trim())
                    .filter(value => value.length > 0);
                
                // Convert endTime to timestamp
                let endTimeTimestamp = 0;
                try {
                    if (endTimeRaw.includes('T')) {
                        const date = new Date(endTimeRaw);
                        if (!isNaN(date.getTime())) {
                            endTimeTimestamp = Math.floor(date.getTime() / 1000);
                        }
                    }
                } catch (e) {
                    console.error('Error parsing end time:', e);
                    alert('Invalid end time. Please check your date selection.');
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'Confirm & Create on Chain';
                    }
                    return;
                }
                
                // For now, submit the form normally (local storage)
                // In a full implementation, this would call a smart contract
                const form = document.getElementById('createMarketForm');
                if (form) {
                    // Trigger form submission
                    form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
                }
                
                // Close confirmation modal
                closeConfirmationModal();
                
                // Close create market modal
                if (createMarketModal) {
                    createMarketModal.classList.add('hidden');
                    createMarketModal.style.display = 'none';
                }
                
                // Show success message
                alert('Market creation initiated! In a full implementation, this would create the market onchain via smart contract.');
                
            } catch (error) {
                console.error('Error creating market onchain:', error);
                alert('Error creating market: ' + (error.message || 'Unknown error'));
            } finally {
                if (confirmBtn) {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'Confirm & Create on Chain';
                }
            }
        }
        
        // Setup confirmation modal close handlers
        const closeConfirmationModalBtn = document.getElementById('closeConfirmationModal');
        const cancelConfirmationBtn = document.getElementById('cancelConfirmationBtn');
        const confirmationModal = document.getElementById('confirmationModal');
        
        if (closeConfirmationModalBtn) {
            closeConfirmationModalBtn.addEventListener('click', closeConfirmationModal);
        }
        
        if (cancelConfirmationBtn) {
            cancelConfirmationBtn.addEventListener('click', closeConfirmationModal);
        }
        
        // Close modal when clicking outside
        if (confirmationModal) {
            confirmationModal.addEventListener('click', (e) => {
                if (e.target === confirmationModal) {
                    closeConfirmationModal();
                }
            });
        }
        
        // Make functions globally accessible
        window.showConfirmationModal = showConfirmationModal;
        window.closeConfirmationModal = closeConfirmationModal;
        window.executeOnchainMarketCreation = executeOnchainMarketCreation;

        // Resolution criteria management
        let resolutionCriteriaCount = 2;
        const MAX_RESOLUTION_CRITERIA = 99;

        function resetResolutionCriteria() {
            const resolutionList = document.getElementById('resolutionCriteriaList');
            resolutionList.innerHTML = `
                <div class="flex gap-2">
                        <input
                            type="text"
                            required
                        class="flex-1 px-3 py-2 rounded-lg text-white resolution-criteria-input"
                        style="background-color: #0d1117; border: 1px solid #30363d;"
                        placeholder="Resolution option 1"
                        data-index="0"
                    />
                </div>
                <div class="flex gap-2">
                    <input
                        type="text"
                        required
                        class="flex-1 px-3 py-2 rounded-lg text-white resolution-criteria-input"
                        style="background-color: #0d1117; border: 1px solid #30363d;"
                        placeholder="Resolution option 2"
                        data-index="1"
                    />
                </div>
            `;
            resolutionCriteriaCount = 2;
            updateResolutionCount();
            // Re-setup validation after reset
            setupResolutionCriteriaValidation();
        }

        function addResolutionCriteria() {
            if (resolutionCriteriaCount >= MAX_RESOLUTION_CRITERIA) {
                alert(`Maximum of ${MAX_RESOLUTION_CRITERIA} resolution options allowed.`);
                return;
            }

            const resolutionList = document.getElementById('resolutionCriteriaList');
            const div = document.createElement('div');
            div.className = 'flex gap-2';
            div.innerHTML = `
                <input
                    type="text"
                    required
                    class="flex-1 px-3 py-2 rounded-lg text-white resolution-criteria-input"
                    style="background-color: #0d1117; border: 1px solid #30363d;"
                    placeholder="Resolution option ${resolutionCriteriaCount + 1}"
                    data-index="${resolutionCriteriaCount}"
                />
                <button
                    type="button"
                    onclick="removeResolutionCriteria(this)"
                    class="px-3 py-2 hover:opacity-80 rounded-lg text-red-500"
                >
                    Remove
                </button>
            `;
            resolutionList.appendChild(div);
            resolutionCriteriaCount++;
            updateResolutionCount();
            // Re-setup validation for new input
            setupResolutionCriteriaValidation();
        }

        function removeResolutionCriteria(button) {
            if (resolutionCriteriaCount <= 2) {
                alert('At least 2 resolution options are required.');
                return;
            }
            button.parentElement.remove();
            resolutionCriteriaCount--;
            updateResolutionCount();
            // Update placeholders and data-index attributes
            const inputs = document.querySelectorAll('.resolution-criteria-input');
            inputs.forEach((input, index) => {
                input.setAttribute('data-index', index);
                input.placeholder = `Resolution option ${index + 1}`;
            });
        }

        function updateResolutionCount() {
            const countDisplay = document.getElementById('resolutionCount');
            const addBtn = document.getElementById('addResolutionBtn');
            countDisplay.textContent = `${resolutionCriteriaCount} resolution option${resolutionCriteriaCount !== 1 ? 's' : ''} added`;
            
            if (resolutionCriteriaCount >= MAX_RESOLUTION_CRITERIA) {
                addBtn.disabled = true;
                addBtn.style.opacity = '0.5';
                addBtn.style.cursor = 'not-allowed';
            } else {
                addBtn.disabled = false;
                addBtn.style.opacity = '1';
                addBtn.style.cursor = 'pointer';
            }
        }
        
        // Check for duplicate resolution criteria names
        function checkForDuplicates() {
            const resolutionInputs = document.querySelectorAll('.resolution-criteria-input');
            const values = Array.from(resolutionInputs).map(input => input.value.trim().toLowerCase());
            const duplicates = new Set();
            const valueCounts = {};
            
            // Count occurrences of each value
            values.forEach((value, index) => {
                if (value.length > 0) {
                    if (!valueCounts[value]) {
                        valueCounts[value] = [];
                    }
                    valueCounts[value].push(index);
                }
            });
            
            // Find duplicates
            Object.keys(valueCounts).forEach(value => {
                if (valueCounts[value].length > 1) {
                    valueCounts[value].forEach(index => duplicates.add(index));
                }
            });
            
            // Update visual indicators
            resolutionInputs.forEach((input, index) => {
                const isDuplicate = duplicates.has(index);
                const errorMessage = input.parentElement.querySelector('.duplicate-error');
                
                if (isDuplicate) {
                    // Add red border
                    input.style.borderColor = '#ef4444';
                    input.style.borderWidth = '2px';
                    
                    // Add or update error message
                    if (!errorMessage) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'duplicate-error';
                        errorDiv.style.color = '#ef4444';
                        errorDiv.style.fontSize = '0.75rem';
                        errorDiv.style.marginTop = '0.25rem';
                        errorDiv.textContent = 'This name is duplicated';
                        input.parentElement.appendChild(errorDiv);
                    }
                } else {
                    // Remove red border
                    input.style.borderColor = '#30363d';
                    input.style.borderWidth = '1px';
                    
                    // Remove error message
                    if (errorMessage) {
                        errorMessage.remove();
                    }
                }
            });
            
            return duplicates.size > 0;
        }
        
        // Validate resolution criteria before form submission
        function validateResolutionCriteria() {
            const resolutionInputs = document.querySelectorAll('.resolution-criteria-input');
            const resolutionCriteria = Array.from(resolutionInputs)
                .map(input => input.value.trim())
                .filter(value => value.length > 0);
            
            if (resolutionCriteria.length < 2) {
                alert('Please add at least 2 resolution options.');
                return false;
            }
            
            if (checkForDuplicates()) {
                alert('Please remove duplicate resolution option names. Each option must have a unique name.');
                return false;
            }
            
            return true;
        }
        
        // Set up event listeners for duplicate checking
        function setupResolutionCriteriaValidation() {
            // Use event delegation for dynamically added inputs
            const resolutionList = document.getElementById('resolutionCriteriaList');
            if (resolutionList) {
                resolutionList.addEventListener('input', (e) => {
                    if (e.target.classList.contains('resolution-criteria-input')) {
                        // Debounce the duplicate check
                        clearTimeout(e.target.validationTimeout);
                        e.target.validationTimeout = setTimeout(() => {
                            checkForDuplicates();
                        }, 300);
                    }
                });
                
                resolutionList.addEventListener('blur', (e) => {
                    if (e.target.classList.contains('resolution-criteria-input')) {
                        checkForDuplicates();
                    }
                }, true);
            }
        }

        // Category system with emojis (defined globally)
        const categoryEmojis = {
            'other': 'üëø',
            'gaming': 'üéÆ',
            'fitness': 'üí™',
            'wellness': 'üí™', // Legacy support
            'socials': 'üéâ',
            'foodies': 'üçî',
            'office': 'üíº',
            'entertainment': 'üé¨',
            'sports': '‚öΩ',
            'education': 'üìö'
        };
        
        // Visibility type description
        // Visibility step removed - all polls are public
        // visibilityType.addEventListener('change', (e) => {
        //     const descriptions = {
        //         'Public': 'Anyone can discover and participate',
        //         'Private': 'Only invited participants can access',
        //         'Group': 'Only group members can participate'
        //     };
        //     visibilityDesc.textContent = descriptions[e.target.value];
        // });

        // Markets data storage
        // Markets storage functions
        const STORAGE_KEY = 'pollit_markets';
        
        function saveMarketsToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(markets));
                console.log('‚úÖ Markets saved to localStorage');
            } catch (error) {
                console.error('Error saving markets to localStorage:', error);
            }
        }
        
        // Market data version - increment this to force refresh
        const MARKETS_VERSION = '2.1';
        const MARKETS_VERSION_KEY = 'marketsVersion';
        
        function loadMarketsFromStorage() {
            // Check if stored markets are from an old version
            const storedVersion = localStorage.getItem(MARKETS_VERSION_KEY);
            if (storedVersion !== MARKETS_VERSION) {
                // Clear old markets if version mismatch
                localStorage.removeItem(STORAGE_KEY);
                localStorage.setItem(MARKETS_VERSION_KEY, MARKETS_VERSION);
                console.log('üîÑ Markets version updated, clearing old cache');
                return null;
            }
            
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const parsedMarkets = JSON.parse(stored);
                    if (Array.isArray(parsedMarkets) && parsedMarkets.length > 0) {
                        console.log('‚úÖ Loaded', parsedMarkets.length, 'markets from localStorage');
                        return parsedMarkets;
                    }
                }
            } catch (error) {
                console.error('Error loading markets from localStorage:', error);
            }
            return null;
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const parsedMarkets = JSON.parse(stored);
                    if (Array.isArray(parsedMarkets) && parsedMarkets.length > 0) {
                        console.log('‚úÖ Loaded', parsedMarkets.length, 'markets from localStorage');
                        return parsedMarkets;
                    }
                }
            } catch (error) {
                console.error('Error loading markets from localStorage:', error);
            }
            return null;
        }
        
        // Default markets with examples for each category (Polymarket-style)
        const defaultMarkets = [
            // Others category - Silly polls that could go viral
            {
                id: 'ot1',
                category: 'other',
                title: 'Will someone propose at the Super Bowl halftime show?',
                description: 'Will there be a surprise proposal during the Super Bowl halftime performance?',
                outcomes: ['Yes', 'No'],
                volume: 125000,
                percentages: [12, 88],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'ot2',
                category: 'other',
                title: 'Will a cat interrupt a live news broadcast this week?',
                description: 'Predicting if a cat will photobomb or interrupt a live TV broadcast',
                outcomes: ['Yes', 'No'],
                volume: 89000,
                percentages: [35, 65],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 604800000).toISOString(),
                comments: []
            },
            {
                id: 'ot3',
                category: 'other',
                title: 'Will someone get stuck in a vending machine this month?',
                description: 'Will there be a viral video of someone stuck in a vending machine?',
                outcomes: ['Yes', 'No'],
                volume: 67000,
                percentages: [18, 82],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 'ot4',
                category: 'other',
                title: 'Will a pigeon photobomb a wedding proposal?',
                description: 'Will a pigeon appear in a viral wedding proposal video?',
                outcomes: ['Yes', 'No'],
                volume: 54000,
                percentages: [22, 78],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            {
                id: 'ot5',
                category: 'other',
                title: 'Will someone order pizza to a random address and it goes viral?',
                description: 'Will a wrong address pizza delivery become a viral TikTok moment?',
                outcomes: ['Yes', 'No'],
                volume: 78000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'ot6',
                category: 'other',
                title: 'Will a squirrel steal someone\'s phone and it gets filmed?',
                description: 'Will a viral video emerge of a squirrel running off with someone\'s phone?',
                outcomes: ['Yes', 'No'],
                volume: 62000,
                percentages: [32, 68],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'ot7',
                category: 'other',
                title: 'Will someone accidentally text their boss "I love you" and it goes viral?',
                description: 'Will a wrong-number "I love you" text to a boss become a viral meme?',
                outcomes: ['Yes', 'No'],
                volume: 95000,
                percentages: [25, 75],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            {
                id: 'ot8',
                category: 'other',
                title: 'Will a dog interrupt a Zoom meeting and it becomes a meme?',
                description: 'Will a dog photobombing a Zoom call reach 1M+ views?',
                outcomes: ['Yes', 'No'],
                volume: 71000,
                percentages: [48, 52],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'ot9',
                category: 'other',
                title: 'Will someone get their head stuck in a fence this month?',
                description: 'Will there be a viral video of someone stuck in a fence?',
                outcomes: ['Yes', 'No'],
                volume: 56000,
                percentages: [18, 82],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 'ot10',
                category: 'other',
                title: 'Will a weatherman get hit by a beach ball on live TV?',
                description: 'Will a beach ball interrupt a live weather broadcast?',
                outcomes: ['Yes', 'No'],
                volume: 83000,
                percentages: [22, 78],
                createdAt: new Date(Date.now() - 129600000).toISOString(),
                emoji: 'üëø',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            // Gaming category - Trending videogames
            {
                id: 'g1',
                category: 'gaming',
                title: 'Will Fortnite Chapter 5 Season 2 break player count records?',
                description: 'Will the new Fortnite season surpass previous peak player numbers?',
                outcomes: ['Yes', 'No'],
                volume: 245000,
                percentages: [68, 32],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'g2',
                category: 'gaming',
                title: 'Will Minecraft 1.21 update add the rumored new mob?',
                description: 'Will the next Minecraft update include the leaked mob feature?',
                outcomes: ['Yes', 'No'],
                volume: 189000,
                percentages: [72, 28],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            {
                id: 'g3',
                category: 'gaming',
                title: 'Will GTA 6 release date be announced before E3?',
                description: 'Will Rockstar announce GTA 6 release date before E3 2025?',
                outcomes: ['Yes', 'No'],
                volume: 320000,
                percentages: [45, 55],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'g4',
                category: 'gaming',
                title: 'Will Valorant Champions 2025 have over 1M peak viewers?',
                description: 'Will the Valorant world championship break 1 million concurrent viewers?',
                outcomes: ['Yes', 'No'],
                volume: 156000,
                percentages: [58, 42],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'g5',
                category: 'gaming',
                title: 'Will Among Us 2 be released this year?',
                description: 'Will InnerSloth release Among Us 2 in 2025?',
                outcomes: ['Yes', 'No'],
                volume: 98000,
                percentages: [25, 75],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'g6',
                category: 'gaming',
                title: 'Will Elden Ring DLC Shadow of the Erdtree win Game of the Year?',
                description: 'Will the Elden Ring expansion win GOTY at The Game Awards?',
                outcomes: ['Yes', 'No'],
                volume: 178000,
                percentages: [38, 62],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 'g7',
                category: 'gaming',
                title: 'Will Call of Duty 2025 break day-one sales records?',
                description: 'Will the next Call of Duty game set a new launch day sales record?',
                outcomes: ['Yes', 'No'],
                volume: 234000,
                percentages: [55, 45],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'g8',
                category: 'gaming',
                title: 'Will League of Legends Worlds 2025 have over 5M peak viewers?',
                description: 'Will the LoL World Championship break 5 million concurrent viewers?',
                outcomes: ['Yes', 'No'],
                volume: 198000,
                percentages: [62, 38],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'g9',
                category: 'gaming',
                title: 'Will Nintendo Switch 2 be announced before summer 2025?',
                description: 'Will Nintendo officially reveal the Switch 2 before June 2025?',
                outcomes: ['Yes', 'No'],
                volume: 287000,
                percentages: [72, 28],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'g10',
                category: 'gaming',
                title: 'Will Palworld reach 50M players in its first month?',
                description: 'Will Palworld hit 50 million players within 30 days of launch?',
                outcomes: ['Yes', 'No'],
                volume: 165000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 'g11',
                category: 'gaming',
                title: 'Will Counter-Strike 2 Major have over 2M peak viewers?',
                description: 'Will the next CS2 Major tournament break 2 million viewers?',
                outcomes: ['Yes', 'No'],
                volume: 142000,
                percentages: [45, 55],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'g12',
                category: 'gaming',
                title: 'Will a new battle royale game dethrone Fortnite this year?',
                description: 'Will any new battle royale game surpass Fortnite\'s player count?',
                outcomes: ['Yes', 'No'],
                volume: 176000,
                percentages: [18, 82],
                createdAt: new Date(Date.now() - 129600000).toISOString(),
                emoji: 'üéÆ',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            // Fitness category
            {
                id: 'w1',
                category: 'fitness',
                title: 'Will the gym be packed on New Year\'s Day?',
                description: 'Predicting if the gym will be overcrowded on January 1st (resolution day)',
                outcomes: ['Yes', 'No'],
                volume: 89000,
                percentages: [85, 15],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 'w2',
                category: 'fitness',
                title: 'Will someone break the world record for most pull-ups in 2025?',
                description: 'Will a new pull-up world record be set this year?',
                outcomes: ['Yes', 'No'],
                volume: 67000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'w3',
                category: 'fitness',
                title: 'Will Peloton stock recover above $10 this quarter?',
                description: 'Will Peloton stock price bounce back above $10?',
                outcomes: ['Yes', 'No'],
                volume: 112000,
                percentages: [42, 58],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            {
                id: 'w4',
                category: 'fitness',
                title: 'Will the CrossFit Games 2025 have over 500K live viewers?',
                description: 'Will the CrossFit championship break 500K concurrent viewers?',
                outcomes: ['Yes', 'No'],
                volume: 54000,
                percentages: [35, 65],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'w5',
                category: 'fitness',
                title: 'Will someone complete a 100-day fitness challenge and go viral?',
                description: 'Will a 100-day fitness transformation video reach 1M+ views?',
                outcomes: ['Yes', 'No'],
                volume: 78000,
                percentages: [52, 48],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 8640000000).toISOString(),
                comments: []
            },
            {
                id: 'w6',
                category: 'fitness',
                title: 'Will someone break the plank world record (over 9 hours)?',
                description: 'Will a new world record be set for longest plank hold?',
                outcomes: ['Yes', 'No'],
                volume: 92000,
                percentages: [15, 85],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'w7',
                category: 'fitness',
                title: 'Will the gym membership cancellation fee be banned?',
                description: 'Will new regulations prohibit gym cancellation fees?',
                outcomes: ['Yes', 'No'],
                volume: 134000,
                percentages: [38, 62],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'w8',
                category: 'fitness',
                title: 'Will someone deadlift 1000+ lbs in competition this year?',
                description: 'Will a powerlifter break the 1000 lb deadlift barrier?',
                outcomes: ['Yes', 'No'],
                volume: 87000,
                percentages: [22, 78],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'w9',
                category: 'fitness',
                title: 'Will a fitness influencer hit 20M followers this year?',
                description: 'Will any fitness creator reach 20 million followers?',
                outcomes: ['Yes', 'No'],
                volume: 101000,
                percentages: [42, 58],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'w10',
                category: 'fitness',
                title: 'Will the marathon world record be broken in 2025?',
                description: 'Will someone set a new world record for fastest marathon?',
                outcomes: ['Yes', 'No'],
                volume: 76000,
                percentages: [35, 65],
                createdAt: new Date(Date.now() - 129600000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'w11',
                category: 'fitness',
                title: 'Will someone complete a 24-hour gym workout challenge?',
                description: 'Will a fitness influencer complete a 24-hour continuous workout?',
                outcomes: ['Yes', 'No'],
                volume: 68000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üí™',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            // Socials category
            {
                id: 's1',
                category: 'socials',
                title: 'Will Coachella 2025 sell out in under 24 hours?',
                description: 'Will Coachella tickets sell out within 24 hours of going on sale?',
                outcomes: ['Yes', 'No'],
                volume: 145000,
                percentages: [65, 35],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üéâ',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 's2',
                category: 'socials',
                title: 'Will someone propose at a music festival this summer?',
                description: 'Will there be a viral proposal at a major music festival?',
                outcomes: ['Yes', 'No'],
                volume: 98000,
                percentages: [48, 52],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üéâ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 's3',
                category: 'socials',
                title: 'Will the New Year\'s Eve Times Square ball drop have over 1M viewers?',
                description: 'Will the Times Square New Year celebration break 1M live viewers?',
                outcomes: ['Yes', 'No'],
                volume: 112000,
                percentages: [72, 28],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üéâ',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 's4',
                category: 'socials',
                title: 'Will a flash mob proposal go viral this month?',
                description: 'Will a flash mob proposal video reach 1M+ views?',
                outcomes: ['Yes', 'No'],
                volume: 67000,
                percentages: [38, 62],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üéâ',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 's5',
                category: 'socials',
                title: 'Will Burning Man 2025 sell out faster than 2024?',
                description: 'Will Burning Man tickets sell out quicker than last year?',
                outcomes: ['Yes', 'No'],
                volume: 89000,
                percentages: [55, 45],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üéâ',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            // Foodies category
            {
                id: 'f1',
                category: 'foodies',
                title: 'Will McDonald\'s bring back the McRib permanently in 2025?',
                description: 'Will McDonald\'s make the McRib a permanent menu item?',
                outcomes: ['Yes', 'No'],
                volume: 178000,
                percentages: [22, 78],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üçî',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'f2',
                category: 'foodies',
                title: 'Will a food influencer hit 10M followers this year?',
                description: 'Will any food TikTok/Instagram creator reach 10 million followers?',
                outcomes: ['Yes', 'No'],
                volume: 134000,
                percentages: [58, 42],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üçî',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'f3',
                category: 'foodies',
                title: 'Will the viral "pasta chip" trend last more than 3 months?',
                description: 'Will the pasta chip TikTok trend survive past Q1 2025?',
                outcomes: ['Yes', 'No'],
                volume: 98000,
                percentages: [35, 65],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üçî',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            {
                id: 'f4',
                category: 'foodies',
                title: 'Will Gordon Ramsay open a new restaurant in NYC this year?',
                description: 'Will Chef Ramsay launch a new restaurant in New York City?',
                outcomes: ['Yes', 'No'],
                volume: 112000,
                percentages: [48, 52],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üçî',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'f5',
                category: 'foodies',
                title: 'Will someone break the world record for eating hot wings?',
                description: 'Will a new world record be set for eating spicy wings?',
                outcomes: ['Yes', 'No'],
                volume: 89000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üçî',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            // Office category
            {
                id: 'o1',
                category: 'office',
                title: 'Will remote work become mandatory for tech companies in 2025?',
                description: 'Will major tech companies require full remote work policies?',
                outcomes: ['Yes', 'No'],
                volume: 245000,
                percentages: [32, 68],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üíº',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'o2',
                category: 'office',
                title: 'Will the 4-day work week become standard this year?',
                description: 'Will major companies adopt a 4-day work week as standard?',
                outcomes: ['Yes', 'No'],
                volume: 189000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üíº',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'o3',
                category: 'office',
                title: 'Will AI replace 50% of office jobs by end of 2025?',
                description: 'Will AI automation eliminate half of current office positions?',
                outcomes: ['Yes', 'No'],
                volume: 320000,
                percentages: [18, 82],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üíº',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'o4',
                category: 'office',
                title: 'Will Zoom stock hit $100 per share this quarter?',
                description: 'Will Zoom stock price reach $100?',
                outcomes: ['Yes', 'No'],
                volume: 156000,
                percentages: [42, 58],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üíº',
                endTime: new Date(Date.now() + 7776000000).toISOString(),
                comments: []
            },
            {
                id: 'o5',
                category: 'office',
                title: 'Will someone accidentally send an email to the entire company?',
                description: 'Will there be a viral "reply all" email disaster this month?',
                outcomes: ['Yes', 'No'],
                volume: 98000,
                percentages: [55, 45],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üíº',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            // Entertainment category
            {
                id: 'e1',
                category: 'entertainment',
                title: '# of views of next MrBeast video on day 1?',
                description: 'How many views will the next MrBeast video get on its first day?',
                outcomes: ['25-30M', '30-35M'],
                volume: 2000000,
                percentages: [12, 88],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üé¨',
                endTime: new Date(Date.now() + 2592000000).toISOString(),
                comments: []
            },
            {
                id: 'e2',
                category: 'entertainment',
                title: 'Will Taylor Swift announce a new album before the Grammys?',
                description: 'Will Taylor Swift drop a surprise album announcement?',
                outcomes: ['Yes', 'No'],
                volume: 450000,
                percentages: [38, 62],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üé¨',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'e3',
                category: 'entertainment',
                title: 'Will the next Marvel movie break $1B at box office?',
                description: 'Will the next MCU film cross the billion dollar mark?',
                outcomes: ['Yes', 'No'],
                volume: 320000,
                percentages: [65, 35],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üé¨',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'e4',
                category: 'entertainment',
                title: 'Will Stranger Things Season 5 premiere in 2025?',
                description: 'Will the final season of Stranger Things release this year?',
                outcomes: ['Yes', 'No'],
                volume: 289000,
                percentages: [72, 28],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üé¨',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'e5',
                category: 'entertainment',
                title: 'Will a TikTok creator hit 100M followers this year?',
                description: 'Will any TikTok account reach 100 million followers?',
                outcomes: ['Yes', 'No'],
                volume: 178000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üé¨',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'e6',
                category: 'entertainment',
                title: 'Will the Oscars 2025 have over 20M viewers?',
                description: 'Will the Academy Awards break 20 million viewers?',
                outcomes: ['Yes', 'No'],
                volume: 134000,
                percentages: [45, 55],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: 'üé¨',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            // Sports category
            {
                id: 'sp1',
                category: 'sports',
                title: 'Will the Super Bowl 2025 break 120M viewers?',
                description: 'Will Super Bowl LIX surpass 120 million viewers?',
                outcomes: ['Yes', 'No'],
                volume: 890000,
                percentages: [58, 42],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: '‚öΩ',
                endTime: new Date(Date.now() + 5184000000).toISOString(),
                comments: []
            },
            {
                id: 'sp2',
                category: 'sports',
                title: 'Will LeBron James break the all-time scoring record again?',
                description: 'Will LeBron set a new NBA scoring milestone this season?',
                outcomes: ['Yes', 'No'],
                volume: 245000,
                percentages: [42, 58],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: '‚öΩ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'sp3',
                category: 'sports',
                title: 'Will Messi win the Ballon d\'Or 2025?',
                description: 'Will Lionel Messi win his 9th Ballon d\'Or award?',
                outcomes: ['Yes', 'No'],
                volume: 320000,
                percentages: [35, 65],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: '‚öΩ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'sp4',
                category: 'sports',
                title: 'Will the Olympics 2024 have over 3B total viewers?',
                description: 'Will the Paris Olympics reach 3 billion cumulative viewers?',
                outcomes: ['Yes', 'No'],
                volume: 189000,
                percentages: [68, 32],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: '‚öΩ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'sp5',
                category: 'sports',
                title: 'Will a rookie win NBA Rookie of the Year unanimously?',
                description: 'Will an NBA rookie win ROY with 100% of first-place votes?',
                outcomes: ['Yes', 'No'],
                volume: 156000,
                percentages: [25, 75],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: '‚öΩ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            {
                id: 'sp6',
                category: 'sports',
                title: 'Will the World Series go to Game 7?',
                description: 'Will the MLB World Series reach a decisive Game 7?',
                outcomes: ['Yes', 'No'],
                volume: 178000,
                percentages: [38, 62],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: '‚öΩ',
                endTime: new Date(Date.now() + 15552000000).toISOString(),
                comments: []
            },
            // Education category
            {
                id: 'ed1',
                category: 'education',
                title: 'Will ChatGPT be banned in schools nationwide?',
                description: 'Will AI chatbots be officially banned in K-12 schools?',
                outcomes: ['Yes', 'No'],
                volume: 189000,
                percentages: [22, 78],
                createdAt: new Date(Date.now() - 86400000).toISOString(),
                emoji: 'üìö',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'ed2',
                category: 'education',
                title: 'Will student loan forgiveness pass in 2025?',
                description: 'Will a major student debt forgiveness bill be approved?',
                outcomes: ['Yes', 'No'],
                volume: 320000,
                percentages: [35, 65],
                createdAt: new Date(Date.now() - 43200000).toISOString(),
                emoji: 'üìö',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'ed3',
                category: 'education',
                title: 'Will Harvard tuition exceed $60K per year?',
                description: 'Will Harvard\'s annual tuition break $60,000?',
                outcomes: ['Yes', 'No'],
                volume: 134000,
                percentages: [58, 42],
                createdAt: new Date(Date.now() - 21600000).toISOString(),
                emoji: 'üìö',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'ed4',
                category: 'education',
                title: 'Will online degrees become more valuable than in-person?',
                description: 'Will employers value online degrees equally or more than traditional?',
                outcomes: ['Yes', 'No'],
                volume: 178000,
                percentages: [28, 72],
                createdAt: new Date(Date.now() - 172800000).toISOString(),
                emoji: 'üìö',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'ed5',
                category: 'education',
                title: 'Will a coding bootcamp graduate get hired at Google?',
                description: 'Will a bootcamp grad (no CS degree) land a job at Google this year?',
                outcomes: ['Yes', 'No'],
                volume: 112000,
                percentages: [42, 58],
                createdAt: new Date(Date.now() - 604800000).toISOString(),
                emoji: 'üìö',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            },
            {
                id: 'ed6',
                category: 'education',
                title: 'Will Khan Academy reach 200M registered users?',
                description: 'Will Khan Academy hit 200 million user registrations?',
                outcomes: ['Yes', 'No'],
                volume: 98000,
                percentages: [65, 35],
                createdAt: new Date(Date.now() - 259200000).toISOString(),
                emoji: 'üìö',
                endTime: new Date(Date.now() + 31536000000).toISOString(),
                comments: []
            }
        ];
        
        // Initialize markets - always include defaults, merge with user-created markets
        let storedMarkets = loadMarketsFromStorage();
        let markets = [...defaultMarkets]; // Start with defaults
        
        if (storedMarkets && storedMarkets.length > 0) {
            // Get IDs of default markets to avoid duplicates
            const defaultIds = new Set(defaultMarkets.map(m => m.id));
            
            // Add user-created markets (those not in defaults) to the array
            storedMarkets.forEach(storedMarket => {
                if (!defaultIds.has(storedMarket.id)) {
                    markets.push(storedMarket);
                }
            });
        }
        
        // Save to localStorage (will include defaults + user markets)
        saveMarketsToStorage();

        // Get emoji based on market title
        function getMarketEmoji(title) {
            if (!title) return 'üìä';
            const lowerTitle = title.toLowerCase();
            
            if (lowerTitle.includes('rain') || lowerTitle.includes('weather') || lowerTitle.includes('sun') || lowerTitle.includes('cloud')) return 'üåßÔ∏è';
            if (lowerTitle.includes('late') || lowerTitle.includes('meeting') || lowerTitle.includes('time') || lowerTitle.includes('on time')) return '‚è∞';
            if (lowerTitle.includes('coffee') || lowerTitle.includes('cafe')) return '‚òï';
            if (lowerTitle.includes('dish') || lowerTitle.includes('dishes') || lowerTitle.includes('cook') || lowerTitle.includes('meal')) return 'üçΩÔ∏è';
            if (lowerTitle.includes('work') || lowerTitle.includes('office') || lowerTitle.includes('job')) return 'üíº';
            if (lowerTitle.includes('train') || lowerTitle.includes('bus') || lowerTitle.includes('traffic') || lowerTitle.includes('commute')) return 'üöá';
            if (lowerTitle.includes('shop') || lowerTitle.includes('buy') || lowerTitle.includes('store')) return 'üõí';
            if (lowerTitle.includes('party') || lowerTitle.includes('event') || lowerTitle.includes('social')) return 'üéâ';
            if (lowerTitle.includes('gym') || lowerTitle.includes('exercise') || lowerTitle.includes('workout') || lowerTitle.includes('fitness')) return 'üí™';
            if (lowerTitle.includes('food') || lowerTitle.includes('eat') || lowerTitle.includes('lunch') || lowerTitle.includes('dinner')) return 'üçî';
            if (lowerTitle.includes('sleep') || lowerTitle.includes('wake') || lowerTitle.includes('bed')) return 'üò¥';
            if (lowerTitle.includes('study') || lowerTitle.includes('exam') || lowerTitle.includes('test')) return 'üìö';
            return 'üìä'; // default
        }

        // Render a single market card
        function renderMarketCard(market) {
            // Always use category emoji first to ensure consistency within categories
            // Then fall back to saved emoji or title-based guess
            const emoji = (market.category && categoryEmojis[market.category]) || market.emoji || getMarketEmoji(market.title);
            const volume = market.volume || 0;
            const volumeText = volume >= 1000 ? `$${(volume / 1000).toFixed(1)}k` : `$${volume}`;
            
            // Calculate win probabilities for outcomes (live-time updates)
            // Use pre-set percentages if available, otherwise calculate
            const totalVolume = market.volume || 0;
            let percentages = market.percentages;
            
            // Track previous percentages to determine trend direction
            // Initialize if not exists (for new markets or first render)
            if (!market.previousPercentages || market.previousPercentages.length !== market.outcomes.length) {
                market.previousPercentages = percentages ? [...percentages] : market.outcomes.map(() => 0);
            }
            
            // If percentages are already set, use them (for fake polls with realistic data)
            if (percentages && percentages.length === market.outcomes.length) {
                // Percentages are already set, use them
            } else if (totalVolume === 0) {
                // New polls with no volume start at 0%
                percentages = market.outcomes.map(() => 0);
            } else {
                // Calculate based on volume distribution (simulate live trading)
                const basePercentages = market.outcomes.map(() => Math.random() * 100);
                const sum = basePercentages.reduce((a, b) => a + b, 0);
                percentages = basePercentages.map(p => Math.round((p / sum) * 100));
                // Store for live updates
                market.percentages = percentages;
            }
            
            // Normalize percentages to ensure they sum to 100 (only if not all zeros)
            const sum = percentages.reduce((a, b) => a + b, 0);
            if (sum > 0 && sum !== 100) {
                percentages = percentages.map(p => Math.round((p / sum) * 100));
                market.percentages = percentages;
            }
            
            // Determine trend direction for each outcome (compare current vs previous)
            const trends = percentages.map((current, idx) => {
                const previous = market.previousPercentages[idx] || 0;
                if (current > previous) return 'up'; // Green
                if (current < previous) return 'down'; // Red
                return 'neutral'; // Gray (no change)
            });
            
            // Update previous percentages for next render
            market.previousPercentages = [...percentages];
            
            return `
                <div class="rounded-lg p-4 cursor-pointer hover:opacity-90 transition-opacity" style="background-color: #161b22; border: 1px solid #30363d;" data-poll-id="${market.id}">
                    <div class="flex items-start justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <div class="w-8 h-8 rounded-full flex items-center justify-center text-lg">
                                ${emoji}
                            </div>
                            <h3 class="text-sm font-medium text-white line-clamp-2 leading-snug">
                                ${market.title}
                            </h3>
                        </div>
                        <button class="p-1 hover:opacity-70 rounded-lg" onclick="event.stopPropagation();">
                            <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                            </svg>
                        </button>
                    </div>
                    <div class="space-y-2 mb-3">
                        ${market.outcomes.slice(0, 2).map((outcome, idx) => {
                            const prob = percentages[idx] || 0;
                            const trend = trends[idx];
                            
                            // Color based on trend: green for up, red for down, gray for neutral/no bets
                            let probColor = '#8b949e'; // Default gray
                            if (prob > 0) {
                                if (trend === 'up') {
                                    probColor = '#10b981'; // Green (trending up)
                                } else if (trend === 'down') {
                                    probColor = '#ef4444'; // Red (trending down)
                                } else {
                                    // Neutral - use green if >= 50%, orange if < 50%
                                    probColor = prob >= 50 ? '#10b981' : '#f59e0b';
                                }
                            }
                            
                            // Determine arrow icon based on trend - always show arrow
                            let arrowIcon = '';
                            if (trend === 'up') {
                                arrowIcon = '<svg class="w-3 h-3 inline-block ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg>';
                            } else if (trend === 'down') {
                                arrowIcon = '<svg class="w-3 h-3 inline-block ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>';
                            } else {
                                // Neutral - show horizontal arrow or default to up
                                arrowIcon = '<svg class="w-3 h-3 inline-block ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="vertical-align: middle;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14" /></svg>';
                            }
                            
                            return `
                            <div class="flex items-center justify-between gap-2">
                                <span class="text-xs flex-1 truncate mr-2" style="color: #8b949e;">${outcome}</span>
                                <span class="text-xs font-semibold cursor-pointer hover:opacity-80 transition-opacity flex items-center" 
                                      style="color: ${probColor};"
                                      onclick="event.stopPropagation(); openTradingModal('${market.id}', ${idx}, '${outcome.replace(/'/g, "\\'")}');">
                                    ${prob}%${arrowIcon}
                                </span>
                            </div>
                        `;
                        }).join('')}
                    </div>
                    <div class="flex items-center justify-between pt-3" style="border-top: 1px solid #30363d;">
                        <span class="text-xs" style="color: #8b949e;">${volumeText} Vol.</span>
                        <button class="p-1 hover:opacity-70 rounded" onclick="event.stopPropagation();">
                            <svg class="h-4 w-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </button>
                    </div>
                </div>
            `;
        }

        // Category filter
        let currentCategoryFilter = '';
        
        function filterByCategory(category, e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Close poll detail page if it's open
            const detailPage = document.getElementById('pollDetailPage');
            if (detailPage && detailPage.style.display !== 'none') {
                closePollDetail();
            }
            
            // Close dashboard if it's open
            const userDashboard = document.getElementById('userDashboard');
            if (userDashboard && userDashboard.style.display !== 'none') {
                closeDashboard();
            }
            
            // Ensure main content is visible
            const mainContent = document.querySelector('main');
            if (mainContent) {
                mainContent.style.display = 'block';
            }
            
            // Scroll to top to show the markets list
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            currentCategoryFilter = category;
            
            // Clear tab selection when category is selected
            const tabs = {
                'Trending': document.getElementById('tabTrending')
            };
            Object.values(tabs).forEach(btn => {
                if (btn) {
                    btn.style.color = '#8b949e';
                    btn.style.borderBottom = 'none';
                }
            });
            activeTab = ''; // Clear active tab
            
            // Update category button styling
            console.log('Calling updateCategoryButtonSelection with:', category);
            updateCategoryButtonSelection(category);
            
            // Force a re-check after a short delay
            setTimeout(() => {
                const btn = document.querySelector('[id^="cat-"].category-selected');
                if (btn) {
                    console.log('Selected button found:', btn.id, btn);
                    console.log('Button computed styles:', window.getComputedStyle(btn).borderBottom);
                } else {
                    console.warn('No selected button found after update');
                }
            }, 100);
            
            renderMarkets();
        }
        
        function updateCategoryButtonSelection(selectedCategory) {
            console.log('updateCategoryButtonSelection called with:', selectedCategory);
            // Category to button ID mapping (including all possible button IDs)
            const categoryButtonMap = {
                'other': ['cat-other'],
                'gaming': ['cat-gaming'],
                'fitness': ['cat-wellness'],
                'wellness': ['cat-wellness'], // Legacy support
                'socials': ['cat-socials'],
                'foodies': ['cat-foodies'],
                'office': ['cat-office'],
                'entertainment': ['cat-entertainment'],
                'sports': ['cat-sports'],
                'education': ['cat-education']
            };
            
            // Remove purple border from all category buttons
            const allCategoryButtons = document.querySelectorAll('[id^="cat-"]');
            allCategoryButtons.forEach(btn => {
                if (btn) {
                    // Remove class
                    btn.classList.remove('category-selected');
                    // Remove all inline border styles
                    btn.style.removeProperty('border-bottom');
                    btn.style.removeProperty('border-bottom-color');
                    btn.style.removeProperty('border-bottom-width');
                    btn.style.removeProperty('border-bottom-left-radius');
                    btn.style.removeProperty('border-bottom-right-radius');
                    btn.style.removeProperty('box-shadow');
                    // Reset onmouseout to default behavior
                    btn.onmouseout = function(e) {
                        this.style.color = '#8b949e';
                        this.style.backgroundColor = 'transparent';
                    };
                }
            });
            
            // Add purple border to selected category button(s)
            const selectedBtnIds = categoryButtonMap[selectedCategory];
            if (selectedBtnIds && selectedBtnIds.length > 0) {
                selectedBtnIds.forEach(btnId => {
                    const selectedBtn = document.getElementById(btnId);
                if (selectedBtn) {
                        console.log('Applying purple border to button:', btnId, selectedBtn);
                        // Add class
                        selectedBtn.classList.add('category-selected');
                        
                        // Force border with inline styles using setProperty for important
                        selectedBtn.style.setProperty('border-bottom', '2px solid #a855f7', 'important');
                        selectedBtn.style.setProperty('border-bottom-left-radius', '0', 'important');
                        selectedBtn.style.setProperty('border-bottom-right-radius', '0', 'important');
                        selectedBtn.style.setProperty('box-shadow', '0 2px 0 0 #a855f7', 'important');
                        
                        // Override onmouseout to preserve border
                        selectedBtn.onmouseout = function(e) {
                            this.style.color = '#8b949e';
                            this.style.backgroundColor = 'transparent';
                            // Always restore the purple border
                            this.style.setProperty('border-bottom', '2px solid #a855f7', 'important');
                            this.style.setProperty('box-shadow', '0 2px 0 0 #a855f7', 'important');
                        };
                    } else {
                        console.warn('Button not found:', btnId);
                    }
                });
            }
        }
        
        function clearCategorySelection() {
            // Remove purple border from all category buttons
            const categoryButtons = document.querySelectorAll('[id^="cat-"]');
            categoryButtons.forEach(btn => {
                if (btn) {
                    // Remove class
                    btn.classList.remove('category-selected');
                    // Remove inline styles
                    btn.style.removeProperty('border-bottom');
                    btn.style.removeProperty('border-bottom-color');
                    btn.style.removeProperty('border-bottom-width');
                    btn.style.removeProperty('border-bottom-left-radius');
                    btn.style.removeProperty('border-bottom-right-radius');
                    btn.style.removeProperty('box-shadow');
                    // Reset onmouseout to default behavior
                    btn.onmouseout = function(e) {
                        this.style.color = '#8b949e';
                        this.style.backgroundColor = 'transparent';
                    };
                }
            });
        }
        
        
        // Search functionality
        let currentSearchQuery = '';
        let selectedSuggestionIndex = -1;
        
        function getSearchSuggestions(query) {
            if (!query || query.trim().length === 0) {
                return [];
            }
            
            const queryLower = query.trim().toLowerCase();
            const keywords = queryLower.split(/\s+/).filter(k => k.length > 0);
            
            // Get matching markets (ALL keywords must match)
            const suggestions = markets.filter(market => {
                const title = (market.title || '').toLowerCase();
                return keywords.every(keyword => title.includes(keyword));
            });
            
            // Sort by relevance (exact matches first, then partial matches)
            return suggestions.sort((a, b) => {
                const aTitle = (a.title || '').toLowerCase();
                const bTitle = (b.title || '').toLowerCase();
                
                // Exact match gets highest priority
                if (aTitle === queryLower) return -1;
                if (bTitle === queryLower) return 1;
                
                // Starts with query gets second priority
                if (aTitle.startsWith(queryLower)) return -1;
                if (bTitle.startsWith(queryLower)) return 1;
                
                // Then by volume/recency
                return (b.volume || 0) - (a.volume || 0);
            }).slice(0, 5); // Limit to 5 suggestions
        }
        
        function renderAutocompleteSuggestions(query) {
            const dropdown = document.getElementById('autocompleteDropdown');
            const list = document.getElementById('autocompleteList');
            const clearBtn = document.getElementById('clearSearchBtn');
            
            if (!dropdown || !list) return;
            
            if (!query || query.trim().length === 0) {
                dropdown.classList.add('hidden');
                if (clearBtn) clearBtn.classList.add('hidden');
                return;
            }
            
            // Show clear button
            if (clearBtn) clearBtn.classList.remove('hidden');
            
            const suggestions = getSearchSuggestions(query);
            
            if (suggestions.length === 0) {
                dropdown.classList.add('hidden');
                return;
            }
            
            dropdown.classList.remove('hidden');
            
            // Simple autocomplete - just show titles
            list.innerHTML = suggestions.map((market, index) => {
                const title = market.title || '';
                
                return `
                    <div 
                        class="px-4 py-2.5 cursor-pointer hover:bg-gray-800 transition-colors suggestion-item"
                        data-index="${index}"
                        data-market-id="${market.id}"
                        onmousedown="event.preventDefault(); selectSuggestion('${market.id}')"
                        onmouseenter="highlightSuggestion(${index})"
                        style="background-color: ${index === selectedSuggestionIndex ? '#21262d' : 'transparent'};"
                    >
                        <p class="text-white text-sm">${title}</p>
                    </div>
                `;
            }).join('');
        }
        
        function highlightSuggestion(index) {
            selectedSuggestionIndex = index;
            const items = document.querySelectorAll('.suggestion-item');
            items.forEach((item, i) => {
                if (i === index) {
                    item.style.backgroundColor = '#21262d';
                } else {
                    item.style.backgroundColor = 'transparent';
                }
            });
        }
        
        function selectSuggestion(marketId) {
            // Set flag to prevent blur from closing dropdown
            window.isClickingSuggestion = true;
            
            const market = markets.find(m => m.id === marketId);
            if (market) {
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.value = market.title;
                }
                // Perform search and hide autocomplete
                currentSearchQuery = market.title.toLowerCase();
                hideAutocomplete();
                renderMarkets();
                
                // Reset flag after a short delay
                setTimeout(() => {
                    window.isClickingSuggestion = false;
                }, 100);
            } else {
                window.isClickingSuggestion = false;
            }
        }
        
        function hideAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            if (dropdown) {
                dropdown.classList.add('hidden');
            }
            selectedSuggestionIndex = -1;
            // Reset clicking flag
            window.isClickingSuggestion = false;
        }
        
        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
                searchInput.focus();
            }
            currentSearchQuery = '';
            currentCategoryFilter = ''; // Also clear category filter
            clearCategorySelection(); // Clear category button selection
            hideAutocomplete();
            renderMarkets();
            const clearBtn = document.getElementById('clearSearchBtn');
            if (clearBtn) clearBtn.classList.add('hidden');
        }
        
        function performSearch(query) {
            const trimmedQuery = query ? query.trim() : '';
            currentSearchQuery = trimmedQuery.toLowerCase();
            // Don't hide autocomplete here - let user see suggestions while typing
            renderMarkets();
        }
        
        // Render all markets based on active tab and search query
        function renderMarkets() {
            const container = document.getElementById('marketsContainer');
            if (!container) {
                console.error('marketsContainer not found');
                return;
            }
            
            let filteredMarkets = [...markets];
            
            // Apply category filter if there's one selected
            if (currentCategoryFilter) {
                filteredMarkets = filteredMarkets.filter(market => {
                    return market.category === currentCategoryFilter;
                });
            }
            
            // Apply search filter if there's a query
            if (currentSearchQuery) {
                filteredMarkets = filteredMarkets.filter(market => {
                    const title = (market.title || '').toLowerCase();
                    // Check if ALL keywords from search query match the title
                    const keywords = currentSearchQuery.split(/\s+/).filter(k => k.length > 0);
                    return keywords.every(keyword => title.includes(keyword));
                });
            }
            
            // Sort based on active tab (only if no category filter is active)
            if (!currentCategoryFilter) {
                if (activeTab === 'Trending') {
                    // Sort by creation date (most recent first)
                    filteredMarkets.sort((a, b) => {
                        const dateA = new Date(a.createdAt || 0);
                        const dateB = new Date(b.createdAt || 0);
                        return dateB - dateA; // Most recent first
                    });
                }
            } else {
                // When filtering by category, sort by creation date (most recent first)
                filteredMarkets.sort((a, b) => {
                    const dateA = new Date(a.createdAt || 0);
                    const dateB = new Date(b.createdAt || 0);
                    return dateB - dateA; // Most recent first
                });
            }
            
            // Show message if no results
            if (filteredMarkets.length === 0 && currentSearchQuery) {
                container.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <svg class="w-16 h-16 mx-auto mb-4" style="color: #8b949e;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        <p class="text-xl text-gray-400 mb-2">No polls found</p>
                        <p class="text-gray-500">Try different keywords or clear your search</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = filteredMarkets.map(market => renderMarketCard(market)).join('');
            
            // Re-attach click handlers after rendering
            setTimeout(() => {
                container.querySelectorAll('[data-poll-id]').forEach(card => {
                    const pollId = card.getAttribute('data-poll-id');
                    // Remove existing listeners to avoid duplicates
                    const newCard = card.cloneNode(true);
                    card.parentNode.replaceChild(newCard, card);
                    
                    newCard.addEventListener('click', (e) => {
                        // Don't trigger if clicking on buttons inside the card
                        if (e.target.closest('button')) {
                            e.stopPropagation();
                            return;
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Card clicked, opening poll:', pollId);
                        openPollDetail(pollId);
                    });
                });
            }, 0);
        }

        // Form submission
        const createMarketForm = document.getElementById('createMarketForm');
        if (createMarketForm) {
            createMarketForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            console.log('Form submitted');
                
                // Validate resolution criteria (including duplicate check)
                const validationResult = validateResolutionCriteria();
                console.log('Validation result:', validationResult);
                if (!validationResult) {
                    console.warn('Validation failed');
                    return;
                }
            
            // Get resolution criteria options
            const resolutionInputs = document.querySelectorAll('.resolution-criteria-input');
            const resolutionCriteria = Array.from(resolutionInputs)
                .map(input => input.value.trim())
                .filter(value => value.length > 0);
            
            const category = document.getElementById('marketCategory').value;
            const title = document.getElementById('marketTitle').value;
            const description = document.getElementById('marketDescription').value;
            const endTimeInput = document.getElementById('endTime');
            const endTimeRaw = endTimeInput ? endTimeInput.value : '';
            const visibility = 'Public'; // All polls are public by default
            
            if (!category || !title || !endTimeRaw) {
                alert('Please fill in all required fields.');
                return;
            }
            
            // Convert endTime to ISO string format for consistent storage
            let endTimeISO = endTimeRaw;
            try {
                // If it's already in ISO format (YYYY-MM-DDTHH:mm), convert to full ISO string
                if (endTimeRaw.includes('T')) {
                    const date = new Date(endTimeRaw);
                    if (!isNaN(date.getTime())) {
                        endTimeISO = date.toISOString();
                    }
                } else {
                    // If it's in a different format, try to parse it
                    const date = new Date(endTimeRaw);
                    if (!isNaN(date.getTime())) {
                        endTimeISO = date.toISOString();
                    }
                }
            } catch (e) {
                console.warn('Could not parse endTime, using raw value:', e);
            }
            
            // Get user identifier from login data
            const loginData = localStorage.getItem('userLogin');
            let creator = null;
            if (loginData) {
                try {
                    const data = JSON.parse(loginData);
                    // For wallet users, use the wallet address; for others, use identifier
                    creator = (data.provider === 'wallet' && data.identifier) 
                        ? data.identifier.toLowerCase() 
                        : (data.identifier || data.userAddress || null);
                } catch (e) {
                    console.warn('Could not parse login data for creator:', e);
                }
            }
            
            // Create new market object with all required fields
            const newMarket = {
                id: Date.now().toString(),
                category: category,
                title: title,
                description: description || '',
                outcomes: resolutionCriteria, // Array of resolution criteria
                volume: 0,
                endTime: endTimeISO, // Save the end time from the form as ISO string
                createdAt: new Date().toISOString(),
                emoji: categoryEmojis[category] || getMarketEmoji(title),
                percentages: resolutionCriteria.map(() => 0), // New polls start at 0%
                outcomeVolumes: resolutionCriteria.map(() => 0), // Initialize outcome volumes
                creator: creator || null, // Add creator field
                visibilityType: visibility || 'Public', // Add visibility type, default to Public
                comments: [] // Initialize comments array
            };
            
            console.log('Creating new market:', newMarket);
            
            // Add to beginning of markets array (newest first)
            markets.unshift(newMarket);
            
            // Save to localStorage
            saveMarketsToStorage();
            
            // All markets are public - no invite link generation needed
            if (false && visibility === 'Private' && creator) {
                // Generate a unique invite token
                const inviteToken = 'inv_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
                
                // Store invite token with market
                newMarket.inviteToken = inviteToken;
                newMarket.visibilityType = 'Private';
                
                // Try to generate invite link via backend API (if backend is available)
                try {
                    const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                    const response = await fetch(`${API_URL}/api/markets/` + newMarket.id + '/invites', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            createdBy: creator,
                            maxUses: null, // Unlimited uses
                            expiresInDays: null // Never expires
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const inviteLink = data.inviteLink || `${window.location.origin}/invite/${data.invite?.inviteToken}`;
                        
                        // Show invite link modal
                        showInviteLinkModal(inviteLink, newMarket.title);
                    } else {
                        // Fallback: use local invite link
                        const inviteLink = `${window.location.origin}?invite=${inviteToken}&market=${newMarket.id}`;
                        showInviteLinkModal(inviteLink, newMarket.title);
                    }
                } catch (error) {
                    console.error('Error generating invite link via backend:', error);
                    // Fallback: use local invite link
                    const inviteLink = `${window.location.origin}?invite=${inviteToken}&market=${newMarket.id}`;
                    showInviteLinkModal(inviteLink, newMarket.title);
                }
                
                // Update markets array with invite token
                markets[0] = newMarket;
                saveMarketsToStorage();
            }
            
            // Reset form
            document.getElementById('createMarketForm').reset();
            resetResolutionCriteria();
            
            // Close modal
            createMarketModal.classList.add('hidden');
            
            // Switch to New tab
            setActiveTab('New');
            
            // Render markets (this will show the new market at the top)
            renderMarkets();
            
            console.log('‚úÖ New market created:', newMarket);
        });
        } else {
            console.error('Create Market form not found. Make sure the form exists in the DOM.');
        }

        // Tab functionality
        let activeTab = 'Trending';
        function setActiveTab(tab) {
            console.log('setActiveTab called with:', tab);
            activeTab = tab;
            
            // Hide all special pages FIRST
            const howItWorksPage = document.getElementById('howItWorksPage');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const userDashboard = document.getElementById('userDashboard');
            const settingsPage = document.getElementById('settingsPage');
            const createMarketModal = document.getElementById('createMarketModal');
            
            if (howItWorksPage) {
                howItWorksPage.style.display = 'none';
                howItWorksPage.style.visibility = 'hidden';
                howItWorksPage.style.opacity = '0';
                howItWorksPage.style.zIndex = '-1';
            }
            if (pollDetailPage && pollDetailPage.style.display !== 'none') {
                closePollDetail();
            }
            if (userDashboard && userDashboard.style.display !== 'none') {
                closeDashboard();
            }
            if (settingsPage) {
                settingsPage.style.display = 'none';
                settingsPage.style.visibility = 'hidden';
            }
            if (createMarketModal) {
                createMarketModal.classList.add('hidden');
                createMarketModal.style.display = 'none';
            }
            
            // Ensure main content is visible
            const mainContent = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const nav = document.querySelector('nav');
            
            if (mainContent) {
                mainContent.style.display = 'block';
                mainContent.style.visibility = 'visible';
                mainContent.style.opacity = '1';
                mainContent.style.zIndex = '1';
            }
            if (marketsContainer) {
                marketsContainer.style.display = 'grid';
                marketsContainer.style.visibility = 'visible';
            }
            if (nav) {
                nav.style.display = 'block';
                nav.style.visibility = 'visible';
            }
            
            // Scroll to top to show the markets list
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // Clear category filter and selection when tab is selected
            currentCategoryFilter = '';
            clearCategorySelection();
            
            // Update tab styling
            const tabs = {
                'Trending': document.getElementById('tabTrending')
            };
            
            Object.keys(tabs).forEach(key => {
                const btn = tabs[key];
                if (btn) {
                    if (key === tab) {
                        btn.style.color = 'white';
                        btn.style.borderBottom = '2px solid #a855f7'; // Match Trending tab purple border
                    } else {
                        btn.style.color = '#8b949e';
                        btn.style.borderBottom = 'none';
                    }
                } else {
                    console.warn('Tab button not found:', key);
                }
            });
            
            // Re-render markets when tab changes (search filter is preserved)
            console.log('Rendering markets with activeTab:', activeTab);
            renderMarkets();
        }
        
        // Make setActiveTab globally accessible
        window.setActiveTab = setActiveTab;
        
        // Simple function to go to Trending section
        function goToTrending() {
            console.log('goToTrending called');
            
            // Hide How It Works page
            const howItWorksPage = document.getElementById('howItWorksPage');
            if (howItWorksPage) {
                howItWorksPage.style.display = 'none';
                howItWorksPage.style.visibility = 'hidden';
                howItWorksPage.style.opacity = '0';
                howItWorksPage.style.zIndex = '-1';
            }
            
            // Hide other pages
            const pollDetailPage = document.getElementById('pollDetailPage');
            const userDashboard = document.getElementById('userDashboard');
            const settingsPage = document.getElementById('settingsPage');
            const createMarketModal = document.getElementById('createMarketModal');
            
            if (pollDetailPage) {
                pollDetailPage.style.display = 'none';
                pollDetailPage.style.visibility = 'hidden';
            }
            if (userDashboard) {
                userDashboard.style.display = 'none';
                userDashboard.style.visibility = 'hidden';
            }
            if (settingsPage) {
                settingsPage.style.display = 'none';
                settingsPage.style.visibility = 'hidden';
            }
            if (createMarketModal) {
                createMarketModal.classList.add('hidden');
                createMarketModal.style.display = 'none';
            }
            
            // Show main content
            const main = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const nav = document.querySelector('nav');
            
            if (main) {
                main.style.display = 'block';
                main.style.visibility = 'visible';
                main.style.opacity = '1';
                main.style.zIndex = '1';
            }
            if (marketsContainer) {
                marketsContainer.style.display = 'grid';
                marketsContainer.style.visibility = 'visible';
            }
            if (nav) {
                nav.style.display = 'block';
                nav.style.visibility = 'visible';
            }
            
            // Force a small delay to ensure DOM updates
            setTimeout(() => {
                // Call setActiveTab to show Trending section
                if (typeof setActiveTab === 'function') {
                    console.log('Calling setActiveTab("Trending")');
                    setActiveTab('Trending');
                } else if (typeof window.setActiveTab === 'function') {
                    console.log('Calling window.setActiveTab("Trending")');
                    window.setActiveTab('Trending');
                } else {
                    console.warn('setActiveTab not found, trying renderMarkets');
                    // Fallback: render markets directly
                    if (typeof renderMarkets === 'function') {
                        renderMarkets();
                    } else if (typeof window.renderMarkets === 'function') {
                        window.renderMarkets();
                    }
                }
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, 50);
        }
        
        // Make goToTrending globally accessible immediately
        window.goToTrending = goToTrending;

        // Poll Detail Functions
        let currentPollId = null;
        
        // Trading state (declared once globally)
        var tradeMode = 'buy';
        var currentTradeAmount = 0;

        function openPollDetail(pollId) {
            console.log('openPollDetail called with pollId:', pollId);
            try {
                // Reload markets from storage to get latest data
                // Try both storage keys to ensure we get the latest data
                const STORAGE_KEY = 'pollit_markets';
                let storedMarkets = localStorage.getItem(STORAGE_KEY) || localStorage.getItem('markets');
                
                if (storedMarkets) {
                    try {
                        const parsed = JSON.parse(storedMarkets);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            // Update markets array with latest data
                            markets.length = 0;
                            markets.push(...parsed);
                            console.log('Reloaded', parsed.length, 'markets from storage');
                        }
                    } catch (e) {
                        console.warn('Error reloading markets from storage:', e);
                    }
                } else {
                    console.warn('No markets found in storage');
                }
                
                // Update URL without reloading
                window.history.pushState({ pollId: pollId }, '', `?poll=${pollId}`);
                
                // Try to find poll with multiple ID matching strategies
                let poll = markets.find(m => {
                    if (!m || !m.id) return false;
                    const mId = m.id.toString();
                    const searchId = pollId.toString();
                    return mId === searchId || mId === pollId || m.id === pollId;
                });
                
                if (!poll) {
                    console.error('Poll not found:', pollId);
                    console.error('Available polls:', markets.map(m => ({ id: m.id, title: m.title })));
                    console.error('Markets array length:', markets.length);
                    
                    // Try reloading from storage one more time
                    const STORAGE_KEY = 'pollit_markets';
                    const storedMarkets = localStorage.getItem(STORAGE_KEY);
                    if (storedMarkets) {
                        try {
                            const parsed = JSON.parse(storedMarkets);
                            if (Array.isArray(parsed)) {
                                markets.length = 0;
                                markets.push(...parsed);
                                poll = markets.find(m => {
                                    if (!m || !m.id) return false;
                                    const mId = m.id.toString();
                                    const searchId = pollId.toString();
                                    return mId === searchId || mId === pollId || m.id === pollId;
                                });
                            }
                        } catch (e) {
                            console.error('Error reloading markets:', e);
                        }
                    }
                    
                    if (!poll) {
                        alert('Poll not found. The poll may have been deleted or the page needs to be refreshed.');
                        return;
                    }
                }
                
                console.log('Poll found:', poll);
                console.log('Poll data:', {
                    id: poll.id,
                    title: poll.title,
                    outcomes: poll.outcomes,
                    volume: poll.volume,
                    percentages: poll.percentages,
                    outcomeVolumes: poll.outcomeVolumes,
                    endTime: poll.endTime,
                    description: poll.description,
                    category: poll.category
                });
                
                // Ensure required fields exist
                if (!poll.outcomes || poll.outcomes.length === 0) {
                    console.error('Poll has no outcomes:', poll);
                    alert('This poll has no outcomes defined. Please refresh the page.');
                    return;
                }
                
                // Ensure percentages array exists and matches outcomes length
                if (!poll.percentages || poll.percentages.length !== poll.outcomes.length) {
                    poll.percentages = poll.outcomes.map(() => 0);
                }
                
                // Ensure volume exists
                if (poll.volume === undefined || poll.volume === null) {
                    poll.volume = 0;
                }

                currentPollId = pollId;
                const detailPage = document.getElementById('pollDetailPage');
                console.log('Detail page element:', detailPage);
                if (!detailPage) {
                    console.error('Poll detail page element not found');
                    return;
                }

                // Hide main content (markets list) but keep header and nav visible
                const mainContent = document.querySelector('main');
                if (mainContent) mainContent.style.display = 'none';
                
                // Show detail page - it should appear below header/nav
                detailPage.style.display = 'block';
                detailPage.style.position = 'relative';
                window.scrollTo(0, 0);
                
                // Set up comment tabs and load top holders by default
                setTimeout(() => {
                    setupCommentTabs();
                    setCommentsTab('topHolders');
                }, 200);

            // Populate poll data
            const titleEl = document.getElementById('pollDetailTitle');
            const volumeEl = document.getElementById('pollVolume');
            const endTimeEl = document.getElementById('pollEndTime');
            const emojiLargeEl = document.getElementById('pollDetailEmojiLarge');
            const tradingTitleEl = document.getElementById('pollTradingTitle');
            const marketContextEl = document.getElementById('marketContextText');
            
            // Always use category emoji first to ensure consistency within categories
            // Then fall back to saved emoji or title-based guess
            const emoji = (poll.category && categoryEmojis[poll.category]) || poll.emoji || getMarketEmoji(poll.title);
            if (titleEl) titleEl.textContent = `${emoji} ${poll.title}`;
            if (emojiLargeEl) emojiLargeEl.textContent = emoji;
            if (tradingTitleEl) tradingTitleEl.textContent = poll.title;
            
            // Format volume
            const volume = poll.volume || 0;
            const volumeText = volume >= 1000 ? `$${(volume / 1000).toFixed(1)}k` : `$${volume}`;
            if (volumeEl) volumeEl.textContent = `${volumeText} Vol.`;
            
            // Setup gamified countdown timer for end time
            let countdownInterval = null;
            let previousValues = { days: -1, hours: -1, minutes: -1, seconds: -1 };
            
            // Clear any existing countdown
            if (window.pollCountdownInterval) {
                clearInterval(window.pollCountdownInterval);
                window.pollCountdownInterval = null;
            }
            
            function updateCountdown() {
                if (!poll.endTime || !endTimeEl) return;
                
                try {
                    const endDate = new Date(poll.endTime);
                    if (isNaN(endDate.getTime())) {
                        endTimeEl.innerHTML = '<span style="color: #8b949e;">Date not set</span>';
                        return;
                    }
                    
                    const now = new Date();
                    const diff = endDate.getTime() - now.getTime();
                    
                    if (diff <= 0) {
                        endTimeEl.innerHTML = '<span style="color: #ef4444; font-weight: 600; animation: pulse 1s ease-in-out infinite;">‚è∞ Ended</span>';
                        if (countdownInterval) {
                            clearInterval(countdownInterval);
                            countdownInterval = null;
                            window.pollCountdownInterval = null;
                        }
                        return;
                    }
                    
                    // Calculate time components
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                    
                    // Calculate total time remaining for color coding (only for urgency)
                    const totalHours = diff / (1000 * 60 * 60);
                    let timeColor = '#ffffff'; // White for normal time
                    if (totalHours < 1) {
                        timeColor = '#ef4444'; // Red only for less than 1 hour
                    }
                    
                    // Create gamified countdown display with animated numbers
                    let countdownHTML = '';
                    
                    // Check which values changed for animation
                    const daysChanged = days !== previousValues.days;
                    const hoursChanged = hours !== previousValues.hours;
                    const minutesChanged = minutes !== previousValues.minutes;
                    const secondsChanged = seconds !== previousValues.seconds;
                    
                    if (days > 0) {
                        countdownHTML = `
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block;" class="countdown-number ${daysChanged ? 'changing' : ''}">${days}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">d</span>
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block; margin-left: 6px;" class="countdown-number ${hoursChanged ? 'changing' : ''}">${hours.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">h</span>
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block; margin-left: 6px;" class="countdown-number ${minutesChanged ? 'changing' : ''}">${minutes.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">m</span>
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block; margin-left: 6px;" class="countdown-number ${secondsChanged ? 'changing' : ''}">${seconds.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">s</span>
                            <span style="color: #8b949e; margin-left: 8px;">remaining</span>
                        `;
                    } else if (hours > 0) {
                        countdownHTML = `
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block;" class="countdown-number ${hoursChanged ? 'changing' : ''}">${hours.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">h</span>
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block; margin-left: 6px;" class="countdown-number ${minutesChanged ? 'changing' : ''}">${minutes.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">m</span>
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.1em; display: inline-block; margin-left: 6px;" class="countdown-number ${secondsChanged ? 'changing' : ''}">${seconds.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">s</span>
                            <span style="color: #8b949e; margin-left: 8px;">remaining</span>
                        `;
                    } else if (minutes > 0) {
                        countdownHTML = `
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.2em; display: inline-block;" class="countdown-number ${minutesChanged ? 'changing' : ''}">${minutes.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">m</span>
                            <span style="color: ${timeColor}; font-weight: 600; font-size: 1.2em; display: inline-block; margin-left: 6px;" class="countdown-number ${secondsChanged ? 'changing' : ''}">${seconds.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">s</span>
                            <span style="color: #8b949e; margin-left: 8px;">remaining</span>
                        `;
                    } else {
                        countdownHTML = `
                            <span style="color: ${timeColor}; font-weight: 700; font-size: 1.3em; display: inline-block; animation: pulse 1s ease-in-out infinite;" class="countdown-number ${secondsChanged ? 'changing' : ''}">${seconds.toString().padStart(2, '0')}</span>
                            <span style="color: #8b949e; font-size: 0.9em; margin-left: 2px;">s</span>
                            <span style="color: #8b949e; margin-left: 8px;">remaining</span>
                        `;
                    }
                    
                    endTimeEl.innerHTML = countdownHTML;
                    
                    // Remove animation class after animation completes
                    setTimeout(() => {
                        const numbers = endTimeEl.querySelectorAll('.countdown-number');
                        numbers.forEach(num => {
                            num.classList.remove('changing');
                        });
                    }, 300);
                    
                    // Update previous values
                    previousValues = { days, hours, minutes, seconds };
                } catch (e) {
                    console.error('Error calculating countdown:', poll.endTime, e);
                    endTimeEl.innerHTML = '<span style="color: #8b949e;">Date not set</span>';
                }
            }
            
            // Initial update
            updateCountdown();
            
            // Update every second for real-time feel
            countdownInterval = setInterval(updateCountdown, 1000);
            window.pollCountdownInterval = countdownInterval;
            
            // Display creator information
            const creatorEl = document.getElementById('pollCreator');
            if (creatorEl) {
                if (poll.creator) {
                    // Try to get username from localStorage or use address
                    let creatorName = poll.creator;
                    try {
                        const loginData = localStorage.getItem('userLogin');
                        if (loginData) {
                            const data = JSON.parse(loginData);
                            // If this is the creator's own poll, use their username
                            if (data.identifier && data.identifier.toLowerCase() === poll.creator.toLowerCase()) {
                                creatorName = data.username || data.name || data.identifier.substring(0, 6) + '...' + data.identifier.substring(data.identifier.length - 4);
                            } else {
                                // For other creators, try to get from localStorage or use shortened address
                                if (poll.creator.startsWith('0x')) {
                                    creatorName = poll.creator.substring(0, 6) + '...' + poll.creator.substring(poll.creator.length - 4);
                                }
                            }
                        } else if (poll.creator.startsWith('0x')) {
                            creatorName = poll.creator.substring(0, 6) + '...' + poll.creator.substring(poll.creator.length - 4);
                        }
                    } catch (e) {
                        console.warn('Error parsing creator info:', e);
                        if (poll.creator.startsWith('0x')) {
                            creatorName = poll.creator.substring(0, 6) + '...' + poll.creator.substring(poll.creator.length - 4);
                        }
                    }
                    creatorEl.innerHTML = `
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                        </svg>
                        <span>Created by: <span style="color: #9333ea; font-weight: 500;">${creatorName}</span></span>
                    `;
                } else {
                    creatorEl.innerHTML = '<span style="color: #8b949e;">Created by: Unknown</span>';
                }
            }
            
            // Set market context (description from create form)
            if (marketContextEl) {
                marketContextEl.textContent = poll.description || 'No description provided.';
            }

            // Render outcomes
            const outcomesList = document.getElementById('pollOutcomesList');
            
            console.log('Outcomes elements - outcomesList:', outcomesList);
            
            if (!outcomesList) {
                console.error('Outcomes elements not found - outcomesList:', outcomesList);
                alert('Error: Required elements not found. Check console for details.');
                return;
            }
            
            outcomesList.innerHTML = '';
            
            if (!poll.outcomes || poll.outcomes.length === 0) {
                outcomesList.innerHTML = '<p class="text-gray-400">No outcomes defined</p>';
                console.warn('Poll has no outcomes');
                return;
            }
            
            console.log('Rendering', poll.outcomes.length, 'outcomes');
            
            // Calculate percentages
            // New polls start at 0% until someone buys shares
            const totalVolume = parseFloat(poll.volume) || 0;
            let percentages = poll.percentages;
            
            // If volume is 0, always set percentages to 0 (even if percentages exist)
            if (totalVolume === 0) {
                percentages = poll.outcomes.map(() => 0);
            } else if (!percentages || percentages.length !== poll.outcomes.length) {
                // If percentages don't exist but volume does, calculate from outcomeVolumes if available
                if (poll.outcomeVolumes && poll.outcomeVolumes.length === poll.outcomes.length) {
                    percentages = poll.outcomeVolumes.map(vol => {
                        return Math.round((parseFloat(vol) / totalVolume) * 100);
                    });
                    // Normalize
                    const sum = percentages.reduce((a, b) => a + b, 0);
                    if (sum !== 100 && sum > 0) {
                        const diff = 100 - sum;
                        percentages[0] += diff; // Add difference to first outcome
                    }
                    } else {
                    // Fallback: distribute evenly
                    percentages = poll.outcomes.map(() => Math.round(100 / poll.outcomes.length));
                }
            }
            
            // Calculate outcome volumes (use stored volumes if available)
            let outcomeVolumes;
            if (poll.outcomeVolumes && poll.outcomeVolumes.length === poll.outcomes.length) {
                // Use stored outcome volumes
                outcomeVolumes = poll.outcomeVolumes.map(vol => parseFloat(vol) || 0);
            } else if (totalVolume === 0) {
                // New polls with 0 volume
                outcomeVolumes = poll.outcomes.map(() => 0);
            } else {
                // Calculate from percentages if volumes not stored
                outcomeVolumes = percentages.map(pct => {
                    return Math.round((totalVolume * pct) / 100);
                });
            }
            
            // Render probability legend
            const legendEl = document.getElementById('pollLegend');
            if (legendEl) {
                // Find the winning percentage (highest) - but if all are 0, no winner
                const maxPercentage = Math.max(...percentages);
                const hasVolume = totalVolume > 0;
                
                legendEl.innerHTML = poll.outcomes.map((outcome, idx) => {
                    // New polls with 0 volume have 0% change
                    const change = hasVolume ? (Math.random() * 6 - 3).toFixed(1) : '0.0';
                    const arrow = change > 0 ? '‚Üë' : (change < 0 ? '‚Üì' : '');
                    // Green if winning (highest percentage), red if losing, gray if all 0
                    const color = !hasVolume ? '#8b949e' : (percentages[idx] === maxPercentage ? '#10b981' : '#ef4444');
                    return `<span style="color: ${color}">‚Ä¢ ${outcome} ${percentages[idx]}% ${arrow}${Math.abs(change)}%</span>`;
                }).join(' ');
            }
            
            // Render outcomes list
            poll.outcomes.forEach((outcome, idx) => {
                const percentage = percentages[idx] || 0;
                const price = (percentage / 100).toFixed(2);
                const noPrice = ((100 - percentage) / 100).toFixed(2);
                const outcomeVolume = outcomeVolumes[idx];
                const volumeText = outcomeVolume >= 1000 ? `$${(outcomeVolume / 1000).toFixed(1)}k` : `$${outcomeVolume}`;
                // New polls with 0 volume have 0% change
                const change = totalVolume > 0 ? (Math.random() * 6 - 3).toFixed(1) : '0.0';
                const arrow = change > 0 ? '‚Üë' : (change < 0 ? '‚Üì' : '');
                
                // Outcome card in 2-column grid (Polymarket style)
                const outcomeCard = document.createElement('div');
                outcomeCard.className = 'flex flex-col p-4';
                outcomeCard.style.cssText = 'background-color: #161b22; border: 1px solid #30363d; border-radius: 8px;';
                
                // Create top section with outcome name, trend, and percentage
                const topSection = document.createElement('div');
                topSection.className = 'flex items-start justify-between mb-3';
                
                // Left: Outcome name, trend, and volume
                const leftInfo = document.createElement('div');
                leftInfo.className = 'flex-1';
                const trendColor = change > 0 ? '#10b981' : change < 0 ? '#ef4444' : '#8b949e';
                leftInfo.innerHTML = `
                    <div class="flex items-center gap-2 mb-1">
                        <h3 class="text-base font-semibold text-white">${outcome}</h3>
                        ${change !== '0.0' ? `<span class="text-sm font-medium" style="color: ${trendColor};">${change > 0 ? '‚Üë' : '‚Üì'}${Math.abs(change)}%</span>` : ''}
                    </div>
                    <p class="text-sm" style="color: #8b949e;">${volumeText} Vol.</p>
                `;
                
                // Right: Percentage
                const percentageDiv = document.createElement('div');
                percentageDiv.className = 'text-right';
                percentageDiv.innerHTML = `<div class="text-lg font-semibold text-white">${percentage}%</div>`;
                
                topSection.appendChild(leftInfo);
                topSection.appendChild(percentageDiv);
                
                // Create bottom section with buy buttons
                const bottomSection = document.createElement('div');
                bottomSection.className = 'flex gap-2 mt-2';
                
                // Check if this is a Yes/No poll (only 2 outcomes and they are "Yes" and "No")
                const isYesNoPoll = poll.outcomes.length === 2 && 
                    poll.outcomes.some(o => o.toLowerCase() === 'yes') && 
                    poll.outcomes.some(o => o.toLowerCase() === 'no');
                
                // Always show only the button for this specific outcome
                const buyButton = document.createElement('button');
                buyButton.type = 'button';
                buyButton.className = 'w-full px-3 py-2 rounded text-sm font-medium text-white hover:opacity-90 transition-opacity';
                
                // Determine button color based on poll type
                let buttonColor;
                if (isYesNoPoll) {
                    // For Yes/No polls, use green for Yes, red for No
                    buttonColor = outcome.toLowerCase() === 'yes' ? '#10b981' : '#ef4444';
                } else {
                    // For other polls, use green for the primary action
                    buttonColor = '#10b981';
                }
                
                buyButton.style.cssText = `background-color: ${buttonColor}; cursor: pointer;`;
                buyButton.textContent = `Buy ${outcome} ${price}¬¢`;
                buyButton.setAttribute('data-outcome-index', idx);
                buyButton.setAttribute('data-outcome-name', outcome);
                buyButton.setAttribute('data-outcome-price', price);
                buyButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof selectOutcomeForTrade === 'function') {
                        selectOutcomeForTrade(idx, outcome, price);
                    } else if (typeof window.selectOutcomeForTrade === 'function') {
                        window.selectOutcomeForTrade(idx, outcome, price);
                    }
                }, true);
                bottomSection.appendChild(buyButton);
                
                outcomeCard.appendChild(topSection);
                outcomeCard.appendChild(bottomSection);
                outcomesList.appendChild(outcomeCard);

                // Remove trading outcomes from sidebar - now handled in modal
            });
            
            // Render probability chart
            renderProbabilityChart(poll, percentages);
            
            // Render related markets (default to Trending)
            renderRelatedMarkets(poll, 'Trending');

            // Render comments
            // Comments will be loaded when Comments tab is clicked
            // Top Holders is shown by default
            
            console.log('Poll detail page opened successfully');
            } catch (error) {
                console.error('Error opening poll detail:', error);
                console.error('Error stack:', error.stack);
                alert('Error opening poll: ' + error.message + '\n\nCheck console for details.');
            }
        }
        
        // Chart rendering function
        function renderProbabilityChart(poll, percentages) {
            const canvas = document.getElementById('chartCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Find the winning percentage (highest)
            const maxPercentage = Math.max(...percentages);
            const allZero = maxPercentage === 0;
            
            // Draw probability lines (simplified - just show current percentages)
            percentages.forEach((pct, idx) => {
                const y = height - (pct / 100) * height;
                // Gray if all 0% (new poll), green if winning (highest percentage), red if losing
                const color = allZero ? '#8b949e' : (pct === maxPercentage ? '#10b981' : '#ef4444');
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
                
                // Add label
                ctx.fillStyle = color;
                ctx.font = '12px sans-serif';
                ctx.fillText(`${poll.outcomes[idx]}: ${pct}%`, 10, y - 5);
            });
        }
        
        // Change chart time range
        function changeChartTimeRange(range) {
            // Update button states
            document.querySelectorAll('#probabilityChart button').forEach(btn => {
                btn.classList.remove('text-white', 'bg-gray-800');
                btn.classList.add('text-gray-400');
            });
            event.target.classList.remove('text-gray-400');
            event.target.classList.add('text-white', 'bg-gray-800');
            
            // In a real implementation, this would fetch and render different time ranges
            console.log('Chart time range changed to:', range);
        }
        
        // Current related tab state
        let currentRelatedTab = 'Trending';
        
        // Set related tab (make globally accessible)
        window.setRelatedTab = function setRelatedTab(tab) {
            currentRelatedTab = tab;
            
            // Update button states
            const trendingTab = document.getElementById('relatedTabTrending');
            const relatedTab = document.getElementById('relatedTabRelated');
            
            if (trendingTab && relatedTab) {
                if (tab === 'Trending') {
                    // Update Trending tab
                    trendingTab.style.background = 'linear-gradient(135deg, #9333ea 0%, #7c3aed 100%)';
                    trendingTab.style.boxShadow = '0 2px 8px rgba(147, 51, 234, 0.3)';
                    trendingTab.classList.remove('text-gray-400', 'hover:bg-gray-800');
                    trendingTab.classList.add('text-white');
                    // Update Related tab
                    relatedTab.style.background = '';
                    relatedTab.style.boxShadow = '';
                    relatedTab.classList.remove('text-white');
                    relatedTab.classList.add('text-gray-400', 'hover:bg-gray-800');
                } else {
                    // Update Related tab
                    relatedTab.style.background = 'linear-gradient(135deg, #9333ea 0%, #7c3aed 100%)';
                    relatedTab.style.boxShadow = '0 2px 8px rgba(147, 51, 234, 0.3)';
                    relatedTab.classList.remove('text-gray-400', 'hover:bg-gray-800');
                    relatedTab.classList.add('text-white');
                    // Update Trending tab
                    trendingTab.style.background = '';
                    trendingTab.style.boxShadow = '';
                    trendingTab.classList.remove('text-white');
                    trendingTab.classList.add('text-gray-400', 'hover:bg-gray-800');
                }
            }
            
            // Re-render with new tab
            if (currentPollId) {
                const poll = markets.find(m => m.id === currentPollId || m.id === currentPollId.toString());
                if (poll) {
                    renderRelatedMarkets(poll, tab);
                }
            }
        }
        
        // Render related markets
        function renderRelatedMarkets(currentPoll, tab = 'Trending') {
            const relatedEl = document.getElementById('relatedMarkets');
            if (!relatedEl) return;
            
            let related = [];
            
            if (tab === 'Trending') {
                // Get top 3 polls sorted by creation date (most recent first)
                related = markets
                    .filter(m => m.id !== currentPoll.id)
                    .sort((a, b) => {
                        const dateA = new Date(a.createdAt || 0);
                        const dateB = new Date(b.createdAt || 0);
                        return dateB - dateA; // Most recent first
                    })
                    .slice(0, 3);
            } else if (tab === 'Related') {
                // Get top 3 polls from the same category
                if (currentPoll.category) {
                    related = markets
                        .filter(m => m.id !== currentPoll.id && m.category === currentPoll.category)
                        .sort((a, b) => {
                            const dateA = new Date(a.createdAt || 0);
                            const dateB = new Date(b.createdAt || 0);
                            return dateB - dateA; // Most recent first
                        })
                        .slice(0, 3);
                } else {
                    related = [];
                }
            }
            
            if (related.length === 0) {
                relatedEl.innerHTML = `
                    <div class="text-center py-8">
                        <div class="text-4xl mb-3 opacity-50">üîç</div>
                        <p class="text-gray-400 text-sm">No related markets found</p>
                    </div>
                `;
                return;
            }
            
            relatedEl.innerHTML = related.map(market => {
                // Always use category emoji first to ensure consistency within categories
                // Then fall back to saved emoji or title-based guess
                const emoji = (market.category && categoryEmojis[market.category]) || market.emoji || getMarketEmoji(market.title);
                return `
                    <div class="group flex items-center gap-4 p-4 rounded-xl cursor-pointer transition-all duration-200 ease-in-out transform hover:scale-[1.02] hover:shadow-lg" 
                         style="background-color: #0d1117; border: 1px solid #30363d; border-left: 3px solid transparent;"
                         onmouseenter="this.style.borderLeftColor='#9333ea'; this.style.backgroundColor='#161b22'; this.style.boxShadow='0 4px 12px rgba(147, 51, 234, 0.15)';"
                         onmouseleave="this.style.borderLeftColor='transparent'; this.style.backgroundColor='#0d1117'; this.style.boxShadow='none';"
                         onclick="openPollDetail('${market.id}')">
                        <div class="flex-shrink-0 w-12 h-12 rounded-xl flex items-center justify-center text-2xl transition-transform duration-200 group-hover:scale-110" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2) 0%, rgba(124, 58, 237, 0.2) 100%); border: 1px solid rgba(147, 51, 234, 0.3);">
                            ${emoji}
                        </div>
                        <div class="flex-1 min-w-0">
                            <p class="text-sm text-white font-medium line-clamp-2 group-hover:text-purple-300 transition-colors duration-200">${market.title}</p>
                        </div>
                        <div class="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                            <svg class="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                            </svg>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Selected outcome for trading
        let selectedOutcomeIndex = null;
        let selectedOutcomeName = null;
        let selectedOutcomePrice = null;
        let selectedMarketAddress = null;
        
        // Select outcome for trading and open modal
        function selectOutcomeForTrade(outcomeIndex, outcomeName, price) {
            console.log('selectOutcomeForTrade called:', { outcomeIndex, outcomeName, price, currentPollId });
            selectedOutcomeIndex = outcomeIndex;
            selectedOutcomeName = outcomeName;
            selectedOutcomePrice = price;
            
            // Get poll data
            const poll = markets.find(m => m.id === currentPollId);
            if (!poll) {
                console.error('Poll not found for currentPollId:', currentPollId);
                alert('Poll not found. Please try again.');
                return;
            }
            
            // Store market address for trading
            if (poll.address) {
                selectedMarketAddress = poll.address;
            } else if (poll.id) {
                // Fallback to using poll ID if address not available
                selectedMarketAddress = poll.id;
            }
            
            // Get emoji
            const emoji = (poll.category && categoryEmojis[poll.category]) || poll.emoji || getMarketEmoji(poll.title);
            
            // Update modal title and emoji
            const modalTitle = document.getElementById('tradingModalTitle');
            const modalEmoji = document.getElementById('tradingModalEmoji');
            if (modalTitle) modalTitle.textContent = outcomeName;
            if (modalEmoji) modalEmoji.textContent = emoji;
            
            // Populate all outcomes in modal
            const modalOutcomes = document.getElementById('tradingModalOutcomes');
            if (modalOutcomes && poll.outcomes) {
                modalOutcomes.innerHTML = '';
                
                // Calculate percentages
                const totalVolume = poll.volume || 0;
                let percentages = poll.percentages || [];
                
                if (totalVolume === 0) {
                    percentages = poll.outcomes.map(() => 0);
                } else if (!percentages || percentages.length !== poll.outcomes.length) {
                    percentages = poll.outcomes.map(() => Math.random() * 100);
                    const sum = percentages.reduce((a, b) => a + b, 0);
                    percentages = percentages.map(p => Math.round((p / sum) * 100));
                }
                
                poll.outcomes.forEach((outcome, idx) => {
                    const percentage = percentages[idx] || 0;
                    const outcomePrice = (percentage / 100).toFixed(2);
                    const isSelected = idx === outcomeIndex;
                    
                    const btn = document.createElement('button');
                    btn.className = 'w-full p-3 rounded-lg font-semibold text-white text-center mb-2';
                    btn.style.cssText = isSelected ? 'background-color: #10b981;' : 'background-color: #6b7280;';
                    btn.textContent = `${outcome} ${outcomePrice}¬¢`;
                    btn.onclick = () => {
                        selectOutcomeForTrade(idx, outcome, outcomePrice);
                    };
                    modalOutcomes.appendChild(btn);
                });
            }
            
            // Open modal (setTradeMode will be called in openTradingModal to set Buy as default)
            openTradingModal();
        }
        
        // Open trading modal (can be called from card with marketId, outcomeIndex, outcomeName)
        function openTradingModal(marketId, outcomeIndex, outcomeName) {
            // If called from card, set the selected outcome
            if (marketId && outcomeIndex !== undefined) {
                currentPollId = marketId;
                selectedOutcomeIndex = outcomeIndex;
                selectedOutcomeName = outcomeName || '';
                // Open poll detail first if not already open
                const poll = markets.find(m => m.id === marketId);
                if (poll) {
                    // Ensure poll detail is open
                    const detailPage = document.getElementById('pollDetailPage');
                    if (!detailPage || detailPage.style.display === 'none') {
                        openPollDetail(marketId);
                    }
                }
            }
            const modal = document.getElementById('tradingModal');
            if (modal) {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                modal.style.display = 'flex'; // Ensure it's visible
                // Reset amount
                currentTradeAmount = 0;
                const amountInput = document.getElementById('modalTradeAmount');
                if (amountInput) amountInput.value = '$0';
                
                // Set up button event listeners (remove old ones first)
                let buyBtn = document.getElementById('modalBuyBtn');
                let sellBtn = document.getElementById('modalSellBtn');
                
                if (buyBtn) {
                    // Clone to remove all event listeners
                    const newBuyBtn = buyBtn.cloneNode(true);
                    buyBtn.parentNode.replaceChild(newBuyBtn, buyBtn);
                    // Get the new button reference
                    buyBtn = document.getElementById('modalBuyBtn');
                    buyBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Buy button clicked');
                        setTradeMode('buy');
                    }, true); // Use capture phase
                }
                
                if (sellBtn) {
                    // Clone to remove all event listeners
                    const newSellBtn = sellBtn.cloneNode(true);
                    sellBtn.parentNode.replaceChild(newSellBtn, sellBtn);
                    // Get the new button reference
                    sellBtn = document.getElementById('modalSellBtn');
                    sellBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Sell button clicked');
                        setTradeMode('sell');
                    }, true); // Use capture phase
                }
                
                // Set up amount buttons with event listeners
                const addAmount1Btn = document.getElementById('addAmount1');
                const addAmount20Btn = document.getElementById('addAmount20');
                const addAmount100Btn = document.getElementById('addAmount100');
                const setMaxAmountBtn = document.getElementById('setMaxAmountBtn');
                
                if (addAmount1Btn) {
                    // Clone to remove old listeners
                    const newBtn = addAmount1Btn.cloneNode(true);
                    addAmount1Btn.parentNode.replaceChild(newBtn, addAmount1Btn);
                    document.getElementById('addAmount1').addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('+$1 button clicked');
                        addTradeAmount(1);
                    }, true);
                }
                
                if (addAmount20Btn) {
                    const newBtn = addAmount20Btn.cloneNode(true);
                    addAmount20Btn.parentNode.replaceChild(newBtn, addAmount20Btn);
                    document.getElementById('addAmount20').addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('+$20 button clicked');
                        addTradeAmount(20);
                    }, true);
                }
                
                if (addAmount100Btn) {
                    const newBtn = addAmount100Btn.cloneNode(true);
                    addAmount100Btn.parentNode.replaceChild(newBtn, addAmount100Btn);
                    document.getElementById('addAmount100').addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('+$100 button clicked');
                        addTradeAmount(100);
                    }, true);
                }
                
                if (setMaxAmountBtn) {
                    const newBtn = setMaxAmountBtn.cloneNode(true);
                    setMaxAmountBtn.parentNode.replaceChild(newBtn, setMaxAmountBtn);
                    document.getElementById('setMaxAmountBtn').addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Max button clicked');
                        setMaxAmount();
                    }, true);
                }
                
                // Set up close button
                const closeBtn = document.getElementById('closeTradingModalBtn');
                if (closeBtn) {
                    // Clone to remove old listeners
                    const newCloseBtn = closeBtn.cloneNode(true);
                    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
                    document.getElementById('closeTradingModalBtn').addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Close button clicked');
                        closeTradingModal();
                    }, true);
                }
                
                // Set Buy as default mode (must be called after modal is visible and buttons are set up)
                setTimeout(() => {
                    setTradeMode('buy');
                }, 100);
                
                console.log('Trading modal opened successfully');
            } else {
                console.error('Trading modal not found in DOM');
                alert('Trading modal not found. Please refresh the page.');
            }
        }
        
        // Close trading modal
        function closeTradingModal() {
            console.log('closeTradingModal called');
            const modal = document.getElementById('tradingModal');
            if (modal) {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                modal.style.display = 'none';
                console.log('Trading modal closed');
            } else {
                console.error('Trading modal not found');
            }
        }
        
        // Trading functions (variables already declared globally)
        function setTradeMode(mode) {
            console.log('setTradeMode called with mode:', mode);
            tradeMode = mode;
            
            // Update owned shares display
            const ownedSharesDisplay = document.getElementById('ownedSharesDisplay');
            if (mode === 'sell' && currentPollId !== null && selectedOutcomeIndex !== null) {
                const ownedShares = calculateUserShares(currentPollId, selectedOutcomeIndex);
                if (ownedSharesDisplay) {
                    ownedSharesDisplay.style.display = 'block';
                    ownedSharesDisplay.textContent = `Owned: $${ownedShares.toFixed(2)}`;
                    ownedSharesDisplay.style.color = ownedShares > 0 ? '#10b981' : '#ef4444';
                }
            } else {
                if (ownedSharesDisplay) {
                    ownedSharesDisplay.style.display = 'none';
                }
            }
            
            // Update Trade button text
            const confirmTradeBtn = document.getElementById('confirmTradeBtn');
            if (confirmTradeBtn) {
                if (mode === 'buy') {
                    confirmTradeBtn.textContent = 'Buy';
                    confirmTradeBtn.style.backgroundColor = '#2563eb'; // Blue for buy
                } else {
                    confirmTradeBtn.textContent = 'Sell';
                    confirmTradeBtn.style.backgroundColor = '#ef4444'; // Red for sell
                }
            }
            
            const buyBtn = document.getElementById('modalBuyBtn');
            const sellBtn = document.getElementById('modalSellBtn');
            
            if (!buyBtn || !sellBtn) {
                console.error('Buy or Sell button not found', { buyBtn: !!buyBtn, sellBtn: !!sellBtn });
                return;
            }
            
            console.log('Applying styles for mode:', mode);
            
            if (mode === 'buy') {
                // Buy button active - purple with blue border
                buyBtn.style.setProperty('background-color', '#9333ea', 'important');
                buyBtn.style.setProperty('border', '2px solid #3b82f6', 'important');
                buyBtn.style.setProperty('color', 'white', 'important');
                buyBtn.classList.add('text-white');
                buyBtn.classList.remove('text-gray-400');
                
                // Sell button inactive - dark with gray border
                sellBtn.style.setProperty('background-color', '#0d1117', 'important');
                sellBtn.style.setProperty('border', '1px solid #30363d', 'important');
                sellBtn.style.setProperty('color', '#9ca3af', 'important');
                sellBtn.classList.remove('text-white');
                sellBtn.classList.add('text-gray-400');
            } else {
                // Sell button active - purple with blue border
                sellBtn.style.setProperty('background-color', '#9333ea', 'important');
                sellBtn.style.setProperty('border', '2px solid #3b82f6', 'important');
                sellBtn.style.setProperty('color', 'white', 'important');
                sellBtn.classList.add('text-white');
                sellBtn.classList.remove('text-gray-400');
                
                // Buy button inactive - dark with gray border
                buyBtn.style.setProperty('background-color', '#0d1117', 'important');
                buyBtn.style.setProperty('border', '1px solid #30363d', 'important');
                buyBtn.style.setProperty('color', '#9ca3af', 'important');
                buyBtn.classList.remove('text-white');
                buyBtn.classList.add('text-gray-400');
            }
            
            console.log('Styles applied. Buy bg:', buyBtn.style.backgroundColor, 'Sell bg:', sellBtn.style.backgroundColor);
        }
        
        function addTradeAmount(amount) {
            console.log('addTradeAmount called with:', amount, 'currentTradeAmount:', currentTradeAmount);
            // Parse current amount from input or use variable
            const amountInput = document.getElementById('modalTradeAmount');
            if (amountInput) {
                // Extract numeric value from input (remove $ and parse)
                const currentValue = parseFloat(amountInput.value.replace('$', '')) || 0;
                currentTradeAmount = currentValue + amount;
                amountInput.value = `$${currentTradeAmount}`;
                console.log('Updated amount to:', currentTradeAmount);
            } else {
                console.error('Amount input not found');
            }
        }
        
        // Calculate user's owned shares for a specific outcome in a market
        function calculateUserShares(marketId, outcomeIndex) {
            if (!marketId || outcomeIndex === null || outcomeIndex === undefined) {
                return 0;
            }
            
            // Get user address
            let userAddress = localStorage.getItem('userAddress');
            if (!userAddress) {
                const loginData = localStorage.getItem('userLogin');
                if (loginData) {
                    try {
                        const data = JSON.parse(loginData);
                        userAddress = data.identifier || data.userAddress || data.address;
                    } catch (e) {
                        console.warn('Error parsing login data:', e);
                    }
                }
            }
            
            if (!userAddress) {
                return 0;
            }
            
            // Normalize user address
            const normalizedUserAddress = userAddress.toLowerCase();
            
            // Get trade history
            const tradeHistory = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
            
            // Calculate net shares: sum of buys minus sum of sells
            let totalShares = 0;
            tradeHistory.forEach(trade => {
                const tradeAddress = (trade.userAddress || '').toLowerCase();
                if (tradeAddress === normalizedUserAddress && 
                    trade.marketId === marketId && 
                    trade.outcomeIndex === outcomeIndex) {
                    if (trade.tradeType === 'buy') {
                        totalShares += parseFloat(trade.amount || 0);
                    } else if (trade.tradeType === 'sell') {
                        totalShares -= parseFloat(trade.amount || 0);
                    }
                }
            });
            
            return Math.max(0, totalShares); // Can't have negative shares
        }
        
        function setMaxAmount() {
            console.log('setMaxAmount called');
            
            if (tradeMode === 'sell' && currentPollId !== null && selectedOutcomeIndex !== null) {
                // For selling, use owned shares
                const ownedShares = calculateUserShares(currentPollId, selectedOutcomeIndex);
                currentTradeAmount = ownedShares;
                console.log('Set max amount to owned shares:', ownedShares);
            } else {
                // For buying, use placeholder (in production, use user balance)
                currentTradeAmount = 1000;
                console.log('Set max amount to:', currentTradeAmount);
            }
            
            const amountInput = document.getElementById('modalTradeAmount');
            if (amountInput) {
                amountInput.value = `$${currentTradeAmount}`;
                console.log('Set max amount to:', currentTradeAmount);
            } else {
                console.error('Amount input not found');
            }
        }
        
        async function executeTrade() {
            const amount = document.getElementById('modalTradeAmount');
            
            if (!amount || !amount.value || amount.value === '$0') {
                alert('Please enter an amount');
                return;
            }
            
            if (selectedOutcomeIndex === null || !selectedOutcomeName || !selectedMarketAddress) {
                alert('Please select an outcome to trade');
                return;
            }
            
            // For selling, check if user has enough shares
            if (tradeMode === 'sell') {
                const ownedShares = calculateUserShares(currentPollId, selectedOutcomeIndex);
                if (ownedShares <= 0) {
                    alert('You don\'t own any shares of this outcome to sell.');
                    return;
                }
                if (parseFloat(currentTradeAmount) > ownedShares) {
                    alert(`You only own $${ownedShares.toFixed(2)} worth of shares. You cannot sell more than you own.`);
                    return;
                }
            }
            
            // Get user address from localStorage (check multiple sources)
            let userAddress = localStorage.getItem('userAddress');
            if (!userAddress) {
                // Try to get from login data
                const loginData = localStorage.getItem('userLogin');
                if (loginData) {
                    try {
                        const data = JSON.parse(loginData);
                        userAddress = data.identifier || data.userAddress || data.address;
                    } catch (e) {
                        console.warn('Error parsing login data:', e);
                    }
                }
            }
            if (!userAddress) {
                alert('Please log in to trade');
                return;
            }
            
            // Check if backend is available, if not use local simulation
            const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
            let useBackend = false;
            
            try {
                // Try to ping backend first
                const pingResponse = await fetch(`${API_URL}/api/health`, { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) // 2 second timeout
                });
                useBackend = pingResponse.ok;
            } catch (e) {
                console.log('Backend not available, using local simulation');
                useBackend = false;
            }
            
            if (useBackend && selectedMarketAddress) {
                // Use backend API
                try {
                    const response = await fetch(`${API_URL}/api/markets/${selectedMarketAddress}/trade`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userAddress: userAddress,
                        outcomeIndex: selectedOutcomeIndex,
                        tradeType: tradeMode, // 'buy' or 'sell'
                        amount: currentTradeAmount
                    })
                });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                
                const data = await response.json();
                
                    if (tradeMode === 'buy') {
                        alert(`Successfully bought $${currentTradeAmount} worth of shares for "${selectedOutcomeName}"`);
                    } else {
                        alert(`Successfully sold $${currentTradeAmount} worth of shares for "${selectedOutcomeName}"`);
                    }
                    
                    // Refresh the poll detail page to show updated data
                    if (currentPollId) {
                        openPollDetail(currentPollId);
                }
            } catch (error) {
                console.error('Trade execution error:', error);
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        alert(`Cannot connect to backend server. Please make sure the backend is running on ${API_URL}`);
                    } else {
                alert(`Trade failed: ${error.message}`);
                    }
                }
            } else {
                // Local simulation mode - update localStorage
                const poll = markets.find(m => m.id === currentPollId);
                if (!poll) {
                    alert('Poll not found');
                    return;
                }
                
                // Update poll volume
                const currentVolume = parseFloat(poll.volume) || 0;
                if (tradeMode === 'buy') {
                    poll.volume = currentVolume + parseFloat(currentTradeAmount);
                } else {
                    poll.volume = Math.max(0, currentVolume - parseFloat(currentTradeAmount));
                }
                
                // Initialize percentages if needed
                if (!poll.percentages || poll.percentages.length !== poll.outcomes.length) {
                    poll.percentages = poll.outcomes.map(() => 0);
                }
                
                // Calculate new percentages based on volume distribution
                // Track volume per outcome (simplified - assume equal distribution initially, then adjust)
                if (!poll.outcomeVolumes) {
                    poll.outcomeVolumes = poll.outcomes.map(() => 0);
                }
                
                // Update volume for selected outcome
                if (tradeMode === 'buy') {
                    poll.outcomeVolumes[selectedOutcomeIndex] = (poll.outcomeVolumes[selectedOutcomeIndex] || 0) + parseFloat(currentTradeAmount);
                } else {
                    poll.outcomeVolumes[selectedOutcomeIndex] = Math.max(0, (poll.outcomeVolumes[selectedOutcomeIndex] || 0) - parseFloat(currentTradeAmount));
                }
                
                // Recalculate percentages based on outcome volumes
                const totalVolume = parseFloat(poll.volume) || 0;
                if (totalVolume > 0) {
                    poll.percentages = poll.outcomeVolumes.map(vol => {
                        return Math.round((parseFloat(vol) / totalVolume) * 100);
                    });
                    
                    // Normalize to ensure they sum to 100
                    const sum = poll.percentages.reduce((a, b) => a + b, 0);
                    if (sum !== 100 && sum > 0) {
                        const diff = 100 - sum;
                        // Add difference to the selected outcome
                        poll.percentages[selectedOutcomeIndex] += diff;
                    }
                } else {
                    poll.percentages = poll.outcomes.map(() => 0);
                }
                
                // Ensure percentages are valid (0-100)
                poll.percentages = poll.percentages.map(p => Math.max(0, Math.min(100, p)));
                
                // Save to localStorage
                saveMarketsToStorage();
                
                // Save trade to history for position tracking
                // Ensure userAddress is set correctly and normalized
                let tradeUserAddress = userAddress ? userAddress.toLowerCase() : null;
                if (!tradeUserAddress) {
                    // Try to get from login data
                    const loginData = localStorage.getItem('userLogin');
                    if (loginData) {
                        try {
                            const loginDataObj = JSON.parse(loginData);
                            tradeUserAddress = (loginDataObj.userAddress || loginDataObj.identifier || '').toLowerCase();
                        } catch (e) {
                            console.warn('Error parsing login data for trade:', e);
                        }
                    }
                }
                
                if (tradeUserAddress) {
                    const tradeHistory = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
                    tradeHistory.push({
                        marketId: currentPollId,
                        userAddress: tradeUserAddress,
                        outcomeIndex: selectedOutcomeIndex,
                        outcomeName: selectedOutcomeName,
                        tradeType: tradeMode,
                        amount: currentTradeAmount,
                        timestamp: new Date().toISOString()
                    });
                    localStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
                    console.log('Trade saved to history:', { marketId: currentPollId, userAddress: tradeUserAddress, amount: currentTradeAmount, outcomeIndex: selectedOutcomeIndex });
                } else {
                    console.warn('Could not save trade - no user address found');
                }
                
                // Update the markets array reference (create new object to ensure reactivity)
                const pollIndex = markets.findIndex(m => m.id === currentPollId);
                if (pollIndex !== -1) {
                    // Create a new object to ensure the reference changes
                    markets[pollIndex] = { ...poll };
                }
                
                // Also update the poll variable used in openPollDetail
                const updatedPoll = markets.find(m => m.id === currentPollId);
                if (updatedPoll) {
                    Object.assign(updatedPoll, poll);
                }
                
                if (tradeMode === 'buy') {
                    alert(`‚úÖ Successfully bought $${currentTradeAmount} worth of shares for "${selectedOutcomeName}"`);
                } else {
                    alert(`‚úÖ Successfully sold $${currentTradeAmount} worth of shares for "${selectedOutcomeName}"`);
                }
                
                // Close trading modal
                if (window.closeTradingModal) {
                    window.closeTradingModal();
                }
                
                // Refresh dashboard if it's open
                const dashboard = document.getElementById('userDashboard');
                if (dashboard && dashboard.style.display !== 'none') {
                    // Reload dashboard data to show updated positions
                    setTimeout(() => {
                        if (typeof loadDashboardData === 'function') {
                            loadDashboardData();
                        }
                    }, 200);
                }
                
                // Refresh the poll detail page to show updated data
                if (currentPollId) {
                    // Small delay to ensure modal closes first
                    setTimeout(() => {
                        openPollDetail(currentPollId);
                    }, 100);
                }
            }
        }

        function closePollDetail() {
            // Don't close if dashboard is open
            const dashboard = document.getElementById('userDashboard');
            const dashboardIsOpen = dashboard && (
                dashboard.style.display !== 'none' && 
                window.getComputedStyle(dashboard).display !== 'none'
            );
            
            if (dashboardIsOpen) {
                console.log('Dashboard is open, preventing closePollDetail from showing homepage');
                return;
            }
            
            // Clear countdown interval when closing poll detail
            if (window.pollCountdownInterval) {
                clearInterval(window.pollCountdownInterval);
                window.pollCountdownInterval = null;
            }
            // Update URL back to homepage
            window.history.pushState({}, '', window.location.pathname);
            
            const detailPage = document.getElementById('pollDetailPage');
            const mainContent = document.querySelector('main');
            
            if (detailPage) {
                detailPage.style.display = 'none';
            }
            if (mainContent) mainContent.style.display = 'block';
            currentPollId = null;
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            // Check if Help & Support page is currently open - if so, keep it open
            const helpSupportPage = document.getElementById('helpSupportPage');
            const helpSupportIsOpen = helpSupportPage && (
                helpSupportPage.style.display !== 'none' && 
                window.getComputedStyle(helpSupportPage).display !== 'none'
            );
            
            if (helpSupportIsOpen || (event.state && event.state.page === 'help-support')) {
                console.log('Help & Support page is open, preventing popstate from closing it');
                // Keep Help & Support page open
                const mainContent = document.querySelector('main');
                const pollDetailPage = document.getElementById('pollDetailPage');
                const dashboard = document.getElementById('userDashboard');
                const settingsPage = document.getElementById('settingsPage');
                const howItWorksPage = document.getElementById('howItWorksPage');
                
                if (mainContent) mainContent.style.display = 'none';
                if (pollDetailPage) pollDetailPage.style.display = 'none';
                if (dashboard) dashboard.style.display = 'none';
                if (settingsPage) settingsPage.style.display = 'none';
                if (howItWorksPage) {
                    howItWorksPage.style.display = 'none';
                    howItWorksPage.style.visibility = 'hidden';
                }
                if (helpSupportPage) {
                    helpSupportPage.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 64px !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 10001 !important; background-color: #0d1117 !important; overflow-y: auto !important; width: 100% !important; min-height: calc(100vh - 64px) !important;';
                }
                return;
            }
            
            // Check if help page (How It Works) is currently open - if so, keep it open
            const howItWorksPage = document.getElementById('howItWorksPage');
            const helpPageIsOpen = howItWorksPage && (
                howItWorksPage.style.display !== 'none' && 
                window.getComputedStyle(howItWorksPage).display !== 'none'
            );
            
            if (helpPageIsOpen || (event.state && event.state.page === 'help')) {
                console.log('Help page is open, preventing popstate from closing it');
                // Keep help page open
                const mainContent = document.querySelector('main');
                const pollDetailPage = document.getElementById('pollDetailPage');
                const dashboard = document.getElementById('userDashboard');
                const settingsPage = document.getElementById('settingsPage');
                
                if (mainContent) mainContent.style.display = 'none';
                if (pollDetailPage) pollDetailPage.style.display = 'none';
                if (dashboard) dashboard.style.display = 'none';
                if (settingsPage) settingsPage.style.display = 'none';
                if (helpSupportPage) {
                    helpSupportPage.style.display = 'none';
                    helpSupportPage.style.visibility = 'hidden';
                }
                if (howItWorksPage) {
                    howItWorksPage.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; width: 100% !important; min-height: 100vh !important; background-color: #0d1117 !important; overflow-y: auto !important; z-index: 1 !important;';
                }
                return;
            }
            
            // Check if dashboard is currently open - if so, keep it open
            const dashboard = document.getElementById('userDashboard');
            const dashboardIsOpen = dashboard && (
                dashboard.style.display !== 'none' && 
                window.getComputedStyle(dashboard).display !== 'none'
            );
            
            if (dashboardIsOpen) {
                console.log('Dashboard is open, preventing popstate from closing it');
                // Keep dashboard open
                const mainContent = document.querySelector('main');
                const pollDetailPage = document.getElementById('pollDetailPage');
                
                if (mainContent) mainContent.style.display = 'none';
                if (pollDetailPage) pollDetailPage.style.display = 'none';
                dashboard.style.display = 'block';
                return;
            }
            
            // Check if dashboard should be open (from state)
            if (event.state && event.state.page === 'dashboard') {
                // Keep dashboard open
                const mainContent = document.querySelector('main');
                const pollDetailPage = document.getElementById('pollDetailPage');
                
                if (dashboard) {
                    if (mainContent) mainContent.style.display = 'none';
                    if (pollDetailPage) pollDetailPage.style.display = 'none';
                    dashboard.style.display = 'block';
                    if (typeof loadDashboardData === 'function') {
                        loadDashboardData();
                    }
                }
                return;
            }
            
            const urlParams = new URLSearchParams(window.location.search);
            const pollId = urlParams.get('poll');
            
            if (pollId) {
                openPollDetail(pollId);
            } else {
                closePollDetail();
            }
        });
        
        // Check URL on page load
        function checkUrlForPoll() {
            // Don't interfere if dashboard is open
            const dashboard = document.getElementById('userDashboard');
            if (dashboard && dashboard.style.display !== 'none' && window.getComputedStyle(dashboard).display !== 'none') {
                console.log('Dashboard is open, skipping URL check');
                return;
            }
            
            const urlParams = new URLSearchParams(window.location.search);
            const pollId = urlParams.get('poll');
            
            if (pollId) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    openPollDetail(pollId);
                }, 100);
            }
        }

        // Chart rendering function
        function renderProbabilityChart(poll, percentages) {
            const canvas = document.getElementById('chartCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Find the winning percentage (highest)
            const maxPercentage = Math.max(...percentages);
            const allZero = maxPercentage === 0;
            
            // Draw probability lines (simplified - just show current percentages)
            percentages.forEach((pct, idx) => {
                const y = height - (pct / 100) * height;
                // Gray if all 0% (new poll), green if winning (highest percentage), red if losing
                const color = allZero ? '#8b949e' : (pct === maxPercentage ? '#10b981' : '#ef4444');
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
                
                // Add label
                ctx.fillStyle = color;
                ctx.font = '12px sans-serif';
                ctx.fillText(`${poll.outcomes[idx]}: ${pct}%`, 10, y - 5);
            });
        }
        
        // Change chart time range
        function changeChartTimeRange(range) {
            // Update button states
            document.querySelectorAll('#probabilityChart button').forEach(btn => {
                btn.classList.remove('text-white', 'bg-gray-800');
                btn.classList.add('text-gray-400');
            });
            event.target.classList.remove('text-gray-400');
            event.target.classList.add('text-white', 'bg-gray-800');
            
            // In a real implementation, this would fetch and render different time ranges
            console.log('Chart time range changed to:', range);
        }
        
        // Trading functions - duplicate removed, using the one above
        
        // Duplicate function removed - using the one above
        
        // Removed duplicate executeTrade function - using the async one above
        
        function showMoreRules() {
            alert('Full rules will be displayed here');
        }

        // Tab switching for Comments/Top Holders
        function setCommentsTab(tab) {
            const topHoldersTab = document.getElementById('topHoldersTab');
            const commentsTab = document.getElementById('commentsTab');
            const topHoldersContent = document.getElementById('topHoldersContent');
            const commentsContent = document.getElementById('commentsContent');
            
            if (tab === 'topHolders') {
                topHoldersTab.classList.add('text-white', 'border-b-2', 'border-white');
                topHoldersTab.classList.remove('text-gray-400');
                commentsTab.classList.remove('text-white', 'border-b-2', 'border-white');
                commentsTab.classList.add('text-gray-400');
                topHoldersContent.style.display = 'block';
                commentsContent.style.display = 'none';
                loadTopHolders();
            } else {
                commentsTab.classList.add('text-white', 'border-b-2', 'border-white');
                commentsTab.classList.remove('text-gray-400');
                topHoldersTab.classList.remove('text-white', 'border-b-2', 'border-white');
                topHoldersTab.classList.add('text-gray-400');
                topHoldersContent.style.display = 'none';
                commentsContent.style.display = 'block';
                loadComments();
            }
        }
        
        // Load top holders
        async function loadTopHolders() {
            if (!currentPollId) {
                console.warn('loadTopHolders: No currentPollId');
                return;
            }
            
            const poll = markets.find(m => m.id === currentPollId || m.id === currentPollId.toString());
            if (!poll) {
                console.warn('loadTopHolders: Poll not found for id:', currentPollId);
                return;
            }
            
            // Use poll.id as address if address doesn't exist (for local markets)
            const marketAddress = poll.address || poll.id;
            console.log('loadTopHolders: Loading for market:', marketAddress);
            
            const topHoldersContent = document.getElementById('topHoldersContent');
            if (!topHoldersContent) {
                console.warn('loadTopHolders: topHoldersContent element not found');
                return;
            }
            
            // Show loading state
            topHoldersContent.innerHTML = '<p class="text-gray-400 text-center py-8">Loading...</p>';
            
            try {
                const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                const response = await fetch(`${API_URL}/api/markets/${encodeURIComponent(marketAddress)}/top-holders`);
                
                if (!response.ok) {
                    // If backend is not available or no holders found, show blank
                    if (response.status === 0 || response.status >= 500) {
                        console.warn('Backend unavailable, showing blank top holders');
                        topHoldersContent.innerHTML = '';
                        return;
                    }
                    // For 404 or other errors, also show blank
                    if (response.status === 404) {
                        console.log('No top holders found for this market');
                        topHoldersContent.innerHTML = '';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const topHolders = await response.json();
                console.log('Top holders received:', topHolders);
                
                if (!topHolders || topHolders.length === 0) {
                    // Show blank if no holders
                    topHoldersContent.innerHTML = '';
                    return;
                }
            
                topHoldersContent.innerHTML = topHolders.slice(0, 5).map((holder, index) => {
                    const address = holder.userAddress || holder.address || 'Unknown';
                    const username = holder.username || 'Unknown User';
                    const shares = parseInt(holder.totalShares || 0);
                    const initial = username.charAt(0).toUpperCase();
                    const rank = index + 1;
                    const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
                    const rankColor = rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#8b949e';
                    
                    return `
                    <div class="flex items-center justify-between py-2 px-2 rounded hover:bg-gray-800 transition-colors" style="background-color: #0d1117; border-bottom: 1px solid #30363d;">
                        <div class="flex items-center gap-2 flex-1 min-w-0">
                            <div class="flex-shrink-0 w-6 text-center">
                                <span class="text-xs font-bold" style="color: ${rankColor};">${medal || rank}</span>
                            </div>
                            <div class="w-7 h-7 rounded-full flex items-center justify-center text-white font-semibold text-xs flex-shrink-0" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);">
                                ${initial}
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-white font-medium text-sm truncate">${username}</p>
                                <p class="text-gray-400 text-xs truncate">${address.length > 10 ? `${address.slice(0, 4)}...${address.slice(-3)}` : address}</p>
                            </div>
                        </div>
                        <div class="text-right flex-shrink-0 ml-2">
                            <p class="text-white font-semibold text-sm">${shares.toLocaleString()}</p>
                            <p class="text-gray-400 text-xs">votes</p>
                        </div>
                    </div>
                `;
                }).join('');
            } catch (error) {
                console.error('Error loading top holders:', error);
                // Show blank on error - no fake data
                topHoldersContent.innerHTML = '';
            }
        }
        
        // Display fake top holders for visibility
        function displayFakeTopHolders(container) {
            const fakeHolders = [
                { username: 'Alice Trader', userAddress: '0x1111...1111', totalShares: 1250 },
                { username: 'Bob Investor', userAddress: '0x2222...2222', totalShares: 980 },
                { username: 'Charlie Crypto', userAddress: '0x3333...3333', totalShares: 875 },
                { username: 'Diana DeFi', userAddress: '0x4444...4444', totalShares: 720 },
                { username: 'Eve Exchange', userAddress: '0x5555...5555', totalShares: 650 }
            ];
            
            container.innerHTML = fakeHolders.map((holder, index) => {
                const initial = holder.username.charAt(0).toUpperCase();
                const rank = index + 1;
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
                const rankColor = rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#8b949e';
                
                return `
                    <div class="flex items-center justify-between py-2 px-2 rounded hover:bg-gray-800 transition-colors" style="background-color: #0d1117; border-bottom: 1px solid #30363d;">
                        <div class="flex items-center gap-2 flex-1 min-w-0">
                            <div class="flex-shrink-0 w-6 text-center">
                                <span class="text-xs font-bold" style="color: ${rankColor};">${medal || rank}</span>
                            </div>
                            <div class="w-7 h-7 rounded-full flex items-center justify-center text-white font-semibold text-xs flex-shrink-0" style="background: linear-gradient(135deg, #9333ea 0%, #ec4899 50%, #4f46e5 100%);">
                                ${initial}
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-white font-medium text-sm truncate">${holder.username}</p>
                                <p class="text-gray-400 text-xs truncate">${holder.userAddress}</p>
                            </div>
                        </div>
                        <div class="text-right flex-shrink-0 ml-2">
                            <p class="text-white font-semibold text-sm">${holder.totalShares.toLocaleString()}</p>
                            <p class="text-gray-400 text-xs">votes</p>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Load comments from backend
        async function loadComments() {
            if (!currentPollId) {
                console.warn('loadComments: No currentPollId');
                return;
            }
            
            const poll = markets.find(m => m.id === currentPollId || m.id === currentPollId.toString());
            if (!poll) {
                console.warn('loadComments: Poll not found for id:', currentPollId);
                return;
            }
            
            // Use poll.id as address if address doesn't exist (for local markets)
            const marketAddress = poll.address || poll.id;
            
            // Get user address from login data
            const loginData = localStorage.getItem('userLogin');
            let userAddress = null;
            if (loginData) {
                try {
                    const data = JSON.parse(loginData);
                    userAddress = data.identifier || data.walletInfo?.address;
                } catch (e) {
                    console.warn('Error parsing login data:', e);
                }
            }
            
            const commentsList = document.getElementById('commentsList');
            if (!commentsList) {
                console.warn('loadComments: commentsList element not found');
                return;
            }
            
            // Show loading state
            commentsList.innerHTML = '<p class="text-gray-400 text-center py-8">Loading comments...</p>';
            
            try {
                const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                const url = `${API_URL}/api/markets/${encodeURIComponent(marketAddress)}/comments${userAddress ? `?userAddress=${encodeURIComponent(userAddress)}` : ''}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    if (response.status === 0 || response.status >= 500) {
                        console.warn('Backend unavailable for comments');
                        commentsList.innerHTML = '<p class="text-gray-400 text-center py-8">Comments unavailable. Backend may be offline.</p>';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const comments = await response.json();
                renderComments(comments, marketAddress);
            } catch (error) {
                console.error('Error loading comments:', error);
                if (commentsList) {
                    commentsList.innerHTML = '<p class="text-gray-400 text-center py-8">Error loading comments. Please try again later.</p>';
                }
            }
        }
        
        function renderComments(comments, marketAddress) {
            const commentsList = document.getElementById('commentsList');
            const commentsCount = document.getElementById('commentsCount');
            
            if (!comments || comments.length === 0) {
                commentsList.innerHTML = '<p class="text-gray-400 text-center py-8">No comments yet. Be the first to comment!</p>';
                commentsCount.textContent = '0';
                return;
            }

            commentsCount.textContent = comments.length;
            
            commentsList.innerHTML = comments.map((comment) => {
                const commentId = `comment-${comment.id}`;
                const isLiked = comment.isLiked || false;
                const likes = comment.likes || 0;
                const heartColor = isLiked ? '#9333ea' : 'currentColor';
                const heartFill = isLiked ? '#9333ea' : 'none';
                const dateStr = comment.date ? new Date(comment.date).toLocaleString() : 'Just now';
                
                // Render replies
                const repliesHtml = comment.replies && comment.replies.length > 0 ? `
                    <div class="ml-12 mt-3 space-y-3">
                        ${comment.replies.map(reply => {
                            const replyId = `reply-${reply.id}`;
                            const replyIsLiked = reply.isLiked || false;
                            const replyLikes = reply.likes || 0;
                            const replyHeartColor = replyIsLiked ? '#9333ea' : 'currentColor';
                            const replyHeartFill = replyIsLiked ? '#9333ea' : 'none';
                            const replyDateStr = reply.date ? new Date(reply.date).toLocaleString() : 'Just now';
                            
                            return `
                                <div class="pb-3 border-l-2 pl-3" style="border-color: #30363d;">
                                    <div class="flex items-start gap-3">
                                        <div class="w-6 h-6 rounded-full flex items-center justify-center text-white text-xs font-semibold" style="background-color: #9333ea;">
                                            ${reply.author.charAt(0).toUpperCase()}
                                        </div>
                                        <div class="flex-1">
                                            <div class="flex items-center gap-2 mb-1">
                                                <span class="text-white font-semibold text-sm">${reply.author}</span>
                                                <span class="text-gray-400 text-xs">${replyDateStr}</span>
                                            </div>
                                            <p class="text-gray-300 text-xs">${reply.text}</p>
                                            <div class="flex items-center gap-4 mt-2">
                                                <button id="likeBtn-${replyId}" data-comment-id="${reply.id}" class="text-gray-400 hover:text-white text-xs flex items-center gap-1 transition-colors" style="cursor: pointer;">
                                                    <svg class="w-3 h-3" fill="${replyHeartFill}" stroke="${replyHeartColor}" viewBox="0 0 24 24" style="color: ${replyHeartColor};">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                                                    </svg>
                                                    <span id="likeCount-${replyId}">${replyLikes}</span>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                ` : '';
                
                return `
                <div class="pb-4 border-b" style="border-color: #30363d;">
                    <div class="flex items-start gap-3">
                        <div class="w-8 h-8 rounded-full flex items-center justify-center text-white font-semibold" style="background-color: #9333ea;">
                            ${comment.author.charAt(0).toUpperCase()}
                        </div>
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="text-white font-semibold">${comment.author}</span>
                                <span class="text-gray-400 text-sm">${dateStr}</span>
                            </div>
                            <p class="text-gray-300 text-sm">${comment.text}</p>
                            <div class="flex items-center gap-4 mt-2">
                                <button id="likeBtn-${commentId}" data-comment-id="${comment.id}" class="text-gray-400 hover:text-white text-sm flex items-center gap-1 transition-colors" style="cursor: pointer;">
                                    <svg class="w-4 h-4" fill="${heartFill}" stroke="${heartColor}" viewBox="0 0 24 24" style="color: ${heartColor};">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                                    </svg>
                                    <span id="likeCount-${commentId}">${likes}</span>
                                </button>
                                <button id="replyBtn-${commentId}" data-comment-id="${comment.id}" class="text-gray-400 hover:text-white text-sm" style="cursor: pointer;">Reply</button>
                            </div>
                            ${repliesHtml}
                        </div>
                    </div>
                </div>
            `;
            }).join('');
            
            // Attach event listeners
            comments.forEach(comment => {
                const commentId = `comment-${comment.id}`;
                const likeBtn = document.getElementById(`likeBtn-${commentId}`);
                const replyBtn = document.getElementById(`replyBtn-${commentId}`);
                
                if (likeBtn) {
                    likeBtn.addEventListener('click', () => handleLike(comment.id, commentId));
                }
                
                if (replyBtn) {
                    replyBtn.addEventListener('click', () => handleReply(comment.id, comment.author));
                }
                
                // Handle reply likes
                if (comment.replies) {
                    comment.replies.forEach(reply => {
                        const replyId = `reply-${reply.id}`;
                        const replyLikeBtn = document.getElementById(`likeBtn-${replyId}`);
                        if (replyLikeBtn) {
                            replyLikeBtn.addEventListener('click', () => handleLike(reply.id, replyId));
                        }
                    });
                }
            });
        }

        let replyingToCommentId = null;
        let replyingToAuthor = null;
        
        async function postComment() {
            const input = document.getElementById('commentInput');
            if (!input) {
                console.error('Comment input not found');
                return;
            }
            
            const text = input.value.trim();
            
            if (!text) {
                alert('Please enter a comment');
                return;
            }
            
            if (!currentPollId) {
                alert('No poll selected');
                return;
            }

            const poll = markets.find(m => m.id === currentPollId || m.id === currentPollId.toString());
            if (!poll) {
                console.error('Poll not found:', currentPollId);
                alert('Poll not found. Please try again.');
                return;
            }

            // Use poll.id as address if address doesn't exist (for local markets)
            const marketAddress = poll.address || poll.id;

            // Get user address from login data
            const loginData = localStorage.getItem('userLogin');
            let userAddress = null;
            if (loginData) {
                try {
                    const data = JSON.parse(loginData);
                    userAddress = data.identifier || data.walletInfo?.address;
                } catch (e) {
                    console.warn('Error parsing login data:', e);
                }
            }
            
            if (!userAddress) {
                alert('Please log in to post a comment');
                return;
            }

            try {
                const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                const response = await fetch(`${API_URL}/api/markets/${encodeURIComponent(marketAddress)}/comments`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userAddress: userAddress,
                        text: text,
                        parentCommentId: replyingToCommentId || null
                    })
                }).catch(fetchError => {
                    // Network error (backend not running)
                    console.error('Network error:', fetchError);
                    throw new Error('Backend server is not running. Please start the backend server on port 3001.');
                });
                
                if (!response.ok) {
                    let errorMessage = `HTTP error! status: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        // Could not parse error response
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                
                // Clear input
                input.value = '';
                replyingToCommentId = null;
                replyingToAuthor = null;
                // Update placeholder
                input.placeholder = 'Add a comment';
                // Reload comments
                await loadComments();
                
                // Update comment count
                const commentsCount = document.getElementById('commentsCount');
                if (commentsCount) {
                    // Will be updated by loadComments
                }
            } catch (error) {
                console.error('Error posting comment:', error);
                const errorMsg = error.message || 'Please try again.';
                if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
                    const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                    alert(`Cannot connect to backend server. Please make sure the backend is running on ${API_URL}`);
                } else {
                    alert(`Error posting comment: ${errorMsg}`);
                }
            }
        }
        
        function handleReply(commentId, authorName) {
            const input = document.getElementById('commentInput');
            if (input) {
                replyingToCommentId = commentId;
                replyingToAuthor = authorName;
                input.placeholder = `Reply to ${authorName}...`;
                input.focus();
            }
        }
        
        async function handleLike(commentId, elementId) {
            const userAddress = localStorage.getItem('userAddress');
            if (!userAddress) {
                alert('Please log in to like comments');
                return;
            }
            
            try {
                const API_URL = (window.APP_CONFIG && window.APP_CONFIG.API_URL) || 'http://localhost:3001';
                const response = await fetch(`${API_URL}/api/comments/${commentId}/like`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userAddress: userAddress
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Update UI
                    const likeBtn = document.getElementById(`likeBtn-${elementId}`);
                    const likeCount = document.getElementById(`likeCount-${elementId}`);
                    const heartSvg = likeBtn ? likeBtn.querySelector('svg') : null;
                    
                    if (likeBtn && likeCount && heartSvg) {
                        if (data.liked) {
                            heartSvg.setAttribute('fill', '#9333ea');
                            heartSvg.setAttribute('stroke', '#9333ea');
                            heartSvg.style.color = '#9333ea';
                            likeBtn.style.color = '#9333ea';
                        } else {
                            heartSvg.setAttribute('fill', 'none');
                            heartSvg.setAttribute('stroke', 'currentColor');
                            heartSvg.style.color = 'currentColor';
                            likeBtn.style.color = '#9ca3af';
                        }
                        likeCount.textContent = data.likes || 0;
                    }
                } else {
                    alert(`Error liking comment: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error liking comment:', error);
                alert('Error liking comment. Please try again.');
            }
        }
        
        function toggleLike(pollId, commentIndex) {
            console.log('toggleLike called:', pollId, commentIndex);
            const poll = markets.find(m => m.id === pollId);
            if (!poll || !poll.comments || !poll.comments[commentIndex]) {
                console.error('Poll or comment not found');
                return;
            }
            
            const comment = poll.comments[commentIndex];
            const commentId = `${pollId}-comment-${commentIndex}`;
            
            // Increment likes and set to liked state
            comment.isLiked = true;
            comment.likes = (comment.likes || 0) + 1;
            
            // Update the UI
            const likeBtn = document.getElementById(`likeBtn-${commentId}`);
            const likeCount = document.getElementById(`likeCount-${commentId}`);
            const heartSvg = likeBtn ? likeBtn.querySelector('svg') : null;
            
            if (likeBtn && likeCount && heartSvg) {
                // Always set to purple when clicked
                heartSvg.setAttribute('fill', '#9333ea');
                heartSvg.setAttribute('stroke', '#9333ea');
                heartSvg.style.color = '#9333ea';
                heartSvg.style.setProperty('color', '#9333ea', 'important');
                likeBtn.style.color = '#9333ea';
                likeBtn.style.setProperty('color', '#9333ea', 'important');
                likeCount.textContent = comment.likes || 0;
            }
            
            // Save to localStorage
            saveMarketsToStorage();
        }

        // Search input event listener
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            let searchTimeout;
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value;
                selectedSuggestionIndex = -1;
                
                // Show autocomplete suggestions immediately
                renderAutocompleteSuggestions(query);
                
                // Debounce actual search/filtering
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 300);
            });
            
            // Handle keyboard navigation
            searchInput.addEventListener('keydown', (e) => {
                const dropdown = document.getElementById('autocompleteDropdown');
                const isDropdownVisible = dropdown && !dropdown.classList.contains('hidden');
                
                if (isDropdownVisible) {
                    const suggestions = getSearchSuggestions(e.target.value);
                    
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
                        highlightSuggestion(selectedSuggestionIndex);
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                        if (selectedSuggestionIndex >= 0) {
                            highlightSuggestion(selectedSuggestionIndex);
                        } else {
                            selectedSuggestionIndex = -1;
                            document.querySelectorAll('.suggestion-item').forEach(item => {
                                item.style.backgroundColor = 'transparent';
                            });
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
                            selectSuggestion(suggestions[selectedSuggestionIndex].id);
                        } else {
                            performSearch(e.target.value);
                            hideAutocomplete();
                        }
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                        searchInput.blur();
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch(e.target.value);
                }
            });
            
            // Focus/blur handling
            let isClickingSuggestion = false;
            
            searchInput.addEventListener('focus', () => {
                searchInput.style.borderColor = '#9333ea';
                if (searchInput.value) {
                    renderAutocompleteSuggestions(searchInput.value);
                }
            });
            
            searchInput.addEventListener('blur', (e) => {
                // Don't hide if clicking on a suggestion
                if (window.isClickingSuggestion) {
                    return;
                }
                
                // Delay hiding to allow click events on suggestions
                setTimeout(() => {
                    // Double check if we're still not clicking a suggestion
                    if (!window.isClickingSuggestion && !document.activeElement.closest('#autocompleteDropdown')) {
                        if (!searchInput.value) {
                            searchInput.style.borderColor = '#30363d';
                        }
                        hideAutocomplete();
                    }
                }, 200);
            });
            
            // Click outside to close
            document.addEventListener('click', (e) => {
                const clickedInside = e.target.closest('#searchInput') || e.target.closest('#autocompleteDropdown');
                if (!clickedInside) {
                    hideAutocomplete();
                }
            });
        }
        
        // Initialize: markets are already loaded from localStorage above
        console.log('üìä Total markets loaded:', markets.length);
        
        // Ensure tab buttons have proper event listeners
        const tabTrending = document.getElementById('tabTrending');
        if (tabTrending) {
            tabTrending.addEventListener('click', (e) => {
                e.preventDefault();
                setActiveTab('Trending');
            });
        }
        
        renderMarkets();
        
        // How It Works page functions - Make available immediately
        window.openHowItWorks = function openHowItWorks() {
            console.log('=== openHowItWorks called ===');
            const howItWorksPage = document.getElementById('howItWorksPage');
            
            if (!howItWorksPage) {
                console.error('ERROR: howItWorksPage element not found!');
                alert('How it Works page element not found. Please refresh the page.');
                return;
            }
            
            console.log('Page element found, showing it...');
            console.log('Page innerHTML length:', howItWorksPage.innerHTML.length);
            
            // Update browser history to track this page state
            history.pushState({ page: 'help' }, '', window.location.pathname);
            
            // Hide ALL other content containers - be very aggressive
            const mainContent = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const userDashboard = document.getElementById('userDashboard');
            const settingsPage = document.getElementById('settingsPage');
            
            [mainContent, marketsContainer, pollDetailPage, userDashboard, settingsPage].forEach(container => {
                if (container) {
                    container.style.display = 'none';
                    container.style.visibility = 'hidden';
                    container.style.opacity = '0';
                    container.style.zIndex = '-1000';
                    container.style.pointerEvents = 'none';
                }
            });
            
            // KEEP HEADER AND NAV VISIBLE
            const header = document.querySelector('header');
            const nav = document.querySelector('nav');
            if (header) {
                header.style.display = 'block';
                header.style.visibility = 'visible';
                header.style.zIndex = '200';
            }
            if (nav) {
                nav.style.display = 'block';
                nav.style.visibility = 'visible';
                nav.style.zIndex = '200';
            }
            
            // Calculate header height
            const headerHeight = header ? header.offsetHeight : 64;
            const navHeight = nav ? nav.offsetHeight : 48;
            const totalHeaderHeight = headerHeight + navHeight;
            
            // Show the how it works page - use absolute positioning relative to body
            howItWorksPage.style.cssText = `
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                position: fixed !important;
                top: ${totalHeaderHeight}px !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100% !important;
                height: calc(100vh - ${totalHeaderHeight}px) !important;
                background-color: #0d1117 !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                z-index: 150 !important;
                padding: 0 !important;
                margin: 0 !important;
            `;
            
            // Remove hidden class if present
            howItWorksPage.classList.remove('hidden');
            
            // Ensure the inner container is visible
            const pageContainer = howItWorksPage.querySelector('.max-w-4xl');
            if (pageContainer) {
                pageContainer.style.cssText = `
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    margin: 0 auto !important;
                    padding: 3rem 1rem !important;
                `;
            }
            
            // Ensure ALL sections are visible
            const sections = howItWorksPage.querySelectorAll('section, div, h1, h2, h3, p, ul, li, button');
            sections.forEach(el => {
                el.style.visibility = 'visible';
                el.style.opacity = '1';
                el.style.display = '';
                el.classList.remove('hidden');
            });
            
            // Add purple underline to "How it works" link
            const howItWorksLink = document.getElementById('howItWorksLink');
            if (howItWorksLink) {
                howItWorksLink.style.borderBottom = '2px solid #a855f7';
            }
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'instant' });
            
            // Force visibility check and fix after a delay
            setTimeout(() => {
                const computedStyle = window.getComputedStyle(howItWorksPage);
                const rect = howItWorksPage.getBoundingClientRect();
                
                console.log('How it Works page visibility check:', {
                    display: computedStyle.display,
                    visibility: computedStyle.visibility,
                    opacity: computedStyle.opacity,
                    zIndex: computedStyle.zIndex,
                    height: computedStyle.height,
                    top: computedStyle.top,
                    width: computedStyle.width,
                    boundingRect: rect,
                    innerHTMLLength: howItWorksPage.innerHTML.length,
                    childrenCount: howItWorksPage.children.length
                });
                
                // If still not visible, try moving it to body
                if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || rect.height === 0) {
                    console.warn('Page still not visible, trying to move to body...');
                    const body = document.body;
                    if (howItWorksPage.parentNode !== body) {
                        body.appendChild(howItWorksPage);
                    }
                    howItWorksPage.style.cssText = `
                        display: block !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        position: fixed !important;
                        top: ${totalHeaderHeight}px !important;
                        left: 0 !important;
                        right: 0 !important;
                        bottom: 0 !important;
                        width: 100% !important;
                        height: calc(100vh - ${totalHeaderHeight}px) !important;
                        background-color: #0d1117 !important;
                        overflow-y: auto !important;
                        z-index: 9999 !important;
                    `;
                }
            }, 300);
            
            console.log('How it Works page should now be visible');
        }
        
        function closeHowItWorks() {
            console.log('closeHowItWorks called');
            const howItWorksPage = document.getElementById('howItWorksPage');
            const mainContent = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const nav = document.querySelector('nav');
            
            if (howItWorksPage) {
                howItWorksPage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                howItWorksPage.style.zIndex = '-1';
            }
            
            // Show main content again
            if (mainContent) {
                mainContent.style.display = 'block';
                mainContent.style.visibility = 'visible';
                mainContent.style.opacity = '1';
                mainContent.style.zIndex = '1';
            }
            if (marketsContainer) {
                marketsContainer.style.display = 'grid';
                marketsContainer.style.visibility = 'visible';
            }
            if (nav) {
                nav.style.display = 'block';
                nav.style.visibility = 'visible';
            }
            
            // Remove purple underline from "How it works" link
            const howItWorksLink = document.getElementById('howItWorksLink');
            if (howItWorksLink) {
                howItWorksLink.style.borderBottom = '2px solid transparent';
            }
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            console.log('How it Works page closed');
        }
        
        // Go to homepage function
        function goToHomepage() {
            console.log('goToHomepage called');
            
            // Close any open pages/sections
            const howItWorksPage = document.getElementById('howItWorksPage');
            const pollDetailPage = document.getElementById('pollDetailPage');
            const createMarketModal = document.getElementById('createMarketModal');
            const userDashboard = document.getElementById('userDashboard');
            const settingsPage = document.getElementById('settingsPage');
            
            // Hide special pages with inline styles
            if (howItWorksPage) {
                howItWorksPage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                howItWorksPage.style.zIndex = '-1';
                howItWorksPage.classList.add('hidden');
            }
            if (pollDetailPage) {
                pollDetailPage.style.display = 'none';
                pollDetailPage.style.visibility = 'hidden';
            }
            if (createMarketModal) {
                createMarketModal.classList.add('hidden');
                createMarketModal.style.display = 'none';
            }
            if (userDashboard) {
                userDashboard.style.display = 'none';
                userDashboard.style.visibility = 'hidden';
            }
            if (settingsPage) {
                settingsPage.style.display = 'none';
                settingsPage.style.visibility = 'hidden';
            }
            
            // Show main content
            const mainContent = document.querySelector('main');
            const marketsContainer = document.getElementById('marketsContainer');
            const nav = document.querySelector('nav');
            
            if (mainContent) {
                mainContent.style.display = 'block';
                mainContent.style.visibility = 'visible';
                mainContent.style.opacity = '1';
                mainContent.style.zIndex = '1';
            }
            if (marketsContainer) {
                marketsContainer.style.display = 'grid';
                marketsContainer.style.visibility = 'visible';
            }
            if (nav) {
                nav.style.display = 'block';
                nav.style.visibility = 'visible';
            }
            
            // Set active tab to Trending (homepage)
            if (typeof setActiveTab === 'function') {
                setActiveTab('Trending');
            } else if (typeof window.setActiveTab === 'function') {
                window.setActiveTab('Trending');
            }
            
            // Reset URL to homepage
            window.history.pushState({}, '', window.location.pathname);
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            console.log('Navigated to homepage');
        }

        // Make functions globally accessible
        window.openPollDetail = openPollDetail;
        window.closePollDetail = closePollDetail;
        window.postComment = postComment;
        window.openDateTimePicker = openDateTimePicker;
        window.closeDateTimePicker = closeDateTimePicker;
        window.openHowItWorks = openHowItWorks;
        window.closeHowItWorks = closeHowItWorks;
        window.goToHomepage = goToHomepage;
        window.selectSuggestion = selectSuggestion;
        window.highlightSuggestion = highlightSuggestion;
        window.clearSearch = clearSearch;
        window.filterByCategory = filterByCategory;
        
        // Make date/time picker functions globally accessible for inline onclick handlers
        window.updateCalendar = updateCalendar;
        window.updateTimeInputs = updateTimeInputs;
        window.updateTimeDisplay = updateTimeDisplay;
        window.setAMPM = setAMPM;
        window.changeMonth = changeMonth;
        window.setToday = setToday;
        window.clearDateTime = clearDateTime;
        window.confirmDateTime = confirmDateTime;
        window.selectDay = selectDay;
        window.populateMonthYearDropdowns = populateMonthYearDropdowns;
        
        console.log('Date/time picker functions exposed:', {
            updateCalendar: typeof window.updateCalendar,
            updateTimeInputs: typeof window.updateTimeInputs,
            updateTimeDisplay: typeof window.updateTimeDisplay,
            setAMPM: typeof window.setAMPM,
            changeMonth: typeof window.changeMonth,
            setToday: typeof window.setToday,
            clearDateTime: typeof window.clearDateTime,
            confirmDateTime: typeof window.confirmDateTime,
            selectDay: typeof window.selectDay
        });
        
        console.log('Markets loaded:', markets.length);
        console.log('openDateTimePicker function available:', typeof window.openDateTimePicker);
        console.log('openPollDetail function available:', typeof window.openPollDetail);
        
        // Check if URL has a poll parameter on page load
        setTimeout(() => {
            checkUrlForPoll();
        }, 500);
        
        // Initialize resolution criteria validation
        setupResolutionCriteriaValidation();
        
        // Make dashboard functions globally accessible
        window.openDashboard = openDashboard;
        window.closeDashboard = closeDashboard;
        
        // Show positions detail
        function showPositionsDetail() {
            const detailSection = document.getElementById('dashboardPositionsDetail');
            const positionsList = document.getElementById('dashboardPositionsList');
            
            if (!detailSection || !positionsList) {
                console.warn('Positions detail elements not found');
                return;
            }
            
            // Get positions from window or recalculate
            let positions = window.dashboardActivePositions || [];
            
            // If no positions stored, try to get from localStorage and recalculate
            if (positions.length === 0) {
                try {
                    const loginData = localStorage.getItem('userLogin');
                    if (!loginData) {
                        positionsList.innerHTML = `
                            <div class="p-6 rounded-xl text-center" style="background-color: #161b22; border: 1px solid #30363d;">
                                <p class="text-[#8b949e] mb-4">Please log in to view your positions.</p>
                            </div>
                        `;
                        detailSection.style.display = 'block';
                        detailSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        return;
                    }
                    
                    const data = JSON.parse(loginData);
                    const userAddress = data.address || data.identifier || data.userAddress;
                    
                    // Reload dashboard data to get fresh positions
                    if (typeof loadDashboardData === 'function') {
                        loadDashboardData();
                        // Wait a bit for data to load
                        setTimeout(() => {
                            positions = window.dashboardActivePositions || [];
                            renderPositionsList(positions, positionsList);
                        }, 100);
                        return;
                    }
                } catch (e) {
                    console.error('Error loading positions:', e);
                }
            }
            
            // Render positions first
            renderPositionsList(positions, positionsList);
            
            // Show the detail section
            detailSection.style.display = 'block';
            detailSection.style.visibility = 'visible';
            detailSection.classList.remove('hidden');
            
            console.log('Detail section shown', {
                positionsCount: positions.length,
                listContent: positionsList.innerHTML.length,
                sectionDisplay: detailSection.style.display
            });
            
            // Only scroll if there's content to show
            if (positions.length > 0 || positionsList.innerHTML.trim().length > 0) {
                // Force a reflow to ensure the element is rendered
                void detailSection.offsetHeight;
                
                // Scroll to detail section after ensuring it's rendered
                setTimeout(() => {
                    if (detailSection.offsetParent !== null && detailSection.offsetHeight > 0) {
                        detailSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    } else {
                        console.warn('Detail section not visible, cannot scroll');
                    }
                }, 200);
            } else {
                console.log('No positions to display, not scrolling');
            }
        }
        
        function renderPositionsList(positions, positionsList) {
            if (positions.length === 0) {
                positionsList.innerHTML = `
                    <div class="p-6 rounded-xl text-center" style="background-color: #161b22; border: 1px solid #30363d;">
                        <p class="text-[#8b949e] mb-4">You don't have any active positions yet.</p>
                        <button onclick="hidePositionsDetail(); closeDashboard(); document.getElementById('createMarketBtn')?.click();" class="px-4 py-2 rounded-lg text-white font-medium hover:opacity-90 transition-opacity" style="background-color: #9333ea;">
                            Start Trading
                        </button>
                    </div>
                `;
                return;
            }
            
            // Get markets from localStorage
            const marketsData = localStorage.getItem('pollit_markets') || localStorage.getItem('markets');
            const markets = marketsData ? JSON.parse(marketsData) : [];
            
            positionsList.innerHTML = positions.map(pos => {
                const market = markets.find(m => m.id === pos.marketId);
                const emoji = market ? ((market.category && categoryEmojis[market.category]) || market.emoji || 'üìä') : 'üìä';
                const pnlColor = pos.pnl >= 0 ? '#10b981' : '#ef4444';
                const pnlIcon = pos.pnl >= 0 ? 'üìà' : 'üìâ';
                const pnlSign = pos.pnl >= 0 ? '+' : '';
                const outcomeName = market && market.outcomes && market.outcomes[pos.outcomeIndex] ? market.outcomes[pos.outcomeIndex] : 'Unknown';
                
                // Calculate sold amount if available
                const soldAmount = pos.soldAmount || 0;
                const currentPosition = pos.volume || 0;
                const totalInvested = currentPosition + soldAmount;
                
                return `
                    <div class="p-4 rounded-xl cursor-pointer hover:opacity-90 transition-all" style="background-color: #161b22; border: 1px solid #30363d;" onclick="event.stopPropagation(); (function() { const pollId = '${pos.marketId}'; const dashboard = document.getElementById('userDashboard'); if(dashboard) dashboard.style.display = 'none'; if(typeof openPollDetail === 'function') { openPollDetail(pollId); } else if(typeof window.openPollDetail === 'function') { window.openPollDetail(pollId); } })();">
                        <div class="flex items-start justify-between gap-4">
                            <div class="flex items-start gap-3 flex-1 min-w-0">
                                <span class="text-2xl flex-shrink-0">${emoji}</span>
                                <div class="flex-1 min-w-0">
                                    <h4 class="text-white font-medium mb-1 truncate">${pos.title || market?.title || 'Unknown Market'}</h4>
                                    <p class="text-sm text-[#8b949e] mb-1">${outcomeName}</p>
                                    ${soldAmount > 0 ? `<p class="text-xs text-[#ef4444]">Sold: $${soldAmount.toFixed(2)}</p>` : ''}
                                </div>
                            </div>
                            <div class="flex flex-col items-end flex-shrink-0">
                                <span class="text-lg font-bold text-white mb-1">$${currentPosition.toFixed(2)}</span>
                                <span class="text-sm font-medium" style="color: ${pnlColor};">
                                    ${pnlIcon} ${pnlSign}$${Math.abs(pos.pnl || 0).toFixed(2)}
                                </span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Hide positions detail
        function hidePositionsDetail() {
            const detailSection = document.getElementById('dashboardPositionsDetail');
            if (detailSection) {
                detailSection.style.display = 'none';
            }
        }
        
        window.showPositionsDetail = showPositionsDetail;
        window.hidePositionsDetail = hidePositionsDetail;
        
        // Make trading functions globally accessible
        window.selectOutcomeForTrade = selectOutcomeForTrade;
        window.openTradingModal = openTradingModal;
        window.closeTradingModal = closeTradingModal;
        window.setTradeMode = setTradeMode;
        window.addTradeAmount = addTradeAmount;
        window.setMaxAmount = setMaxAmount;
        window.calculateUserShares = calculateUserShares;
        window.executeTrade = executeTrade;
        window.closeHowItWorks = closeHowItWorks;
        window.goToHomepage = goToHomepage;
        window.openCreateMarketModal = openCreateMarketModal;
        
        // Set up button event listeners
        function setupNavigationButtons() {
            // Logo button - navigate to Trending section (homepage)
            const logoLink = document.getElementById('logoLink');
            if (logoLink) {
                logoLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log('Logo clicked - forcing navigation to Trending');
                    
                    // Forcefully hide How It Works page with all methods
                    const howItWorksPage = document.getElementById('howItWorksPage');
                    if (howItWorksPage) {
                        howItWorksPage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; z-index: -1 !important; position: absolute !important;';
                        howItWorksPage.classList.add('hidden');
                    }
                    
                    // Hide all other special pages
                    const pollDetailPage = document.getElementById('pollDetailPage');
                    const userDashboard = document.getElementById('userDashboard');
                    const settingsPage = document.getElementById('settingsPage');
                    const createMarketModal = document.getElementById('createMarketModal');
                    
                    if (pollDetailPage) pollDetailPage.style.display = 'none';
                    if (userDashboard) userDashboard.style.display = 'none';
                    if (settingsPage) settingsPage.style.display = 'none';
                    if (createMarketModal) {
                        createMarketModal.classList.add('hidden');
                        createMarketModal.style.display = 'none';
                    }
                    
                    // Forcefully show main content
                    const main = document.querySelector('main');
                    const marketsContainer = document.getElementById('marketsContainer');
                    const nav = document.querySelector('nav');
                    
                    if (main) {
                        main.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; z-index: 1 !important;';
                    }
                    if (marketsContainer) {
                        marketsContainer.style.cssText = 'display: grid !important; visibility: visible !important;';
                    }
                    if (nav) {
                        nav.style.cssText = 'display: block !important; visibility: visible !important;';
                    }
                    
                    // Close menu if open
                    if (typeof closeMenu === 'function') {
                        closeMenu();
                    }
                    
                    // Call setActiveTab - it will handle the rest
                    setTimeout(function() {
                        if (window.setActiveTab) {
                            console.log('Calling setActiveTab("Trending")');
                            window.setActiveTab('Trending');
                        } else {
                            console.error('setActiveTab not available');
                        }
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }, 50);
                });
            }
            
            // Back to Home button in help page - use direct onclick handler
            const backToHomeBtn = document.getElementById('backToHomeBtn');
            if (backToHomeBtn) {
                // Set onclick directly - this will override the inline onclick
                backToHomeBtn.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Back to Home button clicked');
                    
                    // Hide How It Works page immediately
                    const howItWorksPage = document.getElementById('howItWorksPage');
                    if (howItWorksPage) {
                        howItWorksPage.style.display = 'none';
                        howItWorksPage.style.visibility = 'hidden';
                        howItWorksPage.style.opacity = '0';
                    }
                    
                    // Show main content
                    const main = document.querySelector('main');
                    const marketsContainer = document.getElementById('marketsContainer');
                    const nav = document.querySelector('nav');
                    
                    if (main) {
                        main.style.display = 'block';
                        main.style.visibility = 'visible';
                        main.style.opacity = '1';
                    }
                    if (marketsContainer) {
                        marketsContainer.style.display = 'grid';
                        marketsContainer.style.visibility = 'visible';
                    }
                    if (nav) {
                        nav.style.display = 'block';
                        nav.style.visibility = 'visible';
                    }
                    
                    // Hide other pages
                    const pollDetailPage = document.getElementById('pollDetailPage');
                    const userDashboard = document.getElementById('userDashboard');
                    const settingsPage = document.getElementById('settingsPage');
                    if (pollDetailPage) pollDetailPage.style.display = 'none';
                    if (userDashboard) userDashboard.style.display = 'none';
                    if (settingsPage) settingsPage.style.display = 'none';
                    
                    // Call setActiveTab to show Trending - use setTimeout to ensure DOM is ready
                    setTimeout(function() {
                        console.log('Calling setActiveTab("Trending")');
                        if (window.setActiveTab) {
                            window.setActiveTab('Trending');
                        } else if (typeof setActiveTab === 'function') {
                            setActiveTab('Trending');
                        } else {
                            console.error('setActiveTab not found');
                            // Fallback: try to render markets
                            if (window.renderMarkets) {
                                window.renderMarkets();
                            }
                        }
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }, 50);
                };
            }
        }
        
        // Set up on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', setupNavigationButtons);
        
        // Also set up immediately if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupNavigationButtons);
        } else {
            setupNavigationButtons();
        }
        
        // Make comment functions globally accessible
        window.setCommentsTab = setCommentsTab;
        
        // Set up comment tab buttons - use event delegation since elements are created dynamically
        function setupCommentTabs() {
            const topHoldersTab = document.getElementById('topHoldersTab');
            const commentsTab = document.getElementById('commentsTab');
            const postCommentBtn = document.getElementById('postCommentBtn');
            
            if (topHoldersTab) {
                // Remove old listeners by cloning
                const newTopHoldersTab = topHoldersTab.cloneNode(true);
                topHoldersTab.parentNode.replaceChild(newTopHoldersTab, topHoldersTab);
                const updatedTopHoldersTab = document.getElementById('topHoldersTab');
                if (updatedTopHoldersTab) {
                    updatedTopHoldersTab.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Top Holders tab clicked');
                        setCommentsTab('topHolders');
                    });
                }
            }
            
            if (commentsTab) {
                // Remove old listeners by cloning
                const newCommentsTab = commentsTab.cloneNode(true);
                commentsTab.parentNode.replaceChild(newCommentsTab, commentsTab);
                const updatedCommentsTab = document.getElementById('commentsTab');
                if (updatedCommentsTab) {
                    updatedCommentsTab.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Comments tab clicked');
                        setCommentsTab('comments');
                    });
                }
            }
            
            if (postCommentBtn) {
                postCommentBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    postComment();
                });
            }
        }
        
        window.setupCommentTabs = setupCommentTabs;
        
        // Category scroll functionality
        function scrollCategories(direction) {
            const container = document.getElementById('categoryScrollContainer');
            if (!container) return;
            
            const scrollAmount = 200; // pixels to scroll
            const currentScroll = container.scrollLeft;
            const newScroll = direction === 'left' 
                ? currentScroll - scrollAmount 
                : currentScroll + scrollAmount;
            
            container.scrollTo({
                left: newScroll,
                behavior: 'smooth'
            });
        }
        
        function updateCategoryScrollArrows() {
            const container = document.getElementById('categoryScrollContainer');
            const leftBtn = document.getElementById('categoryScrollLeft');
            const rightBtn = document.getElementById('categoryScrollRight');
            const leftFade = document.getElementById('categoryFadeLeft');
            const rightFade = document.getElementById('categoryFadeRight');
            
            if (!container || !leftBtn || !rightBtn) return;
            
            const scrollLeft = container.scrollLeft;
            const scrollWidth = container.scrollWidth;
            const clientWidth = container.clientWidth;
            const maxScroll = scrollWidth - clientWidth;
            
            // Show/hide left arrow and fade
            if (scrollLeft > 10) {
                leftBtn.style.opacity = '1';
                leftBtn.style.pointerEvents = 'auto';
                if (leftFade) leftFade.style.opacity = '1';
            } else {
                leftBtn.style.opacity = '0';
                leftBtn.style.pointerEvents = 'none';
                if (leftFade) leftFade.style.opacity = '0';
            }
            
            // Show/hide right arrow and fade
            if (scrollLeft < maxScroll - 10) {
                rightBtn.style.opacity = '1';
                rightBtn.style.pointerEvents = 'auto';
                if (rightFade) rightFade.style.opacity = '1';
            } else {
                rightBtn.style.opacity = '0';
                rightBtn.style.pointerEvents = 'none';
                if (rightFade) rightFade.style.opacity = '0';
            }
        }
        
        // Also set up on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', setupCommentTabs);
        
        // Setup settings form handler
        document.addEventListener('DOMContentLoaded', function() {
            const settingsForm = document.getElementById('settingsForm');
            if (settingsForm) {
                settingsForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const settingsData = {
                        username: document.getElementById('settingsUsername').value,
                        email: document.getElementById('settingsEmail').value,
                        bio: document.getElementById('settingsBio').value,
                        currency: document.getElementById('settingsCurrency').value,
                        paymentMethod: document.getElementById('settingsPaymentMethod').value,
                        walletAddress: document.getElementById('settingsWalletAddress').value || null,
                        emailNotifications: document.getElementById('settingsEmailNotifications').checked,
                        pushNotifications: document.getElementById('settingsPushNotifications').checked
                    };
                    
                    const saved = await saveSettings(settingsData);
                    if (saved) {
                        // Settings are already saved to localStorage by saveSettings function
                        // Reload dashboard if it's open to show updated username
                        const dashboard = document.getElementById('userDashboard');
                        if (dashboard && dashboard.style.display !== 'none') {
                            if (typeof loadDashboardData === 'function') {
                                loadDashboardData();
                            }
                        }
                    }
                });
                
                // Show/hide wallet address based on payment method
                const paymentMethodSelect = document.getElementById('settingsPaymentMethod');
                if (paymentMethodSelect) {
                    paymentMethodSelect.addEventListener('change', (e) => {
                        const walletContainer = document.getElementById('settingsWalletAddressContainer');
                        if (e.target.value === 'wallet') {
                            walletContainer.classList.remove('hidden');
                        } else {
                            walletContainer.classList.add('hidden');
                        }
                    });
                }
            }
        });
        
        // Initialize: Clear all category selections on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Clear any category selections that might have been set
            if (!currentCategoryFilter) {
                clearCategorySelection();
            }
            
            // Set up How it Works link
            const howItWorksLink = document.getElementById('howItWorksLink');
            if (howItWorksLink) {
                console.log('How it Works link found, attaching event listener');
                howItWorksLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('How it Works link clicked');
                    if (window.openHowItWorks) {
                        window.openHowItWorks();
                    } else {
                        console.error('openHowItWorks function not found on window');
                    }
                    return false;
                });
            } else {
                console.error('howItWorksLink element not found');
            }
            
            // Set up Account button click handler
            const accountButton = document.getElementById('accountButton');
            if (accountButton) {
                console.log('Account button found, attaching event listener');
                accountButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Account button clicked via event listener');
                    if (typeof handleAccountClick === 'function') {
                        handleAccountClick(e);
                    } else if (typeof window.handleAccountClick === 'function') {
                        window.handleAccountClick(e);
                    } else if (typeof navigateToDashboard === 'function') {
                        navigateToDashboard();
                    } else if (typeof window.navigateToDashboard === 'function') {
                        window.navigateToDashboard();
                    } else {
                        console.error('Account navigation functions not found');
                        alert('Account navigation not available');
                    }
                });
            } else {
                console.error('Account button element not found');
            }
            
            // Set up category scroll arrows
            const container = document.getElementById('categoryScrollContainer');
            if (container) {
                // Update arrows on scroll
                container.addEventListener('scroll', updateCategoryScrollArrows);
                // Update arrows on window resize
                window.addEventListener('resize', updateCategoryScrollArrows);
                // Initial check
                setTimeout(updateCategoryScrollArrows, 100);
            }
            
            // Start live updates for market percentages
            startLiveUpdates();
        });
        
        // Live-time percentage update system
        function updateMarketPercentages() {
            markets.forEach(market => {
                const totalVolume = market.volume || 0;
                
                // Only update markets with volume (active trading)
                if (totalVolume > 0) {
                    // Simulate live trading activity (in real app, this would come from blockchain/backend)
                    // Small random fluctuations to simulate real-time trading
                    if (!market.percentages || market.percentages.length !== market.outcomes.length) {
                        // Initialize if not set
                        const basePercentages = market.outcomes.map(() => Math.random() * 100);
                        const sum = basePercentages.reduce((a, b) => a + b, 0);
                        market.percentages = basePercentages.map(p => Math.round((p / sum) * 100));
                    } else {
                        // Add small random fluctuations (¬±2%) to simulate live trading
                        market.percentages = market.percentages.map(p => {
                            const change = (Math.random() - 0.5) * 4; // -2% to +2%
                            return Math.max(0, Math.min(100, Math.round(p + change)));
                        });
                        
                        // Normalize to ensure sum is 100
                        const sum = market.percentages.reduce((a, b) => a + b, 0);
                        if (sum > 0 && sum !== 100) {
                            market.percentages = market.percentages.map(p => Math.round((p / sum) * 100));
                        }
                    }
                }
            });
            
            // Re-render markets to show updated percentages
            renderMarkets();
        }
        
        let liveUpdateInterval = null;
        
        function startLiveUpdates() {
            // Update every 3 seconds for live-time feel
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
            }
            liveUpdateInterval = setInterval(updateMarketPercentages, 3000);
        }
        
        function stopLiveUpdates() {
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
                liveUpdateInterval = null;
            }
        }
    </script>
</body>
</html>
